//
// dp_multisettest.cpp test
//
//		generated by gendptest, 2018/12/19
//

#include <dptl/dp_set.hpp>
#include <dptl/utest.hpp>
#include <dptl/udata.hpp>
#include <cstring>

using namespace dptl;

// Unit Test Classes
// -----------------------------------------------------------------------------
class dp_multisettest : public unittest, public basic_testdata
{
	int		m_cnt;

    public:
	// --- constructor/assignment/destructor ---
	void test01();
	void test02();
	void test03();
	void test04();
	void test05();
	void test06();
	void test07();
	void test08();
	void test09();

	// --- find/lower_bound/upper_bound/equal_range ---
	void test0A();
	void test0B();
	void test0C();
	void test0D();
	void test0E();
	void test0F();
	void test10();
	void test11();
	void test12();

	// --- emplace/insert/erase ---
	void test13();
	void test14();
	void test15();
	void test16();
	void test17();
	void test18();
	void test19();
	void test1A();
	void test1B();

	// --- iterator ---
	void test1C();
	void test1D();
	void test1E();
	void test1F();
	void test20();
	void test21();
	void test22();
	void test23();
	void test24();

	// --- miscellaneous (swap/count/size/empty/clear) ---
	void test25();
	void test26();
	void test27();
	void test28();
	void test29();
	void test2A();
	void test2B();
	void test2C();
	void test2D();

	// --- relational operators ---
	void test2E();
	void test2F();
	void test30();
	void test31();
	void test32();
	void test33();
	void test34();
	void test35();
	void test36();

	dp_multisettest( int argc, char** argv ) : unittest( argc, argv )
	{
		m_cnt = test::getCntr();
		fprintf( stderr, "*** test::getCntr() : %d\n", m_cnt );
	}

	~dp_multisettest()
	{
		this->set_subtitle( "test class allocation" );
		AssertEqual( m_cnt, test::getCntr() );
		fprintf( stderr, "\n" );
	}
};

#include <dptl/dp_set.hpp>

// Testdata Check Utilities
// -----------------------------------------------------------------------------
template <typename T>
inline bool check_multiset( dp_multiset<T> const& ls, std::initializer_list<typename value_p<T>::t> const& ts )
{
	rp_multiset<T> l;

	for ( auto&& a : ts ) l.emplace( a );

	return ls == reinterpret_cast<dp_multiset<T> const&>( l );
}

template <typename T>
inline bool check_multiset( rp_multiset<T> const& ls, std::initializer_list<typename value_p<T>::t> const& ts )
{
	rp_multiset<T> l;

	for ( auto&& a : ts ) l.emplace( a );

	return ls == l;
}

template <typename T>
inline bool check_multiset( std::multiset<T> const& ls, std::initializer_list<T> const& ts )
{
	std::multiset<T>     l;

	for ( auto a : ts ) l.emplace( a );

	return ls == l;
}

// -----------------------------------------------------------------------------
void dp_multisettest::test01()
{
	this->set_subtitle( "constructor/assignment/destructor - reference pointer(pointer) value" );

	// default constructor
	rp_multiset<test*>		lr;
	AssertTrue( check_multiset( lr, { } ));

	// copy constructor
	rp_multiset<test*>		p0( lr );
	const rp_multiset<test*>	c0( lr );
	lr.insert( &t1 );
	rp_multiset<test*>		p1( lr );
	const rp_multiset<test*>	c1( lr );
	lr.insert( &t2 );
	lr.insert( &t3 );
	lr.insert( &t3 );
	lr.insert( &t3 );
	lr.insert( &t4 );
	lr.insert( &t5 );
	rp_multiset<test*>		p5( lr );
	const rp_multiset<test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multiset( p1, { &t1 } ));
	AssertTrue( check_multiset( p5, { &t1, &t2, &t3, &t3, &t3, &t4, &t5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_multiset( c1, { &t1 } ));
	AssertTrue( check_multiset( c5, { &t1, &t2, &t3, &t3, &t3, &t4, &t5 } ));

	// move constructor
	{
		rp_multiset<test*>   lx = lr;
		rp_multiset<test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multiset( ly, { &t1, &t2, &t3, &t3, &t3, &t4, &t5 } ));
	}
	// copy assignment operator
	{
		rp_multiset<test*>   lx;

		lx = p1;
		AssertTrue( check_multiset( lx, { &t1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multiset( lx, { &t1, &t2, &t3, &t3, &t3, &t4, &t5 } ));
	}
	// move assignment operator
	{
		rp_multiset<test*>   lx;

		lr = p1;
		lx = rp_multiset<test*>( { &t5, &t5, &t2 } );		// move assignment by r-value
		AssertTrue( check_multiset( lx, { &t5, &t5, &t2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_multiset( lx, { &t1 } ));
		AssertTrue( check_multiset( lr, {} ));			// not mandatory

		lx = std::move( lx );	
		AssertTrue( check_multiset( lx, {} ));			// not mandatory
	}
	// iterator constructor
	{
		rp_multiset<test*>   lx = p5;
		rp_multiset<test*>::iterator	i = lx.find( &t4 );

		rp_multiset<test*>   x3( lx.begin(), i );
		AssertTrue( check_multiset( x3, { &t1, &t2, &t3, &t3, &t3 } ));
		rp_multiset<test*>   x0( i, i );
		AssertTrue( x0.empty());
		rp_multiset<test*>   x1( i, lx.end());
		AssertTrue( check_multiset( x1, { &t4, &t5 } ));
	}
	// initializer constructor/assignment operator
	{
		rp_multiset<test*>   lx = p5;
		rp_multiset<test*>   x0 { };
		rp_multiset<test*>   x1 { &t1 };
		rp_multiset<test*>   x5 { &t1, &t2, &t3, &t3, &t3, &t4, &t5 };

		AssertTrue( x0.empty());
		AssertTrue( check_multiset( x1, { &t1 } ));
		AssertTrue( check_multiset( x5, { &t1, &t2, &t3, &t3, &t3, &t4, &t5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { &t1 };
		AssertTrue( check_multiset( lx, { &t1 } ));
		lx = { &t1, &t2, &t3, &t3, &t3, &t4, &t5 };
		AssertTrue( check_multiset( lx, { &t1, &t2, &t3, &t3, &t3, &t4, &t5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test02()
{
	this->set_subtitle( "constructor/assignment/destructor - deep pointer(pointer) value" );

	// default constructor
	dp_multiset<test*>		lr;
	AssertTrue( check_multiset( lr, { } ));

	// copy constructor
	dp_multiset<test*>		p0( lr );
	const dp_multiset<test*>	c0( lr );
	lr.insert( dpl( &t1 ) );
	dp_multiset<test*>		p1( lr );
	const dp_multiset<test*>	c1( lr );
	lr.insert( dpl( &t2 ) );
	lr.insert( dpl( &t3 ) );
	lr.insert( dpl( &t3 ) );
	lr.insert( dpl( &t3 ) );
	lr.insert( dpl( &t4 ) );
	lr.insert( dpl( &t5 ) );
	dp_multiset<test*>		p5( lr );
	const dp_multiset<test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multiset( p1, { &t1 } ));
	AssertTrue( check_multiset( p5, { &t1, &t2, &t3, &t3, &t3, &t4, &t5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_multiset( c1, { &t1 } ));
	AssertTrue( check_multiset( c5, { &t1, &t2, &t3, &t3, &t3, &t4, &t5 } ));

	// move constructor
	{
		dp_multiset<test*>   lx = lr;
		dp_multiset<test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multiset( ly, { &t1, &t2, &t3, &t3, &t3, &t4, &t5 } ));
	}
	// copy assignment operator
	{
		dp_multiset<test*>   lx;

		lx = p1;
		AssertTrue( check_multiset( lx, { &t1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multiset( lx, { &t1, &t2, &t3, &t3, &t3, &t4, &t5 } ));
	}
	// move assignment operator
	{
		dp_multiset<test*>   lx;

		lr = p1;
		lx = dp_multiset<test*>( { &t5, &t5, &t2 } );		// move assignment by r-value
		AssertTrue( check_multiset( lx, { &t5, &t5, &t2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_multiset( lx, { &t1 } ));
		AssertTrue( check_multiset( lr, {} ));			// not mandatory

		lx = std::move( lx );	
		AssertTrue( check_multiset( lx, {} ));			// not mandatory
	}
	// iterator constructor
	{
		dp_multiset<test*>   lx = p5;
		dp_multiset<test*>::iterator	i = lx.find( &t4 );

		dp_multiset<test*>   x3( lx.begin(), i );
		AssertTrue( check_multiset( x3, { &t1, &t2, &t3, &t3, &t3 } ));
		dp_multiset<test*>   x0( i, i );
		AssertTrue( x0.empty());
		dp_multiset<test*>   x1( i, lx.end());
		AssertTrue( check_multiset( x1, { &t4, &t5 } ));
	}
	// initializer constructor/assignment operator
	{
		dp_multiset<test*>   lx = p5;
		dp_multiset<test*>   x0 { };
		dp_multiset<test*>   x1 { &t1 };
		dp_multiset<test*>   x5 { &t1, &t2, &t3, &t3, &t3, &t4, &t5 };

		AssertTrue( x0.empty());
		AssertTrue( check_multiset( x1, { &t1 } ));
		AssertTrue( check_multiset( x5, { &t1, &t2, &t3, &t3, &t3, &t4, &t5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { &t1 };
		AssertTrue( check_multiset( lx, { &t1 } ));
		lx = { &t1, &t2, &t3, &t3, &t3, &t4, &t5 };
		AssertTrue( check_multiset( lx, { &t1, &t2, &t3, &t3, &t3, &t4, &t5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test03()
{
	this->set_subtitle( "constructor/assignment/destructor - reference pointer(c-string) value" );

	// default constructor
	rp_multiset<const char[]>		lr;
	AssertTrue( check_multiset( lr, { } ));

	// copy constructor
	rp_multiset<const char[]>		p0( lr );
	const rp_multiset<const char[]>	c0( lr );
	lr.insert( s1 );
	rp_multiset<const char[]>		p1( lr );
	const rp_multiset<const char[]>	c1( lr );
	lr.insert( s2 );
	lr.insert( s3 );
	lr.insert( s3 );
	lr.insert( s3 );
	lr.insert( s4 );
	lr.insert( s5 );
	rp_multiset<const char[]>		p5( lr );
	const rp_multiset<const char[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multiset( p1, { s1 } ));
	AssertTrue( check_multiset( p5, { s1, s2, s3, s3, s3, s4, s5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_multiset( c1, { s1 } ));
	AssertTrue( check_multiset( c5, { s1, s2, s3, s3, s3, s4, s5 } ));

	// move constructor
	{
		rp_multiset<const char[]>   lx = lr;
		rp_multiset<const char[]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multiset( ly, { s1, s2, s3, s3, s3, s4, s5 } ));
	}
	// copy assignment operator
	{
		rp_multiset<const char[]>   lx;

		lx = p1;
		AssertTrue( check_multiset( lx, { s1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multiset( lx, { s1, s2, s3, s3, s3, s4, s5 } ));
	}
	// move assignment operator
	{
		rp_multiset<const char[]>   lx;

		lr = p1;
		lx = rp_multiset<const char[]>( { s5, s5, s2 } );		// move assignment by r-value
		AssertTrue( check_multiset( lx, { s5, s5, s2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_multiset( lx, { s1 } ));
		AssertTrue( check_multiset( lr, {} ));			// not mandatory

		lx = std::move( lx );	
		AssertTrue( check_multiset( lx, {} ));			// not mandatory
	}
	// iterator constructor
	{
		rp_multiset<const char[]>   lx = p5;
		rp_multiset<const char[]>::iterator	i = lx.find( s4 );

		rp_multiset<const char[]>   x3( lx.begin(), i );
		AssertTrue( check_multiset( x3, { s1, s2, s3, s3, s3 } ));
		rp_multiset<const char[]>   x0( i, i );
		AssertTrue( x0.empty());
		rp_multiset<const char[]>   x1( i, lx.end());
		AssertTrue( check_multiset( x1, { s4, s5 } ));
	}
	// initializer constructor/assignment operator
	{
		rp_multiset<const char[]>   lx = p5;
		rp_multiset<const char[]>   x0 { };
		rp_multiset<const char[]>   x1 { s1 };
		rp_multiset<const char[]>   x5 { s1, s2, s3, s3, s3, s4, s5 };

		AssertTrue( x0.empty());
		AssertTrue( check_multiset( x1, { s1 } ));
		AssertTrue( check_multiset( x5, { s1, s2, s3, s3, s3, s4, s5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { s1 };
		AssertTrue( check_multiset( lx, { s1 } ));
		lx = { s1, s2, s3, s3, s3, s4, s5 };
		AssertTrue( check_multiset( lx, { s1, s2, s3, s3, s3, s4, s5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test04()
{
	this->set_subtitle( "constructor/assignment/destructor - deep pointer(c-string) value" );

	// default constructor
	dp_multiset<const char[]>		lr;
	AssertTrue( check_multiset( lr, { } ));

	// copy constructor
	dp_multiset<const char[]>		p0( lr );
	const dp_multiset<const char[]>	c0( lr );
	lr.insert( strdup( s1 ) );
	dp_multiset<const char[]>		p1( lr );
	const dp_multiset<const char[]>	c1( lr );
	lr.insert( strdup( s2 ) );
	lr.insert( strdup( s3 ) );
	lr.insert( strdup( s3 ) );
	lr.insert( strdup( s3 ) );
	lr.insert( strdup( s4 ) );
	lr.insert( strdup( s5 ) );
	dp_multiset<const char[]>		p5( lr );
	const dp_multiset<const char[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multiset( p1, { s1 } ));
	AssertTrue( check_multiset( p5, { s1, s2, s3, s3, s3, s4, s5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_multiset( c1, { s1 } ));
	AssertTrue( check_multiset( c5, { s1, s2, s3, s3, s3, s4, s5 } ));

	// move constructor
	{
		dp_multiset<const char[]>   lx = lr;
		dp_multiset<const char[]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multiset( ly, { s1, s2, s3, s3, s3, s4, s5 } ));
	}
	// copy assignment operator
	{
		dp_multiset<const char[]>   lx;

		lx = p1;
		AssertTrue( check_multiset( lx, { s1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multiset( lx, { s1, s2, s3, s3, s3, s4, s5 } ));
	}
	// move assignment operator
	{
		dp_multiset<const char[]>   lx;

		lr = p1;
		lx = dp_multiset<const char[]>( { s5, s5, s2 } );		// move assignment by r-value
		AssertTrue( check_multiset( lx, { s5, s5, s2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_multiset( lx, { s1 } ));
		AssertTrue( check_multiset( lr, {} ));			// not mandatory

		lx = std::move( lx );	
		AssertTrue( check_multiset( lx, {} ));			// not mandatory
	}
	// iterator constructor
	{
		dp_multiset<const char[]>   lx = p5;
		dp_multiset<const char[]>::iterator	i = lx.find( s4 );

		dp_multiset<const char[]>   x3( lx.begin(), i );
		AssertTrue( check_multiset( x3, { s1, s2, s3, s3, s3 } ));
		dp_multiset<const char[]>   x0( i, i );
		AssertTrue( x0.empty());
		dp_multiset<const char[]>   x1( i, lx.end());
		AssertTrue( check_multiset( x1, { s4, s5 } ));
	}
	// initializer constructor/assignment operator
	{
		dp_multiset<const char[]>   lx = p5;
		dp_multiset<const char[]>   x0 { };
		dp_multiset<const char[]>   x1 { s1 };
		dp_multiset<const char[]>   x5 { s1, s2, s3, s3, s3, s4, s5 };

		AssertTrue( x0.empty());
		AssertTrue( check_multiset( x1, { s1 } ));
		AssertTrue( check_multiset( x5, { s1, s2, s3, s3, s3, s4, s5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { s1 };
		AssertTrue( check_multiset( lx, { s1 } ));
		lx = { s1, s2, s3, s3, s3, s4, s5 };
		AssertTrue( check_multiset( lx, { s1, s2, s3, s3, s3, s4, s5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test05()
{
	this->set_subtitle( "constructor/assignment/destructor - reference pointer(v-array) value" );

	// default constructor
	rp_multiset<test[]>		lr;
	AssertTrue( check_multiset( lr, { } ));

	// copy constructor
	rp_multiset<test[]>		p0( lr );
	const rp_multiset<test[]>	c0( lr );
	lr.insert( v1 );
	rp_multiset<test[]>		p1( lr );
	const rp_multiset<test[]>	c1( lr );
	lr.insert( v2 );
	lr.insert( v3 );
	lr.insert( v3 );
	lr.insert( v3 );
	lr.insert( v4 );
	lr.insert( v5 );
	rp_multiset<test[]>		p5( lr );
	const rp_multiset<test[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multiset( p1, { v1 } ));
	AssertTrue( check_multiset( p5, { v1, v2, v3, v3, v3, v4, v5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_multiset( c1, { v1 } ));
	AssertTrue( check_multiset( c5, { v1, v2, v3, v3, v3, v4, v5 } ));

	// move constructor
	{
		rp_multiset<test[]>   lx = lr;
		rp_multiset<test[]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multiset( ly, { v1, v2, v3, v3, v3, v4, v5 } ));
	}
	// copy assignment operator
	{
		rp_multiset<test[]>   lx;

		lx = p1;
		AssertTrue( check_multiset( lx, { v1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multiset( lx, { v1, v2, v3, v3, v3, v4, v5 } ));
	}
	// move assignment operator
	{
		rp_multiset<test[]>   lx;

		lr = p1;
		lx = rp_multiset<test[]>( { v5, v5, v2 } );		// move assignment by r-value
		AssertTrue( check_multiset( lx, { v5, v5, v2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_multiset( lx, { v1 } ));
		AssertTrue( check_multiset( lr, {} ));			// not mandatory

		lx = std::move( lx );	
		AssertTrue( check_multiset( lx, {} ));			// not mandatory
	}
	// iterator constructor
	{
		rp_multiset<test[]>   lx = p5;
		rp_multiset<test[]>::iterator	i = lx.find( v4 );

		rp_multiset<test[]>   x3( lx.begin(), i );
		AssertTrue( check_multiset( x3, { v1, v2, v3, v3, v3 } ));
		rp_multiset<test[]>   x0( i, i );
		AssertTrue( x0.empty());
		rp_multiset<test[]>   x1( i, lx.end());
		AssertTrue( check_multiset( x1, { v4, v5 } ));
	}
	// initializer constructor/assignment operator
	{
		rp_multiset<test[]>   lx = p5;
		rp_multiset<test[]>   x0 { };
		rp_multiset<test[]>   x1 { v1 };
		rp_multiset<test[]>   x5 { v1, v2, v3, v3, v3, v4, v5 };

		AssertTrue( x0.empty());
		AssertTrue( check_multiset( x1, { v1 } ));
		AssertTrue( check_multiset( x5, { v1, v2, v3, v3, v3, v4, v5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { v1 };
		AssertTrue( check_multiset( lx, { v1 } ));
		lx = { v1, v2, v3, v3, v3, v4, v5 };
		AssertTrue( check_multiset( lx, { v1, v2, v3, v3, v3, v4, v5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test06()
{
	this->set_subtitle( "constructor/assignment/destructor - deep pointer(v-array) value" );

	// default constructor
	dp_multiset<test[]>		lr;
	AssertTrue( check_multiset( lr, { } ));

	// copy constructor
	dp_multiset<test[]>		p0( lr );
	const dp_multiset<test[]>	c0( lr );
	lr.insert( dpl( v1 ) );
	dp_multiset<test[]>		p1( lr );
	const dp_multiset<test[]>	c1( lr );
	lr.insert( dpl( v2 ) );
	lr.insert( dpl( v3 ) );
	lr.insert( dpl( v3 ) );
	lr.insert( dpl( v3 ) );
	lr.insert( dpl( v4 ) );
	lr.insert( dpl( v5 ) );
	dp_multiset<test[]>		p5( lr );
	const dp_multiset<test[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multiset( p1, { v1 } ));
	AssertTrue( check_multiset( p5, { v1, v2, v3, v3, v3, v4, v5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_multiset( c1, { v1 } ));
	AssertTrue( check_multiset( c5, { v1, v2, v3, v3, v3, v4, v5 } ));

	// move constructor
	{
		dp_multiset<test[]>   lx = lr;
		dp_multiset<test[]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multiset( ly, { v1, v2, v3, v3, v3, v4, v5 } ));
	}
	// copy assignment operator
	{
		dp_multiset<test[]>   lx;

		lx = p1;
		AssertTrue( check_multiset( lx, { v1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multiset( lx, { v1, v2, v3, v3, v3, v4, v5 } ));
	}
	// move assignment operator
	{
		dp_multiset<test[]>   lx;

		lr = p1;
		lx = dp_multiset<test[]>( { v5, v5, v2 } );		// move assignment by r-value
		AssertTrue( check_multiset( lx, { v5, v5, v2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_multiset( lx, { v1 } ));
		AssertTrue( check_multiset( lr, {} ));			// not mandatory

		lx = std::move( lx );	
		AssertTrue( check_multiset( lx, {} ));			// not mandatory
	}
	// iterator constructor
	{
		dp_multiset<test[]>   lx = p5;
		dp_multiset<test[]>::iterator	i = lx.find( v4 );

		dp_multiset<test[]>   x3( lx.begin(), i );
		AssertTrue( check_multiset( x3, { v1, v2, v3, v3, v3 } ));
		dp_multiset<test[]>   x0( i, i );
		AssertTrue( x0.empty());
		dp_multiset<test[]>   x1( i, lx.end());
		AssertTrue( check_multiset( x1, { v4, v5 } ));
	}
	// initializer constructor/assignment operator
	{
		dp_multiset<test[]>   lx = p5;
		dp_multiset<test[]>   x0 { };
		dp_multiset<test[]>   x1 { v1 };
		dp_multiset<test[]>   x5 { v1, v2, v3, v3, v3, v4, v5 };

		AssertTrue( x0.empty());
		AssertTrue( check_multiset( x1, { v1 } ));
		AssertTrue( check_multiset( x5, { v1, v2, v3, v3, v3, v4, v5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { v1 };
		AssertTrue( check_multiset( lx, { v1 } ));
		lx = { v1, v2, v3, v3, v3, v4, v5 };
		AssertTrue( check_multiset( lx, { v1, v2, v3, v3, v3, v4, v5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test07()
{
	this->set_subtitle( "constructor/assignment/destructor - reference pointer(f-array) value" );

	// default constructor
	rp_multiset<test[3]>		lr;
	AssertTrue( check_multiset( lr, { } ));

	// copy constructor
	rp_multiset<test[3]>		p0( lr );
	const rp_multiset<test[3]>	c0( lr );
	lr.insert( w1 );
	rp_multiset<test[3]>		p1( lr );
	const rp_multiset<test[3]>	c1( lr );
	lr.insert( w2 );
	lr.insert( w3 );
	lr.insert( w3 );
	lr.insert( w3 );
	lr.insert( w4 );
	lr.insert( w5 );
	rp_multiset<test[3]>		p5( lr );
	const rp_multiset<test[3]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multiset( p1, { w1 } ));
	AssertTrue( check_multiset( p5, { w1, w2, w3, w3, w3, w4, w5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_multiset( c1, { w1 } ));
	AssertTrue( check_multiset( c5, { w1, w2, w3, w3, w3, w4, w5 } ));

	// move constructor
	{
		rp_multiset<test[3]>   lx = lr;
		rp_multiset<test[3]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multiset( ly, { w1, w2, w3, w3, w3, w4, w5 } ));
	}
	// copy assignment operator
	{
		rp_multiset<test[3]>   lx;

		lx = p1;
		AssertTrue( check_multiset( lx, { w1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multiset( lx, { w1, w2, w3, w3, w3, w4, w5 } ));
	}
	// move assignment operator
	{
		rp_multiset<test[3]>   lx;

		lr = p1;
		lx = rp_multiset<test[3]>( { w5, w5, w2 } );		// move assignment by r-value
		AssertTrue( check_multiset( lx, { w5, w5, w2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_multiset( lx, { w1 } ));
		AssertTrue( check_multiset( lr, {} ));			// not mandatory

		lx = std::move( lx );	
		AssertTrue( check_multiset( lx, {} ));			// not mandatory
	}
	// iterator constructor
	{
		rp_multiset<test[3]>   lx = p5;
		rp_multiset<test[3]>::iterator	i = lx.find( w4 );

		rp_multiset<test[3]>   x3( lx.begin(), i );
		AssertTrue( check_multiset( x3, { w1, w2, w3, w3, w3 } ));
		rp_multiset<test[3]>   x0( i, i );
		AssertTrue( x0.empty());
		rp_multiset<test[3]>   x1( i, lx.end());
		AssertTrue( check_multiset( x1, { w4, w5 } ));
	}
	// initializer constructor/assignment operator
	{
		rp_multiset<test[3]>   lx = p5;
		rp_multiset<test[3]>   x0 { };
		rp_multiset<test[3]>   x1 { w1 };
		rp_multiset<test[3]>   x5 { w1, w2, w3, w3, w3, w4, w5 };

		AssertTrue( x0.empty());
		AssertTrue( check_multiset( x1, { w1 } ));
		AssertTrue( check_multiset( x5, { w1, w2, w3, w3, w3, w4, w5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { w1 };
		AssertTrue( check_multiset( lx, { w1 } ));
		lx = { w1, w2, w3, w3, w3, w4, w5 };
		AssertTrue( check_multiset( lx, { w1, w2, w3, w3, w3, w4, w5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test08()
{
	this->set_subtitle( "constructor/assignment/destructor - deep pointer(f-array) value" );

	// default constructor
	dp_multiset<test[3]>		lr;
	AssertTrue( check_multiset( lr, { } ));

	// copy constructor
	dp_multiset<test[3]>		p0( lr );
	const dp_multiset<test[3]>	c0( lr );
	lr.insert( dpl( w1 ) );
	dp_multiset<test[3]>		p1( lr );
	const dp_multiset<test[3]>	c1( lr );
	lr.insert( dpl( w2 ) );
	lr.insert( dpl( w3 ) );
	lr.insert( dpl( w3 ) );
	lr.insert( dpl( w3 ) );
	lr.insert( dpl( w4 ) );
	lr.insert( dpl( w5 ) );
	dp_multiset<test[3]>		p5( lr );
	const dp_multiset<test[3]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multiset( p1, { w1 } ));
	AssertTrue( check_multiset( p5, { w1, w2, w3, w3, w3, w4, w5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_multiset( c1, { w1 } ));
	AssertTrue( check_multiset( c5, { w1, w2, w3, w3, w3, w4, w5 } ));

	// move constructor
	{
		dp_multiset<test[3]>   lx = lr;
		dp_multiset<test[3]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multiset( ly, { w1, w2, w3, w3, w3, w4, w5 } ));
	}
	// copy assignment operator
	{
		dp_multiset<test[3]>   lx;

		lx = p1;
		AssertTrue( check_multiset( lx, { w1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multiset( lx, { w1, w2, w3, w3, w3, w4, w5 } ));
	}
	// move assignment operator
	{
		dp_multiset<test[3]>   lx;

		lr = p1;
		lx = dp_multiset<test[3]>( { w5, w5, w2 } );		// move assignment by r-value
		AssertTrue( check_multiset( lx, { w5, w5, w2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_multiset( lx, { w1 } ));
		AssertTrue( check_multiset( lr, {} ));			// not mandatory

		lx = std::move( lx );	
		AssertTrue( check_multiset( lx, {} ));			// not mandatory
	}
	// iterator constructor
	{
		dp_multiset<test[3]>   lx = p5;
		dp_multiset<test[3]>::iterator	i = lx.find( w4 );

		dp_multiset<test[3]>   x3( lx.begin(), i );
		AssertTrue( check_multiset( x3, { w1, w2, w3, w3, w3 } ));
		dp_multiset<test[3]>   x0( i, i );
		AssertTrue( x0.empty());
		dp_multiset<test[3]>   x1( i, lx.end());
		AssertTrue( check_multiset( x1, { w4, w5 } ));
	}
	// initializer constructor/assignment operator
	{
		dp_multiset<test[3]>   lx = p5;
		dp_multiset<test[3]>   x0 { };
		dp_multiset<test[3]>   x1 { w1 };
		dp_multiset<test[3]>   x5 { w1, w2, w3, w3, w3, w4, w5 };

		AssertTrue( x0.empty());
		AssertTrue( check_multiset( x1, { w1 } ));
		AssertTrue( check_multiset( x5, { w1, w2, w3, w3, w3, w4, w5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { w1 };
		AssertTrue( check_multiset( lx, { w1 } ));
		lx = { w1, w2, w3, w3, w3, w4, w5 };
		AssertTrue( check_multiset( lx, { w1, w2, w3, w3, w3, w4, w5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test09()
{
	this->set_subtitle( "constructor/assignment/destructor - data(int value) value" );

	// default constructor
	std::multiset<int>		lr;
	AssertTrue( check_multiset( lr, { } ));

	// copy constructor
	std::multiset<int>		p0( lr );
	const std::multiset<int>	c0( lr );
	lr.insert( 1 );
	std::multiset<int>		p1( lr );
	const std::multiset<int>	c1( lr );
	lr.insert( 2 );
	lr.insert( 3 );
	lr.insert( 3 );
	lr.insert( 3 );
	lr.insert( 4 );
	lr.insert( 5 );
	std::multiset<int>		p5( lr );
	const std::multiset<int>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multiset( p1, { 1 } ));
	AssertTrue( check_multiset( p5, { 1, 2, 3, 3, 3, 4, 5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_multiset( c1, { 1 } ));
	AssertTrue( check_multiset( c5, { 1, 2, 3, 3, 3, 4, 5 } ));

	// move constructor
	{
		std::multiset<int>   lx = lr;
		std::multiset<int>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multiset( ly, { 1, 2, 3, 3, 3, 4, 5 } ));
	}
	// copy assignment operator
	{
		std::multiset<int>   lx;

		lx = p1;
		AssertTrue( check_multiset( lx, { 1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multiset( lx, { 1, 2, 3, 3, 3, 4, 5 } ));
	}
	// move assignment operator
	{
		std::multiset<int>   lx;

		lr = p1;
		lx = std::multiset<int>( { 5, 5, 2 } );		// move assignment by r-value
		AssertTrue( check_multiset( lx, { 5, 5, 2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_multiset( lx, { 1 } ));
		AssertTrue( check_multiset( lr, {} ));			// not mandatory

		lx = std::move( lx );	
		AssertTrue( check_multiset( lx, {} ));			// not mandatory
	}
	// iterator constructor
	{
		std::multiset<int>   lx = p5;
		std::multiset<int>::iterator	i = lx.find( 4 );

		std::multiset<int>   x3( lx.begin(), i );
		AssertTrue( check_multiset( x3, { 1, 2, 3, 3, 3 } ));
		std::multiset<int>   x0( i, i );
		AssertTrue( x0.empty());
		std::multiset<int>   x1( i, lx.end());
		AssertTrue( check_multiset( x1, { 4, 5 } ));
	}
	// initializer constructor/assignment operator
	{
		std::multiset<int>   lx = p5;
		std::multiset<int>   x0 { };
		std::multiset<int>   x1 { 1 };
		std::multiset<int>   x5 { 1, 2, 3, 3, 3, 4, 5 };

		AssertTrue( x0.empty());
		AssertTrue( check_multiset( x1, { 1 } ));
		AssertTrue( check_multiset( x5, { 1, 2, 3, 3, 3, 4, 5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { 1 };
		AssertTrue( check_multiset( lx, { 1 } ));
		lx = { 1, 2, 3, 3, 3, 4, 5 };
		AssertTrue( check_multiset( lx, { 1, 2, 3, 3, 3, 4, 5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test0A()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range - reference pointer(pointer) value" );

	rp_multiset<test*>      s = { &t1, &t2, &t5, &t8, &t4, &t2, &t3, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2 };

	print( s );

	AssertNotEqual( s.find( &t4 ), s.end());
	AssertEqual( *s.find( &t4 ), &t4 );
	AssertEqual( **s.find( &t4 ), t4 );
	// **s.find( &t4 ) = t5;		 // compile error, the value is the key of binary search-tree

	AssertEqual( s.find( &t7 ), s.end());
	// AssertEqual( *s.find( &t7 ), nullptr );    // runtime error

	// null value
	AssertEqual( s.find( nullptr ), s.end());
	s.insert( nullptr );
	AssertNotEqual( s.find( nullptr ), s.end());
	AssertEqual( *s.find( nullptr ), nullptr );

	AssertTrue( check_multiset( s, { &t1, &t2, &t5, &t8, &t4, &t2, &t3, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2, nullptr } ));

	rp_multiset<test*>		      l1, r1, l2, r2, l3, r3, l4, r4, l5, r5;
	rp_multiset<test*>::iterator    b, e;

	// [&t4.->.&t4)
	b = s.find( &t4 );
	e = s.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multiset( l1, { &t4, &t4, &t4, &t4 } ));

	// (&t4.<-.&t4]
	b = s.find( &t4 );
	e = s.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multiset( r1, { } ));

	// [.->.&t4]
	b = s.begin();
	e = s.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multiset( l2, { nullptr, &t1, &t1, &t2, &t2, &t2, &t3, &t3, &t3, &t4, &t4, &t4, &t4 } ));

	// [&t4.<-.]
	b = s.find( &t8 );
	e = s.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multiset( r2, { &t4, &t4, &t4, &t5, &t5, &t8 } ));

	// [.->.&t4)
	b = s.begin();
	e = s.upper_bound( &t3 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multiset( l3, { nullptr, &t1, &t1, &t2, &t2, &t2, &t3, &t3, &t3 } ));

	// (&t4.<-.]
	b = s.find( &t8 );
	e = s.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r3.insert( *i );
	AssertTrue( check_multiset( r3, { &t4, &t4, &t4, &t5, &t5, &t8 } ));

	// [&t4.->.)
	b = s.lower_bound( &t4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multiset( l4, { &t4, &t4, &t4, &t4, &t5, &t5, &t8 } ));

	// (.<-.&t4]
	b = s.upper_bound( &t4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multiset( r4, { &t1, &t1, &t2, &t2, &t2, &t3, &t3, &t3, &t4, &t4, &t4, &t4, &t5 } ));

	// (&t4.->.)
	b = s.upper_bound( &t4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l5.insert( *i );
	AssertTrue( check_multiset( l5, { &t5, &t5, &t8 } ));

	// (.<-.&t4)
	b = s.lower_bound( &t4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multiset( r5, { &t1, &t1, &t2, &t2, &t2, &t3, &t3, &t3, &t4 } ));

	// lowest key
	AssertEqual( s.lower_bound( nullptr ), s.find( nullptr ));
	AssertEqual( s.upper_bound( &t8 ), s.end());
}

// -----------------------------------------------------------------------------
void dp_multisettest::test0B()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range - deep pointer(pointer) value" );

	dp_multiset<test*>      s = { &t1, &t2, &t5, &t8, &t4, &t2, &t3, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2 };

	print( s );

	AssertNotEqual( s.find( &t4 ), s.end());
	AssertNotEqual( *s.find( &t4 ), &t4 );
	AssertEqual( **s.find( &t4 ), t4 );
	// **s.find( &t4 ) = t5;		 // compile error, the value is the key of binary search-tree

	AssertEqual( s.find( &t7 ), s.end());
	// AssertEqual( *s.find( &t7 ), nullptr );    // runtime error

	// null value
	AssertEqual( s.find( nullptr ), s.end());
	s.insert( nullptr );
	AssertNotEqual( s.find( nullptr ), s.end());
	AssertEqual( *s.find( nullptr ), nullptr );

	AssertTrue( check_multiset( s, { &t1, &t2, &t5, &t8, &t4, &t2, &t3, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2, nullptr } ));

	rp_multiset<test*>		      l1, r1, l2, r2, l3, r3, l4, r4, l5, r5;
	dp_multiset<test*>::iterator    b, e;

	// [&t4.->.&t4)
	b = s.find( &t4 );
	e = s.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multiset( l1, { &t4, &t4, &t4, &t4 } ));

	// (&t4.<-.&t4]
	b = s.find( &t4 );
	e = s.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multiset( r1, { } ));

	// [.->.&t4]
	b = s.begin();
	e = s.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multiset( l2, { nullptr, &t1, &t1, &t2, &t2, &t2, &t3, &t3, &t3, &t4, &t4, &t4, &t4 } ));

	// [&t4.<-.]
	b = s.find( &t8 );
	e = s.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multiset( r2, { &t4, &t4, &t4, &t5, &t5, &t8 } ));

	// [.->.&t4)
	b = s.begin();
	e = s.upper_bound( &t3 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multiset( l3, { nullptr, &t1, &t1, &t2, &t2, &t2, &t3, &t3, &t3 } ));

	// (&t4.<-.]
	b = s.find( &t8 );
	e = s.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r3.insert( *i );
	AssertTrue( check_multiset( r3, { &t4, &t4, &t4, &t5, &t5, &t8 } ));

	// [&t4.->.)
	b = s.lower_bound( &t4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multiset( l4, { &t4, &t4, &t4, &t4, &t5, &t5, &t8 } ));

	// (.<-.&t4]
	b = s.upper_bound( &t4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multiset( r4, { &t1, &t1, &t2, &t2, &t2, &t3, &t3, &t3, &t4, &t4, &t4, &t4, &t5 } ));

	// (&t4.->.)
	b = s.upper_bound( &t4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l5.insert( *i );
	AssertTrue( check_multiset( l5, { &t5, &t5, &t8 } ));

	// (.<-.&t4)
	b = s.lower_bound( &t4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multiset( r5, { &t1, &t1, &t2, &t2, &t2, &t3, &t3, &t3, &t4 } ));

	// lowest key
	AssertEqual( s.lower_bound( nullptr ), s.find( nullptr ));
	AssertEqual( s.upper_bound( &t8 ), s.end());
}

// -----------------------------------------------------------------------------
void dp_multisettest::test0C()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range - reference pointer(c-string) value" );

	rp_multiset<const char[]>      s = { s1, s2, s5, s8, s4, s2, s3, s6, s3, s4, s5, s4, s4, s1, s2 };

	print( s );

	AssertNotEqual( s.find( s4 ), s.end());
	AssertEqual( *s.find( s4 ), s4 );

	// **s.find( s4 ) = t5;		 // compile error, the value is the key of binary search-tree

	AssertEqual( s.find( s7 ), s.end());
	// AssertEqual( *s.find( s7 ), nullptr );    // runtime error

	// null value
	AssertEqual( s.find( nullptr ), s.end());
	s.insert( nullptr );
	AssertNotEqual( s.find( nullptr ), s.end());
	AssertEqual( *s.find( nullptr ), nullptr );

	AssertTrue( check_multiset( s, { s1, s2, s5, s8, s4, s2, s3, s6, s3, s4, s5, s4, s4, s1, s2, nullptr } ));

	rp_multiset<const char[]>		      l1, r1, l2, r2, l3, r3, l4, r4, l5, r5;
	rp_multiset<const char[]>::iterator    b, e;

	// [s4.->.s4)
	b = s.find( s4 );
	e = s.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multiset( l1, { s4, s4, s4, s4 } ));

	// (s4.<-.s4]
	b = s.find( s4 );
	e = s.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multiset( r1, { } ));

	// [.->.s4]
	b = s.begin();
	e = s.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multiset( l2, { nullptr, s1, s1, s2, s2, s2, s3, s3, s3, s4, s4, s4, s4 } ));

	// [s4.<-.]
	b = s.find( s8 );
	e = s.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multiset( r2, { s4, s4, s4, s5, s5, s8 } ));

	// [.->.s4)
	b = s.begin();
	e = s.upper_bound( s3 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multiset( l3, { nullptr, s1, s1, s2, s2, s2, s3, s3, s3 } ));

	// (s4.<-.]
	b = s.find( s8 );
	e = s.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r3.insert( *i );
	AssertTrue( check_multiset( r3, { s4, s4, s4, s5, s5, s8 } ));

	// [s4.->.)
	b = s.lower_bound( s4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multiset( l4, { s4, s4, s4, s4, s5, s5, s8 } ));

	// (.<-.s4]
	b = s.upper_bound( s4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multiset( r4, { s1, s1, s2, s2, s2, s3, s3, s3, s4, s4, s4, s4, s5 } ));

	// (s4.->.)
	b = s.upper_bound( s4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l5.insert( *i );
	AssertTrue( check_multiset( l5, { s5, s5, s8 } ));

	// (.<-.s4)
	b = s.lower_bound( s4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multiset( r5, { s1, s1, s2, s2, s2, s3, s3, s3, s4 } ));

	// lowest key
	AssertEqual( s.lower_bound( nullptr ), s.find( nullptr ));
	AssertEqual( s.upper_bound( s8 ), s.end());
}

// -----------------------------------------------------------------------------
void dp_multisettest::test0D()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range - deep pointer(c-string) value" );

	dp_multiset<const char[]>      s = { s1, s2, s5, s8, s4, s2, s3, s6, s3, s4, s5, s4, s4, s1, s2 };

	print( s );

	AssertNotEqual( s.find( s4 ), s.end());
	AssertNotEqual( *s.find( s4 ), s4 );

	// **s.find( s4 ) = t5;		 // compile error, the value is the key of binary search-tree

	AssertEqual( s.find( s7 ), s.end());
	// AssertEqual( *s.find( s7 ), nullptr );    // runtime error

	// null value
	AssertEqual( s.find( nullptr ), s.end());
	s.insert( nullptr );
	AssertNotEqual( s.find( nullptr ), s.end());
	AssertEqual( *s.find( nullptr ), nullptr );

	AssertTrue( check_multiset( s, { s1, s2, s5, s8, s4, s2, s3, s6, s3, s4, s5, s4, s4, s1, s2, nullptr } ));

	rp_multiset<const char[]>		      l1, r1, l2, r2, l3, r3, l4, r4, l5, r5;
	dp_multiset<const char[]>::iterator    b, e;

	// [s4.->.s4)
	b = s.find( s4 );
	e = s.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multiset( l1, { s4, s4, s4, s4 } ));

	// (s4.<-.s4]
	b = s.find( s4 );
	e = s.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multiset( r1, { } ));

	// [.->.s4]
	b = s.begin();
	e = s.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multiset( l2, { nullptr, s1, s1, s2, s2, s2, s3, s3, s3, s4, s4, s4, s4 } ));

	// [s4.<-.]
	b = s.find( s8 );
	e = s.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multiset( r2, { s4, s4, s4, s5, s5, s8 } ));

	// [.->.s4)
	b = s.begin();
	e = s.upper_bound( s3 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multiset( l3, { nullptr, s1, s1, s2, s2, s2, s3, s3, s3 } ));

	// (s4.<-.]
	b = s.find( s8 );
	e = s.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r3.insert( *i );
	AssertTrue( check_multiset( r3, { s4, s4, s4, s5, s5, s8 } ));

	// [s4.->.)
	b = s.lower_bound( s4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multiset( l4, { s4, s4, s4, s4, s5, s5, s8 } ));

	// (.<-.s4]
	b = s.upper_bound( s4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multiset( r4, { s1, s1, s2, s2, s2, s3, s3, s3, s4, s4, s4, s4, s5 } ));

	// (s4.->.)
	b = s.upper_bound( s4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l5.insert( *i );
	AssertTrue( check_multiset( l5, { s5, s5, s8 } ));

	// (.<-.s4)
	b = s.lower_bound( s4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multiset( r5, { s1, s1, s2, s2, s2, s3, s3, s3, s4 } ));

	// lowest key
	AssertEqual( s.lower_bound( nullptr ), s.find( nullptr ));
	AssertEqual( s.upper_bound( s8 ), s.end());
}

// -----------------------------------------------------------------------------
void dp_multisettest::test0E()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range - reference pointer(v-array) value" );

	rp_multiset<test[]>      s = { v1, v2, v5, v8, v4, v2, v3, v6, v3, v4, v5, v4, v4, v1, v2 };

	print( s );

	AssertNotEqual( s.find( v4 ), s.end());
	AssertEqual( *s.find( v4 ), v4 );

	// **s.find( v4 ) = t5;		 // compile error, the value is the key of binary search-tree

	AssertEqual( s.find( v7 ), s.end());
	// AssertEqual( *s.find( v7 ), nullptr );    // runtime error

	// null value
	AssertEqual( s.find( nullptr ), s.end());
	s.insert( nullptr );
	AssertNotEqual( s.find( nullptr ), s.end());
	AssertEqual( *s.find( nullptr ), nullptr );

	AssertTrue( check_multiset( s, { v1, v2, v5, v8, v4, v2, v3, v6, v3, v4, v5, v4, v4, v1, v2, nullptr } ));

	rp_multiset<test[]>		      l1, r1, l2, r2, l3, r3, l4, r4, l5, r5;
	rp_multiset<test[]>::iterator    b, e;

	// [v4.->.v4)
	b = s.find( v4 );
	e = s.upper_bound( v4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multiset( l1, { v4, v4, v4, v4 } ));

	// (v4.<-.v4]
	b = s.find( v4 );
	e = s.lower_bound( v4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multiset( r1, { } ));

	// [.->.v4]
	b = s.begin();
	e = s.upper_bound( v4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multiset( l2, { nullptr, v1, v1, v2, v2, v2, v3, v3, v3, v4, v4, v4, v4 } ));

	// [v4.<-.]
	b = s.find( v8 );
	e = s.lower_bound( v4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multiset( r2, { v4, v4, v4, v5, v5, v8 } ));

	// [.->.v4)
	b = s.begin();
	e = s.upper_bound( v3 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multiset( l3, { nullptr, v1, v1, v2, v2, v2, v3, v3, v3 } ));

	// (v4.<-.]
	b = s.find( v8 );
	e = s.lower_bound( v4 );
	for ( auto i = b; i != e; --i ) r3.insert( *i );
	AssertTrue( check_multiset( r3, { v4, v4, v4, v5, v5, v8 } ));

	// [v4.->.)
	b = s.lower_bound( v4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multiset( l4, { v4, v4, v4, v4, v5, v5, v8 } ));

	// (.<-.v4]
	b = s.upper_bound( v4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multiset( r4, { v1, v1, v2, v2, v2, v3, v3, v3, v4, v4, v4, v4, v5 } ));

	// (v4.->.)
	b = s.upper_bound( v4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l5.insert( *i );
	AssertTrue( check_multiset( l5, { v5, v5, v8 } ));

	// (.<-.v4)
	b = s.lower_bound( v4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multiset( r5, { v1, v1, v2, v2, v2, v3, v3, v3, v4 } ));

	// lowest key
	AssertEqual( s.lower_bound( nullptr ), s.find( nullptr ));
	AssertEqual( s.upper_bound( v8 ), s.end());
}

// -----------------------------------------------------------------------------
void dp_multisettest::test0F()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range - deep pointer(v-array) value" );

	dp_multiset<test[]>      s = { v1, v2, v5, v8, v4, v2, v3, v6, v3, v4, v5, v4, v4, v1, v2 };

	print( s );

	AssertNotEqual( s.find( v4 ), s.end());
	AssertNotEqual( *s.find( v4 ), v4 );

	// **s.find( v4 ) = t5;		 // compile error, the value is the key of binary search-tree

	AssertEqual( s.find( v7 ), s.end());
	// AssertEqual( *s.find( v7 ), nullptr );    // runtime error

	// null value
	AssertEqual( s.find( nullptr ), s.end());
	s.insert( nullptr );
	AssertNotEqual( s.find( nullptr ), s.end());
	AssertEqual( *s.find( nullptr ), nullptr );

	AssertTrue( check_multiset( s, { v1, v2, v5, v8, v4, v2, v3, v6, v3, v4, v5, v4, v4, v1, v2, nullptr } ));

	rp_multiset<test[]>		      l1, r1, l2, r2, l3, r3, l4, r4, l5, r5;
	dp_multiset<test[]>::iterator    b, e;

	// [v4.->.v4)
	b = s.find( v4 );
	e = s.upper_bound( v4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multiset( l1, { v4, v4, v4, v4 } ));

	// (v4.<-.v4]
	b = s.find( v4 );
	e = s.lower_bound( v4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multiset( r1, { } ));

	// [.->.v4]
	b = s.begin();
	e = s.upper_bound( v4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multiset( l2, { nullptr, v1, v1, v2, v2, v2, v3, v3, v3, v4, v4, v4, v4 } ));

	// [v4.<-.]
	b = s.find( v8 );
	e = s.lower_bound( v4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multiset( r2, { v4, v4, v4, v5, v5, v8 } ));

	// [.->.v4)
	b = s.begin();
	e = s.upper_bound( v3 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multiset( l3, { nullptr, v1, v1, v2, v2, v2, v3, v3, v3 } ));

	// (v4.<-.]
	b = s.find( v8 );
	e = s.lower_bound( v4 );
	for ( auto i = b; i != e; --i ) r3.insert( *i );
	AssertTrue( check_multiset( r3, { v4, v4, v4, v5, v5, v8 } ));

	// [v4.->.)
	b = s.lower_bound( v4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multiset( l4, { v4, v4, v4, v4, v5, v5, v8 } ));

	// (.<-.v4]
	b = s.upper_bound( v4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multiset( r4, { v1, v1, v2, v2, v2, v3, v3, v3, v4, v4, v4, v4, v5 } ));

	// (v4.->.)
	b = s.upper_bound( v4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l5.insert( *i );
	AssertTrue( check_multiset( l5, { v5, v5, v8 } ));

	// (.<-.v4)
	b = s.lower_bound( v4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multiset( r5, { v1, v1, v2, v2, v2, v3, v3, v3, v4 } ));

	// lowest key
	AssertEqual( s.lower_bound( nullptr ), s.find( nullptr ));
	AssertEqual( s.upper_bound( v8 ), s.end());
}

// -----------------------------------------------------------------------------
void dp_multisettest::test10()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range - reference pointer(f-array) value" );

	rp_multiset<test[3]>      s = { w1, w2, w5, w8, w4, w2, w3, w6, w3, w4, w5, w4, w4, w1, w2 };

	print( s );

	AssertNotEqual( s.find( w4 ), s.end());
	AssertEqual( *s.find( w4 ), w4 );

	// **s.find( w4 ) = t5;		 // compile error, the value is the key of binary search-tree

	AssertEqual( s.find( w7 ), s.end());
	// AssertEqual( *s.find( w7 ), nullptr );    // runtime error

	// null value
	AssertEqual( s.find( nullptr ), s.end());
	s.insert( nullptr );
	AssertNotEqual( s.find( nullptr ), s.end());
	AssertEqual( *s.find( nullptr ), nullptr );

	AssertTrue( check_multiset( s, { w1, w2, w5, w8, w4, w2, w3, w6, w3, w4, w5, w4, w4, w1, w2, nullptr } ));

	rp_multiset<test[3]>		      l1, r1, l2, r2, l3, r3, l4, r4, l5, r5;
	rp_multiset<test[3]>::iterator    b, e;

	// [w4.->.w4)
	b = s.find( w4 );
	e = s.upper_bound( w4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multiset( l1, { w4, w4, w4, w4 } ));

	// (w4.<-.w4]
	b = s.find( w4 );
	e = s.lower_bound( w4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multiset( r1, { } ));

	// [.->.w4]
	b = s.begin();
	e = s.upper_bound( w4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multiset( l2, { nullptr, w1, w1, w2, w2, w2, w3, w3, w3, w4, w4, w4, w4 } ));

	// [w4.<-.]
	b = s.find( w8 );
	e = s.lower_bound( w4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multiset( r2, { w4, w4, w4, w5, w5, w8 } ));

	// [.->.w4)
	b = s.begin();
	e = s.upper_bound( w3 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multiset( l3, { nullptr, w1, w1, w2, w2, w2, w3, w3, w3 } ));

	// (w4.<-.]
	b = s.find( w8 );
	e = s.lower_bound( w4 );
	for ( auto i = b; i != e; --i ) r3.insert( *i );
	AssertTrue( check_multiset( r3, { w4, w4, w4, w5, w5, w8 } ));

	// [w4.->.)
	b = s.lower_bound( w4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multiset( l4, { w4, w4, w4, w4, w5, w5, w8 } ));

	// (.<-.w4]
	b = s.upper_bound( w4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multiset( r4, { w1, w1, w2, w2, w2, w3, w3, w3, w4, w4, w4, w4, w5 } ));

	// (w4.->.)
	b = s.upper_bound( w4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l5.insert( *i );
	AssertTrue( check_multiset( l5, { w5, w5, w8 } ));

	// (.<-.w4)
	b = s.lower_bound( w4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multiset( r5, { w1, w1, w2, w2, w2, w3, w3, w3, w4 } ));

	// lowest key
	AssertEqual( s.lower_bound( nullptr ), s.find( nullptr ));
	AssertEqual( s.upper_bound( w8 ), s.end());
}

// -----------------------------------------------------------------------------
void dp_multisettest::test11()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range - deep pointer(f-array) value" );

	dp_multiset<test[3]>      s = { w1, w2, w5, w8, w4, w2, w3, w6, w3, w4, w5, w4, w4, w1, w2 };

	print( s );

	AssertNotEqual( s.find( w4 ), s.end());
	AssertNotEqual( *s.find( w4 ), w4 );

	// **s.find( w4 ) = t5;		 // compile error, the value is the key of binary search-tree

	AssertEqual( s.find( w7 ), s.end());
	// AssertEqual( *s.find( w7 ), nullptr );    // runtime error

	// null value
	AssertEqual( s.find( nullptr ), s.end());
	s.insert( nullptr );
	AssertNotEqual( s.find( nullptr ), s.end());
	AssertEqual( *s.find( nullptr ), nullptr );

	AssertTrue( check_multiset( s, { w1, w2, w5, w8, w4, w2, w3, w6, w3, w4, w5, w4, w4, w1, w2, nullptr } ));

	rp_multiset<test[3]>		      l1, r1, l2, r2, l3, r3, l4, r4, l5, r5;
	dp_multiset<test[3]>::iterator    b, e;

	// [w4.->.w4)
	b = s.find( w4 );
	e = s.upper_bound( w4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multiset( l1, { w4, w4, w4, w4 } ));

	// (w4.<-.w4]
	b = s.find( w4 );
	e = s.lower_bound( w4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multiset( r1, { } ));

	// [.->.w4]
	b = s.begin();
	e = s.upper_bound( w4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multiset( l2, { nullptr, w1, w1, w2, w2, w2, w3, w3, w3, w4, w4, w4, w4 } ));

	// [w4.<-.]
	b = s.find( w8 );
	e = s.lower_bound( w4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multiset( r2, { w4, w4, w4, w5, w5, w8 } ));

	// [.->.w4)
	b = s.begin();
	e = s.upper_bound( w3 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multiset( l3, { nullptr, w1, w1, w2, w2, w2, w3, w3, w3 } ));

	// (w4.<-.]
	b = s.find( w8 );
	e = s.lower_bound( w4 );
	for ( auto i = b; i != e; --i ) r3.insert( *i );
	AssertTrue( check_multiset( r3, { w4, w4, w4, w5, w5, w8 } ));

	// [w4.->.)
	b = s.lower_bound( w4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multiset( l4, { w4, w4, w4, w4, w5, w5, w8 } ));

	// (.<-.w4]
	b = s.upper_bound( w4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multiset( r4, { w1, w1, w2, w2, w2, w3, w3, w3, w4, w4, w4, w4, w5 } ));

	// (w4.->.)
	b = s.upper_bound( w4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l5.insert( *i );
	AssertTrue( check_multiset( l5, { w5, w5, w8 } ));

	// (.<-.w4)
	b = s.lower_bound( w4 );
	e = s.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multiset( r5, { w1, w1, w2, w2, w2, w3, w3, w3, w4 } ));

	// lowest key
	AssertEqual( s.lower_bound( nullptr ), s.find( nullptr ));
	AssertEqual( s.upper_bound( w8 ), s.end());
}

// -----------------------------------------------------------------------------
void dp_multisettest::test12()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range - data(int value) value" );

	std::multiset<int>      s = { 1, 2, 5, 8, 4, 2, 3, 3, 3, 4, 5, 4, 4, 1, 2 };

	print( s );

	AssertNotEqual( s.find( 4 ), s.end());


	// **s.find( 4 ) = t5;		 // compile error, the value is the key of binary search-tree

	AssertEqual( s.find( 7 ), s.end());
	// AssertEqual( *s.find( 7 ), 0 );    // runtime error

	// null value
	AssertEqual( s.find( 0 ), s.end());
	s.insert( 0 );
	AssertNotEqual( s.find( 0 ), s.end());
	AssertEqual( *s.find( 0 ), 0 );

	AssertTrue( check_multiset( s, { 1, 2, 5, 8, 4, 2, 3, 3, 3, 4, 5, 4, 4, 1, 2, 0 } ));

	std::multiset<int>		      l1, r1, l2, r2, l3, r3, l4, r4, l5, r5;
	std::multiset<int>::iterator    b, e;

	// [4.->.4)
	b = s.find( 4 );
	e = s.upper_bound( 4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multiset( l1, { 4, 4, 4, 4 } ));

	// (4.<-.4]
	b = s.find( 4 );
	e = s.lower_bound( 4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multiset( r1, { } ));

	// [.->.4]
	b = s.begin();
	e = s.upper_bound( 4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multiset( l2, { 0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4 } ));

	// [4.<-.]
	b = s.find( 8 );
	e = s.lower_bound( 4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multiset( r2, { 4, 4, 4, 5, 5, 8 } ));

	// [.->.4)
	b = s.begin();
	e = s.upper_bound( 3 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multiset( l3, { 0, 1, 1, 2, 2, 2, 3, 3, 3 } ));

	// (4.<-.]
	b = s.find( 8 );
	e = s.lower_bound( 4 );
	for ( auto i = b; i != e; --i ) r3.insert( *i );
	AssertTrue( check_multiset( r3, { 4, 4, 4, 5, 5, 8 } ));

	// [4.->.)
	b = s.lower_bound( 4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multiset( l4, { 4, 4, 4, 4, 5, 5, 8 } ));

	// (.<-.4]
	b = s.upper_bound( 4 );
	e = s.find( 0 );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multiset( r4, { 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5 } ));

	// (4.->.)
	b = s.upper_bound( 4 );
	e = s.end();
	for ( auto i = b; i != e; ++i ) l5.insert( *i );
	AssertTrue( check_multiset( l5, { 5, 5, 8 } ));

	// (.<-.4)
	b = s.lower_bound( 4 );
	e = s.find( 0 );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multiset( r5, { 1, 1, 2, 2, 2, 3, 3, 3, 4 } ));

	// lowest key
	AssertEqual( s.lower_bound( 0 ), s.find( 0 ));
	AssertEqual( s.upper_bound( 8 ), s.end());
}

// -----------------------------------------------------------------------------
void dp_multisettest::test13()
{
	this->set_subtitle( "emplace/insert/erase - reference pointer(pointer) value" );

	rp_multiset<test*>	m1 = { &t1, &t2 };
	rp_multiset<test*>	m2;
	rp_multiset<test*>	m3 = { &t2, &t3, &t3, &t3, &t5 };

	// emplace
	{
		typedef typename rp_multiset<test*>::iterator			iterator;

		rp_multiset<test*>	pm;
		rp_multiset<test*>	pi;
		iterator		r;
		iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			r = pm.emplace( *i );

			AssertEqual( *i, *r );
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			j = pi.emplace_hint( j, *i );

			AssertEqual( *i, *j );
		}
		AssertTrue( check_multiset( pm, { &t1, &t2 } ));
		AssertTrue( check_multiset( pi, { &t1, &t2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			r = pm.emplace( *i );

			AssertEqual( *i, *r );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			j = pi.emplace_hint( j, *i );

			AssertEqual( *i, *j );
		}

		AssertTrue( check_multiset( pm, { &t1, &t2, &t2, &t3, &t3, &t3, &t5 } ));
		AssertTrue( check_multiset( pi, { &t1, &t2, &t2, &t3, &t3, &t3, &t5 } ));
	}

	// insert
	{
		rp_multiset<test*>     pm;
		rp_multiset<test*>     il;
		rp_multiset<test*>     it;

		for ( auto i = m1.begin(); i != m1.end(); ++i ) pm.insert( *i );
		il.insert( { &t1, &t2 } );
		it.insert( m1.begin(), m1.end());
		AssertTrue( check_multiset( pm, { &t1, &t2 } ));
		AssertTrue( check_multiset( il, { &t1, &t2 } ));
		AssertTrue( check_multiset( it, { &t1, &t2 } ));

		for ( auto i = m2.begin(); i != m2.end(); ++i ) pm.insert( *i );
		il.insert( { } );
		it.insert( m2.begin(), m2.end());
		AssertTrue( check_multiset( pm, { &t1, &t2 } ));
		AssertTrue( check_multiset( il, { &t1, &t2 } ));
		AssertTrue( check_multiset( it, { &t1, &t2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) pm.insert( *i );
		il.insert( { &t2, &t3, &t3, &t3, &t5 } );
		it.insert( m3.begin(), m3.end());
		AssertTrue( check_multiset( pm, { &t1, &t2, &t2, &t3, &t3, &t3, &t5 } ));
		AssertTrue( check_multiset( il, { &t1, &t2, &t2, &t3, &t3, &t3, &t5 } ));
		AssertTrue( check_multiset( it, { &t1, &t2, &t2, &t3, &t3, &t3, &t5 } ));
	}

	// erase
	{
		rp_multiset<test*>	p { &t1, &t2, &t5, &t8, &t4, &t2, &t3, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2, nullptr };
		rp_multiset<test*>	p1( p );

		AssertEqual( p1.erase( &t4 ), 4 );
		AssertTrue( check_multiset( p1, { &t1, &t2, &t5, &t8, &t2, &t3, &t6, &t3, &t5, &t1, &t2, nullptr } ));
		AssertZero( p1.erase( &t7 ));
		AssertEqual( p1.erase( nullptr ), 1 );
		AssertEqual( p1.erase( &t5 ), 2 );
		AssertEqual( p1.erase( &t8 ), 1 );
		AssertTrue( check_multiset( p1, { &t1, &t2, &t2, &t3, &t6, &t3, &t1, &t2 } ));

		rp_multiset<test*>	q1( p );
		rp_multiset<test*>	q2( p );
		rp_multiset<test*>	q3( p );
		rp_multiset<test*>	q4( p );

		q1.erase( q1.find( &t3 ));
		AssertTrue( check_multiset( q1, { &t1, &t2, &t5, &t8, &t4, &t2, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2, nullptr } ));
		// q1.erase( q1.find( &t7 ));	runtime-error
		q1.erase( q1.find( &t8 ));
		AssertTrue( check_multiset( q1, { &t1, &t2, &t5, &t4, &t2, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2, nullptr } ));
		q1.erase( q1.begin());
		AssertTrue( check_multiset( q1, { &t1, &t2, &t5, &t4, &t2, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2 } ));
		// q1.erase( q1.end());		runtime-error
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multiset( q1, { } ));
		q2.erase( q2.lower_bound( &t4 ), q2.upper_bound( &t4 ));
		AssertTrue( check_multiset( q2, { &t1, &t2, &t5, &t8, &t2, &t3, &t6, &t3, &t5, &t1, &t2, nullptr } ));
		q2.erase( q2.begin(), q2.upper_bound( &t4 ));
		AssertTrue( check_multiset( q2, { &t5, &t5, &t8 } ));
		q3.erase( q3.lower_bound( &t4 ), q3.end());
		AssertTrue( check_multiset( q3, { &t1, &t2, &t2, &t3, &t6, &t3, &t1, &t2, nullptr } ));
		q4.erase( q4.find( &t4 ), q4.find( &t4 ));
		AssertTrue( check_multiset( q4, { &t1, &t2, &t5, &t8, &t4, &t2, &t3, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2, nullptr } ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multiset( q4, { &t1, &t2, &t5, &t8, &t4, &t2, &t3, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2, nullptr } ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multiset( q4, { &t1, &t2, &t5, &t8, &t4, &t2, &t3, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2, nullptr } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test14()
{
	this->set_subtitle( "emplace/insert/erase - deep pointer(pointer) value" );

	rp_multiset<test*>	m1 = { &t1, &t2 };
	rp_multiset<test*>	m2;
	rp_multiset<test*>	m3 = { &t2, &t3, &t3, &t3, &t5 };

	// emplace
	{
		typedef typename dp_multiset<test*>::iterator			iterator;

		dp_multiset<test*>	pm;
		dp_multiset<test*>	pi;
		iterator		r;
		iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			r = pm.emplace( dp_dup<test*>()( *i ));

			AssertEqual( *i, *r );
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			j = pi.emplace_hint( j, dp_dup<test*>()( *i ));

			AssertEqual( *i, *j );
		}
		AssertTrue( check_multiset( pm, { &t1, &t2 } ));
		AssertTrue( check_multiset( pi, { &t1, &t2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			r = pm.emplace( dp_dup<test*>()( *i ));

			AssertEqual( *i, *r );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			j = pi.emplace_hint( j, dp_dup<test*>()( *i ));

			AssertEqual( *i, *j );
		}

		AssertTrue( check_multiset( pm, { &t1, &t2, &t2, &t3, &t3, &t3, &t5 } ));
		AssertTrue( check_multiset( pi, { &t1, &t2, &t2, &t3, &t3, &t3, &t5 } ));
	}

	// insert
	{
		dp_multiset<test*>     pm;
		dp_multiset<test*>     il;
		dp_multiset<test*>     it;

		for ( auto i = m1.begin(); i != m1.end(); ++i ) pm.insert( dp_dup<test*>()( *i ));
		il.insert( { &t1, &t2 } );
		it.insert( m1.begin(), m1.end());
		AssertTrue( check_multiset( pm, { &t1, &t2 } ));
		AssertTrue( check_multiset( il, { &t1, &t2 } ));
		AssertTrue( check_multiset( it, { &t1, &t2 } ));

		for ( auto i = m2.begin(); i != m2.end(); ++i ) pm.insert( dp_dup<test*>()( *i ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());
		AssertTrue( check_multiset( pm, { &t1, &t2 } ));
		AssertTrue( check_multiset( il, { &t1, &t2 } ));
		AssertTrue( check_multiset( it, { &t1, &t2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) pm.insert( dp_dup<test*>()( *i ));
		il.insert( { &t2, &t3, &t3, &t3, &t5 } );
		it.insert( m3.begin(), m3.end());
		AssertTrue( check_multiset( pm, { &t1, &t2, &t2, &t3, &t3, &t3, &t5 } ));
		AssertTrue( check_multiset( il, { &t1, &t2, &t2, &t3, &t3, &t3, &t5 } ));
		AssertTrue( check_multiset( it, { &t1, &t2, &t2, &t3, &t3, &t3, &t5 } ));
	}

	// erase
	{
		dp_multiset<test*>	p { &t1, &t2, &t5, &t8, &t4, &t2, &t3, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2, nullptr };
		dp_multiset<test*>	p1( p );

		AssertEqual( p1.erase( &t4 ), 4 );
		AssertTrue( check_multiset( p1, { &t1, &t2, &t5, &t8, &t2, &t3, &t6, &t3, &t5, &t1, &t2, nullptr } ));
		AssertZero( p1.erase( &t7 ));
		AssertEqual( p1.erase( nullptr ), 1 );
		AssertEqual( p1.erase( &t5 ), 2 );
		AssertEqual( p1.erase( &t8 ), 1 );
		AssertTrue( check_multiset( p1, { &t1, &t2, &t2, &t3, &t6, &t3, &t1, &t2 } ));

		dp_multiset<test*>	q1( p );
		dp_multiset<test*>	q2( p );
		dp_multiset<test*>	q3( p );
		dp_multiset<test*>	q4( p );

		q1.erase( q1.find( &t3 ));
		AssertTrue( check_multiset( q1, { &t1, &t2, &t5, &t8, &t4, &t2, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2, nullptr } ));
		// q1.erase( q1.find( &t7 ));	runtime-error
		q1.erase( q1.find( &t8 ));
		AssertTrue( check_multiset( q1, { &t1, &t2, &t5, &t4, &t2, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2, nullptr } ));
		q1.erase( q1.begin());
		AssertTrue( check_multiset( q1, { &t1, &t2, &t5, &t4, &t2, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2 } ));
		// q1.erase( q1.end());		runtime-error
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multiset( q1, { } ));
		q2.erase( q2.lower_bound( &t4 ), q2.upper_bound( &t4 ));
		AssertTrue( check_multiset( q2, { &t1, &t2, &t5, &t8, &t2, &t3, &t6, &t3, &t5, &t1, &t2, nullptr } ));
		q2.erase( q2.begin(), q2.upper_bound( &t4 ));
		AssertTrue( check_multiset( q2, { &t5, &t5, &t8 } ));
		q3.erase( q3.lower_bound( &t4 ), q3.end());
		AssertTrue( check_multiset( q3, { &t1, &t2, &t2, &t3, &t6, &t3, &t1, &t2, nullptr } ));
		q4.erase( q4.find( &t4 ), q4.find( &t4 ));
		AssertTrue( check_multiset( q4, { &t1, &t2, &t5, &t8, &t4, &t2, &t3, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2, nullptr } ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multiset( q4, { &t1, &t2, &t5, &t8, &t4, &t2, &t3, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2, nullptr } ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multiset( q4, { &t1, &t2, &t5, &t8, &t4, &t2, &t3, &t6, &t3, &t4, &t5, &t4, &t4, &t1, &t2, nullptr } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test15()
{
	this->set_subtitle( "emplace/insert/erase - reference pointer(c-string) value" );

	rp_multiset<const char[]>	m1 = { s1, s2 };
	rp_multiset<const char[]>	m2;
	rp_multiset<const char[]>	m3 = { s2, s3, s3, s3, s5 };

	// emplace
	{
		typedef typename rp_multiset<const char[]>::iterator			iterator;

		rp_multiset<const char[]>	pm;
		rp_multiset<const char[]>	pi;
		iterator		r;
		iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			r = pm.emplace( *i );

			AssertEqual( *i, *r );
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			j = pi.emplace_hint( j, *i );

			AssertEqual( *i, *j );
		}
		AssertTrue( check_multiset( pm, { s1, s2 } ));
		AssertTrue( check_multiset( pi, { s1, s2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			r = pm.emplace( *i );

			AssertEqual( *i, *r );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			j = pi.emplace_hint( j, *i );

			AssertEqual( *i, *j );
		}

		AssertTrue( check_multiset( pm, { s1, s2, s2, s3, s3, s3, s5 } ));
		AssertTrue( check_multiset( pi, { s1, s2, s2, s3, s3, s3, s5 } ));
	}

	// insert
	{
		rp_multiset<const char[]>     pm;
		rp_multiset<const char[]>     il;
		rp_multiset<const char[]>     it;

		for ( auto i = m1.begin(); i != m1.end(); ++i ) pm.insert( *i );
		il.insert( { s1, s2 } );
		it.insert( m1.begin(), m1.end());
		AssertTrue( check_multiset( pm, { s1, s2 } ));
		AssertTrue( check_multiset( il, { s1, s2 } ));
		AssertTrue( check_multiset( it, { s1, s2 } ));

		for ( auto i = m2.begin(); i != m2.end(); ++i ) pm.insert( *i );
		il.insert( { } );
		it.insert( m2.begin(), m2.end());
		AssertTrue( check_multiset( pm, { s1, s2 } ));
		AssertTrue( check_multiset( il, { s1, s2 } ));
		AssertTrue( check_multiset( it, { s1, s2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) pm.insert( *i );
		il.insert( { s2, s3, s3, s3, s5 } );
		it.insert( m3.begin(), m3.end());
		AssertTrue( check_multiset( pm, { s1, s2, s2, s3, s3, s3, s5 } ));
		AssertTrue( check_multiset( il, { s1, s2, s2, s3, s3, s3, s5 } ));
		AssertTrue( check_multiset( it, { s1, s2, s2, s3, s3, s3, s5 } ));
	}

	// erase
	{
		rp_multiset<const char[]>	p { s1, s2, s5, s8, s4, s2, s3, s6, s3, s4, s5, s4, s4, s1, s2, nullptr };
		rp_multiset<const char[]>	p1( p );

		AssertEqual( p1.erase( s4 ), 4 );
		AssertTrue( check_multiset( p1, { s1, s2, s5, s8, s2, s3, s6, s3, s5, s1, s2, nullptr } ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( nullptr ), 1 );
		AssertEqual( p1.erase( s5 ), 2 );
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_multiset( p1, { s1, s2, s2, s3, s6, s3, s1, s2 } ));

		rp_multiset<const char[]>	q1( p );
		rp_multiset<const char[]>	q2( p );
		rp_multiset<const char[]>	q3( p );
		rp_multiset<const char[]>	q4( p );

		q1.erase( q1.find( s3 ));
		AssertTrue( check_multiset( q1, { s1, s2, s5, s8, s4, s2, s6, s3, s4, s5, s4, s4, s1, s2, nullptr } ));
		// q1.erase( q1.find( s7 ));	runtime-error
		q1.erase( q1.find( s8 ));
		AssertTrue( check_multiset( q1, { s1, s2, s5, s4, s2, s6, s3, s4, s5, s4, s4, s1, s2, nullptr } ));
		q1.erase( q1.begin());
		AssertTrue( check_multiset( q1, { s1, s2, s5, s4, s2, s6, s3, s4, s5, s4, s4, s1, s2 } ));
		// q1.erase( q1.end());		runtime-error
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multiset( q1, { } ));
		q2.erase( q2.lower_bound( s4 ), q2.upper_bound( s4 ));
		AssertTrue( check_multiset( q2, { s1, s2, s5, s8, s2, s3, s6, s3, s5, s1, s2, nullptr } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_multiset( q2, { s5, s5, s8 } ));
		q3.erase( q3.lower_bound( s4 ), q3.end());
		AssertTrue( check_multiset( q3, { s1, s2, s2, s3, s6, s3, s1, s2, nullptr } ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_multiset( q4, { s1, s2, s5, s8, s4, s2, s3, s6, s3, s4, s5, s4, s4, s1, s2, nullptr } ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multiset( q4, { s1, s2, s5, s8, s4, s2, s3, s6, s3, s4, s5, s4, s4, s1, s2, nullptr } ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multiset( q4, { s1, s2, s5, s8, s4, s2, s3, s6, s3, s4, s5, s4, s4, s1, s2, nullptr } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test16()
{
	this->set_subtitle( "emplace/insert/erase - deep pointer(c-string) value" );

	rp_multiset<const char[]>	m1 = { s1, s2 };
	rp_multiset<const char[]>	m2;
	rp_multiset<const char[]>	m3 = { s2, s3, s3, s3, s5 };

	// emplace
	{
		typedef typename dp_multiset<const char[]>::iterator			iterator;

		dp_multiset<const char[]>	pm;
		dp_multiset<const char[]>	pi;
		iterator		r;
		iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			r = pm.emplace( dp_dup<const char[]>()( *i ));

			AssertEqual( *i, *r );
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			j = pi.emplace_hint( j, dp_dup<const char[]>()( *i ));

			AssertEqual( *i, *j );
		}
		AssertTrue( check_multiset( pm, { s1, s2 } ));
		AssertTrue( check_multiset( pi, { s1, s2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			r = pm.emplace( dp_dup<const char[]>()( *i ));

			AssertEqual( *i, *r );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			j = pi.emplace_hint( j, dp_dup<const char[]>()( *i ));

			AssertEqual( *i, *j );
		}

		AssertTrue( check_multiset( pm, { s1, s2, s2, s3, s3, s3, s5 } ));
		AssertTrue( check_multiset( pi, { s1, s2, s2, s3, s3, s3, s5 } ));
	}

	// insert
	{
		dp_multiset<const char[]>     pm;
		dp_multiset<const char[]>     il;
		dp_multiset<const char[]>     it;

		for ( auto i = m1.begin(); i != m1.end(); ++i ) pm.insert( dp_dup<const char[]>()( *i ));
		il.insert( { s1, s2 } );
		it.insert( m1.begin(), m1.end());
		AssertTrue( check_multiset( pm, { s1, s2 } ));
		AssertTrue( check_multiset( il, { s1, s2 } ));
		AssertTrue( check_multiset( it, { s1, s2 } ));

		for ( auto i = m2.begin(); i != m2.end(); ++i ) pm.insert( dp_dup<const char[]>()( *i ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());
		AssertTrue( check_multiset( pm, { s1, s2 } ));
		AssertTrue( check_multiset( il, { s1, s2 } ));
		AssertTrue( check_multiset( it, { s1, s2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) pm.insert( dp_dup<const char[]>()( *i ));
		il.insert( { s2, s3, s3, s3, s5 } );
		it.insert( m3.begin(), m3.end());
		AssertTrue( check_multiset( pm, { s1, s2, s2, s3, s3, s3, s5 } ));
		AssertTrue( check_multiset( il, { s1, s2, s2, s3, s3, s3, s5 } ));
		AssertTrue( check_multiset( it, { s1, s2, s2, s3, s3, s3, s5 } ));
	}

	// erase
	{
		dp_multiset<const char[]>	p { s1, s2, s5, s8, s4, s2, s3, s6, s3, s4, s5, s4, s4, s1, s2, nullptr };
		dp_multiset<const char[]>	p1( p );

		AssertEqual( p1.erase( s4 ), 4 );
		AssertTrue( check_multiset( p1, { s1, s2, s5, s8, s2, s3, s6, s3, s5, s1, s2, nullptr } ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( nullptr ), 1 );
		AssertEqual( p1.erase( s5 ), 2 );
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_multiset( p1, { s1, s2, s2, s3, s6, s3, s1, s2 } ));

		dp_multiset<const char[]>	q1( p );
		dp_multiset<const char[]>	q2( p );
		dp_multiset<const char[]>	q3( p );
		dp_multiset<const char[]>	q4( p );

		q1.erase( q1.find( s3 ));
		AssertTrue( check_multiset( q1, { s1, s2, s5, s8, s4, s2, s6, s3, s4, s5, s4, s4, s1, s2, nullptr } ));
		// q1.erase( q1.find( s7 ));	runtime-error
		q1.erase( q1.find( s8 ));
		AssertTrue( check_multiset( q1, { s1, s2, s5, s4, s2, s6, s3, s4, s5, s4, s4, s1, s2, nullptr } ));
		q1.erase( q1.begin());
		AssertTrue( check_multiset( q1, { s1, s2, s5, s4, s2, s6, s3, s4, s5, s4, s4, s1, s2 } ));
		// q1.erase( q1.end());		runtime-error
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multiset( q1, { } ));
		q2.erase( q2.lower_bound( s4 ), q2.upper_bound( s4 ));
		AssertTrue( check_multiset( q2, { s1, s2, s5, s8, s2, s3, s6, s3, s5, s1, s2, nullptr } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_multiset( q2, { s5, s5, s8 } ));
		q3.erase( q3.lower_bound( s4 ), q3.end());
		AssertTrue( check_multiset( q3, { s1, s2, s2, s3, s6, s3, s1, s2, nullptr } ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_multiset( q4, { s1, s2, s5, s8, s4, s2, s3, s6, s3, s4, s5, s4, s4, s1, s2, nullptr } ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multiset( q4, { s1, s2, s5, s8, s4, s2, s3, s6, s3, s4, s5, s4, s4, s1, s2, nullptr } ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multiset( q4, { s1, s2, s5, s8, s4, s2, s3, s6, s3, s4, s5, s4, s4, s1, s2, nullptr } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test17()
{
	this->set_subtitle( "emplace/insert/erase - reference pointer(v-array) value" );

	rp_multiset<test[]>	m1 = { v1, v2 };
	rp_multiset<test[]>	m2;
	rp_multiset<test[]>	m3 = { v2, v3, v3, v3, v5 };

	// emplace
	{
		typedef typename rp_multiset<test[]>::iterator			iterator;

		rp_multiset<test[]>	pm;
		rp_multiset<test[]>	pi;
		iterator		r;
		iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			r = pm.emplace( *i );

			AssertEqual( *i, *r );
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			j = pi.emplace_hint( j, *i );

			AssertEqual( *i, *j );
		}
		AssertTrue( check_multiset( pm, { v1, v2 } ));
		AssertTrue( check_multiset( pi, { v1, v2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			r = pm.emplace( *i );

			AssertEqual( *i, *r );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			j = pi.emplace_hint( j, *i );

			AssertEqual( *i, *j );
		}

		AssertTrue( check_multiset( pm, { v1, v2, v2, v3, v3, v3, v5 } ));
		AssertTrue( check_multiset( pi, { v1, v2, v2, v3, v3, v3, v5 } ));
	}

	// insert
	{
		rp_multiset<test[]>     pm;
		rp_multiset<test[]>     il;
		rp_multiset<test[]>     it;

		for ( auto i = m1.begin(); i != m1.end(); ++i ) pm.insert( *i );
		il.insert( { v1, v2 } );
		it.insert( m1.begin(), m1.end());
		AssertTrue( check_multiset( pm, { v1, v2 } ));
		AssertTrue( check_multiset( il, { v1, v2 } ));
		AssertTrue( check_multiset( it, { v1, v2 } ));

		for ( auto i = m2.begin(); i != m2.end(); ++i ) pm.insert( *i );
		il.insert( { } );
		it.insert( m2.begin(), m2.end());
		AssertTrue( check_multiset( pm, { v1, v2 } ));
		AssertTrue( check_multiset( il, { v1, v2 } ));
		AssertTrue( check_multiset( it, { v1, v2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) pm.insert( *i );
		il.insert( { v2, v3, v3, v3, v5 } );
		it.insert( m3.begin(), m3.end());
		AssertTrue( check_multiset( pm, { v1, v2, v2, v3, v3, v3, v5 } ));
		AssertTrue( check_multiset( il, { v1, v2, v2, v3, v3, v3, v5 } ));
		AssertTrue( check_multiset( it, { v1, v2, v2, v3, v3, v3, v5 } ));
	}

	// erase
	{
		rp_multiset<test[]>	p { v1, v2, v5, v8, v4, v2, v3, v6, v3, v4, v5, v4, v4, v1, v2, nullptr };
		rp_multiset<test[]>	p1( p );

		AssertEqual( p1.erase( v4 ), 4 );
		AssertTrue( check_multiset( p1, { v1, v2, v5, v8, v2, v3, v6, v3, v5, v1, v2, nullptr } ));
		AssertZero( p1.erase( v7 ));
		AssertEqual( p1.erase( nullptr ), 1 );
		AssertEqual( p1.erase( v5 ), 2 );
		AssertEqual( p1.erase( v8 ), 1 );
		AssertTrue( check_multiset( p1, { v1, v2, v2, v3, v6, v3, v1, v2 } ));

		rp_multiset<test[]>	q1( p );
		rp_multiset<test[]>	q2( p );
		rp_multiset<test[]>	q3( p );
		rp_multiset<test[]>	q4( p );

		q1.erase( q1.find( v3 ));
		AssertTrue( check_multiset( q1, { v1, v2, v5, v8, v4, v2, v6, v3, v4, v5, v4, v4, v1, v2, nullptr } ));
		// q1.erase( q1.find( v7 ));	runtime-error
		q1.erase( q1.find( v8 ));
		AssertTrue( check_multiset( q1, { v1, v2, v5, v4, v2, v6, v3, v4, v5, v4, v4, v1, v2, nullptr } ));
		q1.erase( q1.begin());
		AssertTrue( check_multiset( q1, { v1, v2, v5, v4, v2, v6, v3, v4, v5, v4, v4, v1, v2 } ));
		// q1.erase( q1.end());		runtime-error
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multiset( q1, { } ));
		q2.erase( q2.lower_bound( v4 ), q2.upper_bound( v4 ));
		AssertTrue( check_multiset( q2, { v1, v2, v5, v8, v2, v3, v6, v3, v5, v1, v2, nullptr } ));
		q2.erase( q2.begin(), q2.upper_bound( v4 ));
		AssertTrue( check_multiset( q2, { v5, v5, v8 } ));
		q3.erase( q3.lower_bound( v4 ), q3.end());
		AssertTrue( check_multiset( q3, { v1, v2, v2, v3, v6, v3, v1, v2, nullptr } ));
		q4.erase( q4.find( v4 ), q4.find( v4 ));
		AssertTrue( check_multiset( q4, { v1, v2, v5, v8, v4, v2, v3, v6, v3, v4, v5, v4, v4, v1, v2, nullptr } ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multiset( q4, { v1, v2, v5, v8, v4, v2, v3, v6, v3, v4, v5, v4, v4, v1, v2, nullptr } ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multiset( q4, { v1, v2, v5, v8, v4, v2, v3, v6, v3, v4, v5, v4, v4, v1, v2, nullptr } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test18()
{
	this->set_subtitle( "emplace/insert/erase - deep pointer(v-array) value" );

	rp_multiset<test[]>	m1 = { v1, v2 };
	rp_multiset<test[]>	m2;
	rp_multiset<test[]>	m3 = { v2, v3, v3, v3, v5 };

	// emplace
	{
		typedef typename dp_multiset<test[]>::iterator			iterator;

		dp_multiset<test[]>	pm;
		dp_multiset<test[]>	pi;
		iterator		r;
		iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			r = pm.emplace( dp_dup<test[]>()( *i ));

			AssertEqual( *i, *r );
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			j = pi.emplace_hint( j, dp_dup<test[]>()( *i ));

			AssertEqual( *i, *j );
		}
		AssertTrue( check_multiset( pm, { v1, v2 } ));
		AssertTrue( check_multiset( pi, { v1, v2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			r = pm.emplace( dp_dup<test[]>()( *i ));

			AssertEqual( *i, *r );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			j = pi.emplace_hint( j, dp_dup<test[]>()( *i ));

			AssertEqual( *i, *j );
		}

		AssertTrue( check_multiset( pm, { v1, v2, v2, v3, v3, v3, v5 } ));
		AssertTrue( check_multiset( pi, { v1, v2, v2, v3, v3, v3, v5 } ));
	}

	// insert
	{
		dp_multiset<test[]>     pm;
		dp_multiset<test[]>     il;
		dp_multiset<test[]>     it;

		for ( auto i = m1.begin(); i != m1.end(); ++i ) pm.insert( dp_dup<test[]>()( *i ));
		il.insert( { v1, v2 } );
		it.insert( m1.begin(), m1.end());
		AssertTrue( check_multiset( pm, { v1, v2 } ));
		AssertTrue( check_multiset( il, { v1, v2 } ));
		AssertTrue( check_multiset( it, { v1, v2 } ));

		for ( auto i = m2.begin(); i != m2.end(); ++i ) pm.insert( dp_dup<test[]>()( *i ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());
		AssertTrue( check_multiset( pm, { v1, v2 } ));
		AssertTrue( check_multiset( il, { v1, v2 } ));
		AssertTrue( check_multiset( it, { v1, v2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) pm.insert( dp_dup<test[]>()( *i ));
		il.insert( { v2, v3, v3, v3, v5 } );
		it.insert( m3.begin(), m3.end());
		AssertTrue( check_multiset( pm, { v1, v2, v2, v3, v3, v3, v5 } ));
		AssertTrue( check_multiset( il, { v1, v2, v2, v3, v3, v3, v5 } ));
		AssertTrue( check_multiset( it, { v1, v2, v2, v3, v3, v3, v5 } ));
	}

	// erase
	{
		dp_multiset<test[]>	p { v1, v2, v5, v8, v4, v2, v3, v6, v3, v4, v5, v4, v4, v1, v2, nullptr };
		dp_multiset<test[]>	p1( p );

		AssertEqual( p1.erase( v4 ), 4 );
		AssertTrue( check_multiset( p1, { v1, v2, v5, v8, v2, v3, v6, v3, v5, v1, v2, nullptr } ));
		AssertZero( p1.erase( v7 ));
		AssertEqual( p1.erase( nullptr ), 1 );
		AssertEqual( p1.erase( v5 ), 2 );
		AssertEqual( p1.erase( v8 ), 1 );
		AssertTrue( check_multiset( p1, { v1, v2, v2, v3, v6, v3, v1, v2 } ));

		dp_multiset<test[]>	q1( p );
		dp_multiset<test[]>	q2( p );
		dp_multiset<test[]>	q3( p );
		dp_multiset<test[]>	q4( p );

		q1.erase( q1.find( v3 ));
		AssertTrue( check_multiset( q1, { v1, v2, v5, v8, v4, v2, v6, v3, v4, v5, v4, v4, v1, v2, nullptr } ));
		// q1.erase( q1.find( v7 ));	runtime-error
		q1.erase( q1.find( v8 ));
		AssertTrue( check_multiset( q1, { v1, v2, v5, v4, v2, v6, v3, v4, v5, v4, v4, v1, v2, nullptr } ));
		q1.erase( q1.begin());
		AssertTrue( check_multiset( q1, { v1, v2, v5, v4, v2, v6, v3, v4, v5, v4, v4, v1, v2 } ));
		// q1.erase( q1.end());		runtime-error
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multiset( q1, { } ));
		q2.erase( q2.lower_bound( v4 ), q2.upper_bound( v4 ));
		AssertTrue( check_multiset( q2, { v1, v2, v5, v8, v2, v3, v6, v3, v5, v1, v2, nullptr } ));
		q2.erase( q2.begin(), q2.upper_bound( v4 ));
		AssertTrue( check_multiset( q2, { v5, v5, v8 } ));
		q3.erase( q3.lower_bound( v4 ), q3.end());
		AssertTrue( check_multiset( q3, { v1, v2, v2, v3, v6, v3, v1, v2, nullptr } ));
		q4.erase( q4.find( v4 ), q4.find( v4 ));
		AssertTrue( check_multiset( q4, { v1, v2, v5, v8, v4, v2, v3, v6, v3, v4, v5, v4, v4, v1, v2, nullptr } ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multiset( q4, { v1, v2, v5, v8, v4, v2, v3, v6, v3, v4, v5, v4, v4, v1, v2, nullptr } ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multiset( q4, { v1, v2, v5, v8, v4, v2, v3, v6, v3, v4, v5, v4, v4, v1, v2, nullptr } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test19()
{
	this->set_subtitle( "emplace/insert/erase - reference pointer(f-array) value" );

	rp_multiset<test[3]>	m1 = { w1, w2 };
	rp_multiset<test[3]>	m2;
	rp_multiset<test[3]>	m3 = { w2, w3, w3, w3, w5 };

	// emplace
	{
		typedef typename rp_multiset<test[3]>::iterator			iterator;

		rp_multiset<test[3]>	pm;
		rp_multiset<test[3]>	pi;
		iterator		r;
		iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			r = pm.emplace( *i );

			AssertEqual( *i, *r );
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			j = pi.emplace_hint( j, *i );

			AssertEqual( *i, *j );
		}
		AssertTrue( check_multiset( pm, { w1, w2 } ));
		AssertTrue( check_multiset( pi, { w1, w2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			r = pm.emplace( *i );

			AssertEqual( *i, *r );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			j = pi.emplace_hint( j, *i );

			AssertEqual( *i, *j );
		}

		AssertTrue( check_multiset( pm, { w1, w2, w2, w3, w3, w3, w5 } ));
		AssertTrue( check_multiset( pi, { w1, w2, w2, w3, w3, w3, w5 } ));
	}

	// insert
	{
		rp_multiset<test[3]>     pm;
		rp_multiset<test[3]>     il;
		rp_multiset<test[3]>     it;

		for ( auto i = m1.begin(); i != m1.end(); ++i ) pm.insert( *i );
		il.insert( { w1, w2 } );
		it.insert( m1.begin(), m1.end());
		AssertTrue( check_multiset( pm, { w1, w2 } ));
		AssertTrue( check_multiset( il, { w1, w2 } ));
		AssertTrue( check_multiset( it, { w1, w2 } ));

		for ( auto i = m2.begin(); i != m2.end(); ++i ) pm.insert( *i );
		il.insert( { } );
		it.insert( m2.begin(), m2.end());
		AssertTrue( check_multiset( pm, { w1, w2 } ));
		AssertTrue( check_multiset( il, { w1, w2 } ));
		AssertTrue( check_multiset( it, { w1, w2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) pm.insert( *i );
		il.insert( { w2, w3, w3, w3, w5 } );
		it.insert( m3.begin(), m3.end());
		AssertTrue( check_multiset( pm, { w1, w2, w2, w3, w3, w3, w5 } ));
		AssertTrue( check_multiset( il, { w1, w2, w2, w3, w3, w3, w5 } ));
		AssertTrue( check_multiset( it, { w1, w2, w2, w3, w3, w3, w5 } ));
	}

	// erase
	{
		rp_multiset<test[3]>	p { w1, w2, w5, w8, w4, w2, w3, w6, w3, w4, w5, w4, w4, w1, w2, nullptr };
		rp_multiset<test[3]>	p1( p );

		AssertEqual( p1.erase( w4 ), 4 );
		AssertTrue( check_multiset( p1, { w1, w2, w5, w8, w2, w3, w6, w3, w5, w1, w2, nullptr } ));
		AssertZero( p1.erase( w7 ));
		AssertEqual( p1.erase( nullptr ), 1 );
		AssertEqual( p1.erase( w5 ), 2 );
		AssertEqual( p1.erase( w8 ), 1 );
		AssertTrue( check_multiset( p1, { w1, w2, w2, w3, w6, w3, w1, w2 } ));

		rp_multiset<test[3]>	q1( p );
		rp_multiset<test[3]>	q2( p );
		rp_multiset<test[3]>	q3( p );
		rp_multiset<test[3]>	q4( p );

		q1.erase( q1.find( w3 ));
		AssertTrue( check_multiset( q1, { w1, w2, w5, w8, w4, w2, w6, w3, w4, w5, w4, w4, w1, w2, nullptr } ));
		// q1.erase( q1.find( w7 ));	runtime-error
		q1.erase( q1.find( w8 ));
		AssertTrue( check_multiset( q1, { w1, w2, w5, w4, w2, w6, w3, w4, w5, w4, w4, w1, w2, nullptr } ));
		q1.erase( q1.begin());
		AssertTrue( check_multiset( q1, { w1, w2, w5, w4, w2, w6, w3, w4, w5, w4, w4, w1, w2 } ));
		// q1.erase( q1.end());		runtime-error
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multiset( q1, { } ));
		q2.erase( q2.lower_bound( w4 ), q2.upper_bound( w4 ));
		AssertTrue( check_multiset( q2, { w1, w2, w5, w8, w2, w3, w6, w3, w5, w1, w2, nullptr } ));
		q2.erase( q2.begin(), q2.upper_bound( w4 ));
		AssertTrue( check_multiset( q2, { w5, w5, w8 } ));
		q3.erase( q3.lower_bound( w4 ), q3.end());
		AssertTrue( check_multiset( q3, { w1, w2, w2, w3, w6, w3, w1, w2, nullptr } ));
		q4.erase( q4.find( w4 ), q4.find( w4 ));
		AssertTrue( check_multiset( q4, { w1, w2, w5, w8, w4, w2, w3, w6, w3, w4, w5, w4, w4, w1, w2, nullptr } ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multiset( q4, { w1, w2, w5, w8, w4, w2, w3, w6, w3, w4, w5, w4, w4, w1, w2, nullptr } ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multiset( q4, { w1, w2, w5, w8, w4, w2, w3, w6, w3, w4, w5, w4, w4, w1, w2, nullptr } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test1A()
{
	this->set_subtitle( "emplace/insert/erase - deep pointer(f-array) value" );

	rp_multiset<test[3]>	m1 = { w1, w2 };
	rp_multiset<test[3]>	m2;
	rp_multiset<test[3]>	m3 = { w2, w3, w3, w3, w5 };

	// emplace
	{
		typedef typename dp_multiset<test[3]>::iterator			iterator;

		dp_multiset<test[3]>	pm;
		dp_multiset<test[3]>	pi;
		iterator		r;
		iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			r = pm.emplace( dp_dup<test[3]>()( *i ));

			AssertEqual( *i, *r );
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			j = pi.emplace_hint( j, dp_dup<test[3]>()( *i ));

			AssertEqual( *i, *j );
		}
		AssertTrue( check_multiset( pm, { w1, w2 } ));
		AssertTrue( check_multiset( pi, { w1, w2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			r = pm.emplace( dp_dup<test[3]>()( *i ));

			AssertEqual( *i, *r );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			j = pi.emplace_hint( j, dp_dup<test[3]>()( *i ));

			AssertEqual( *i, *j );
		}

		AssertTrue( check_multiset( pm, { w1, w2, w2, w3, w3, w3, w5 } ));
		AssertTrue( check_multiset( pi, { w1, w2, w2, w3, w3, w3, w5 } ));
	}

	// insert
	{
		dp_multiset<test[3]>     pm;
		dp_multiset<test[3]>     il;
		dp_multiset<test[3]>     it;

		for ( auto i = m1.begin(); i != m1.end(); ++i ) pm.insert( dp_dup<test[3]>()( *i ));
		il.insert( { w1, w2 } );
		it.insert( m1.begin(), m1.end());
		AssertTrue( check_multiset( pm, { w1, w2 } ));
		AssertTrue( check_multiset( il, { w1, w2 } ));
		AssertTrue( check_multiset( it, { w1, w2 } ));

		for ( auto i = m2.begin(); i != m2.end(); ++i ) pm.insert( dp_dup<test[3]>()( *i ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());
		AssertTrue( check_multiset( pm, { w1, w2 } ));
		AssertTrue( check_multiset( il, { w1, w2 } ));
		AssertTrue( check_multiset( it, { w1, w2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) pm.insert( dp_dup<test[3]>()( *i ));
		il.insert( { w2, w3, w3, w3, w5 } );
		it.insert( m3.begin(), m3.end());
		AssertTrue( check_multiset( pm, { w1, w2, w2, w3, w3, w3, w5 } ));
		AssertTrue( check_multiset( il, { w1, w2, w2, w3, w3, w3, w5 } ));
		AssertTrue( check_multiset( it, { w1, w2, w2, w3, w3, w3, w5 } ));
	}

	// erase
	{
		dp_multiset<test[3]>	p { w1, w2, w5, w8, w4, w2, w3, w6, w3, w4, w5, w4, w4, w1, w2, nullptr };
		dp_multiset<test[3]>	p1( p );

		AssertEqual( p1.erase( w4 ), 4 );
		AssertTrue( check_multiset( p1, { w1, w2, w5, w8, w2, w3, w6, w3, w5, w1, w2, nullptr } ));
		AssertZero( p1.erase( w7 ));
		AssertEqual( p1.erase( nullptr ), 1 );
		AssertEqual( p1.erase( w5 ), 2 );
		AssertEqual( p1.erase( w8 ), 1 );
		AssertTrue( check_multiset( p1, { w1, w2, w2, w3, w6, w3, w1, w2 } ));

		dp_multiset<test[3]>	q1( p );
		dp_multiset<test[3]>	q2( p );
		dp_multiset<test[3]>	q3( p );
		dp_multiset<test[3]>	q4( p );

		q1.erase( q1.find( w3 ));
		AssertTrue( check_multiset( q1, { w1, w2, w5, w8, w4, w2, w6, w3, w4, w5, w4, w4, w1, w2, nullptr } ));
		// q1.erase( q1.find( w7 ));	runtime-error
		q1.erase( q1.find( w8 ));
		AssertTrue( check_multiset( q1, { w1, w2, w5, w4, w2, w6, w3, w4, w5, w4, w4, w1, w2, nullptr } ));
		q1.erase( q1.begin());
		AssertTrue( check_multiset( q1, { w1, w2, w5, w4, w2, w6, w3, w4, w5, w4, w4, w1, w2 } ));
		// q1.erase( q1.end());		runtime-error
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multiset( q1, { } ));
		q2.erase( q2.lower_bound( w4 ), q2.upper_bound( w4 ));
		AssertTrue( check_multiset( q2, { w1, w2, w5, w8, w2, w3, w6, w3, w5, w1, w2, nullptr } ));
		q2.erase( q2.begin(), q2.upper_bound( w4 ));
		AssertTrue( check_multiset( q2, { w5, w5, w8 } ));
		q3.erase( q3.lower_bound( w4 ), q3.end());
		AssertTrue( check_multiset( q3, { w1, w2, w2, w3, w6, w3, w1, w2, nullptr } ));
		q4.erase( q4.find( w4 ), q4.find( w4 ));
		AssertTrue( check_multiset( q4, { w1, w2, w5, w8, w4, w2, w3, w6, w3, w4, w5, w4, w4, w1, w2, nullptr } ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multiset( q4, { w1, w2, w5, w8, w4, w2, w3, w6, w3, w4, w5, w4, w4, w1, w2, nullptr } ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multiset( q4, { w1, w2, w5, w8, w4, w2, w3, w6, w3, w4, w5, w4, w4, w1, w2, nullptr } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test1B()
{
	this->set_subtitle( "emplace/insert/erase - data(int value) value" );

	std::multiset<int>	m1 = { 1, 2 };
	std::multiset<int>	m2;
	std::multiset<int>	m3 = { 2, 3, 3, 3, 5 };

	// emplace
	{
		typedef typename std::multiset<int>::iterator			iterator;

		std::multiset<int>	pm;
		std::multiset<int>	pi;
		iterator		r;
		iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			r = pm.emplace( *i );

			AssertEqual( *i, *r );
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i ) {
			j = pi.emplace_hint( j, *i );

			AssertEqual( *i, *j );
		}
		AssertTrue( check_multiset( pm, { 1, 2 } ));
		AssertTrue( check_multiset( pi, { 1, 2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			r = pm.emplace( *i );

			AssertEqual( *i, *r );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i ) {
			j = pi.emplace_hint( j, *i );

			AssertEqual( *i, *j );
		}

		AssertTrue( check_multiset( pm, { 1, 2, 2, 3, 3, 3, 5 } ));
		AssertTrue( check_multiset( pi, { 1, 2, 2, 3, 3, 3, 5 } ));
	}

	// insert
	{
		std::multiset<int>     pm;
		std::multiset<int>     il;
		std::multiset<int>     it;

		for ( auto i = m1.begin(); i != m1.end(); ++i ) pm.insert( *i );
		il.insert( { 1, 2 } );
		it.insert( m1.begin(), m1.end());
		AssertTrue( check_multiset( pm, { 1, 2 } ));
		AssertTrue( check_multiset( il, { 1, 2 } ));
		AssertTrue( check_multiset( it, { 1, 2 } ));

		for ( auto i = m2.begin(); i != m2.end(); ++i ) pm.insert( *i );
		il.insert( { } );
		it.insert( m2.begin(), m2.end());
		AssertTrue( check_multiset( pm, { 1, 2 } ));
		AssertTrue( check_multiset( il, { 1, 2 } ));
		AssertTrue( check_multiset( it, { 1, 2 } ));

		for ( auto i = m3.begin(); i != m3.end(); ++i ) pm.insert( *i );
		il.insert( { 2, 3, 3, 3, 5 } );
		it.insert( m3.begin(), m3.end());
		AssertTrue( check_multiset( pm, { 1, 2, 2, 3, 3, 3, 5 } ));
		AssertTrue( check_multiset( il, { 1, 2, 2, 3, 3, 3, 5 } ));
		AssertTrue( check_multiset( it, { 1, 2, 2, 3, 3, 3, 5 } ));
	}

	// erase
	{
		std::multiset<int>	p { 1, 2, 5, 8, 4, 2, 3, 3, 3, 4, 5, 4, 4, 1, 2, 0 };
		std::multiset<int>	p1( p );

		AssertEqual( p1.erase( 4 ), 4 );
		AssertTrue( check_multiset( p1, { 1, 2, 5, 8, 2, 3, 3, 3, 5, 1, 2, 0 } ));
		AssertZero( p1.erase( 7 ));
		AssertEqual( p1.erase( 0 ), 1 );
		AssertEqual( p1.erase( 5 ), 2 );
		AssertEqual( p1.erase( 8 ), 1 );
		AssertTrue( check_multiset( p1, { 1, 2, 2, 3, 3, 3, 1, 2 } ));

		std::multiset<int>	q1( p );
		std::multiset<int>	q2( p );
		std::multiset<int>	q3( p );
		std::multiset<int>	q4( p );

		q1.erase( q1.find( 3 ));
		AssertTrue( check_multiset( q1, { 1, 2, 5, 8, 4, 2, 3, 3, 4, 5, 4, 4, 1, 2, 0 } ));
		// q1.erase( q1.find( 7 ));	runtime-error
		q1.erase( q1.find( 8 ));
		AssertTrue( check_multiset( q1, { 1, 2, 5, 4, 2, 3, 3, 4, 5, 4, 4, 1, 2, 0 } ));
		q1.erase( q1.begin());
		AssertTrue( check_multiset( q1, { 1, 2, 5, 4, 2, 3, 3, 4, 5, 4, 4, 1, 2 } ));
		// q1.erase( q1.end());		runtime-error
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multiset( q1, { } ));
		q2.erase( q2.lower_bound( 4 ), q2.upper_bound( 4 ));
		AssertTrue( check_multiset( q2, { 1, 2, 5, 8, 2, 3, 3, 3, 5, 1, 2, 0 } ));
		q2.erase( q2.begin(), q2.upper_bound( 4 ));
		AssertTrue( check_multiset( q2, { 5, 5, 8 } ));
		q3.erase( q3.lower_bound( 4 ), q3.end());
		AssertTrue( check_multiset( q3, { 1, 2, 2, 3, 3, 3, 1, 2, 0 } ));
		q4.erase( q4.find( 4 ), q4.find( 4 ));
		AssertTrue( check_multiset( q4, { 1, 2, 5, 8, 4, 2, 3, 3, 3, 4, 5, 4, 4, 1, 2, 0 } ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multiset( q4, { 1, 2, 5, 8, 4, 2, 3, 3, 3, 4, 5, 4, 4, 1, 2, 0 } ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multiset( q4, { 1, 2, 5, 8, 4, 2, 3, 3, 3, 4, 5, 4, 4, 1, 2, 0 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test1C()
{
	this->set_subtitle( "iterator - reference pointer(pointer) value" );

	rp_multiset<test*>	     pm = { &t1, &t2, &t3, &t3, &t3, &t5 };
	{
		rp_multiset<test*>::iterator   i;
		rp_multiset<test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rp_multiset<test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertEqual( *i, &t3 );
				AssertEqual( **i, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 6 );
		AssertEqual( pm.find( &t3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rp_multiset<test*>::reverse_iterator   i;
		rp_multiset<test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 4 ) k = rp_multiset<test*>::reverse_iterator( i );
			if ( c == 5 ) {
				AssertNotEqual( i, pm.rend());
				AssertEqual( *i, &t1 );
				AssertEqual( **i, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 6 );
		AssertEqual( static_cast<rp_multiset<test*>::const_reverse_iterator>( pm.find( &t2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test1D()
{
	this->set_subtitle( "iterator - deep pointer(pointer) value" );

	dp_multiset<test*>	     pm = { &t1, &t2, &t3, &t3, &t3, &t5 };
	{
		dp_multiset<test*>::iterator   i;
		dp_multiset<test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = dp_multiset<test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( *i, &t3 );
				AssertEqual( **i, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 6 );
		AssertEqual( pm.find( &t3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		dp_multiset<test*>::reverse_iterator   i;
		dp_multiset<test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 4 ) k = dp_multiset<test*>::reverse_iterator( i );
			if ( c == 5 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( *i, &t1 );
				AssertEqual( **i, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 6 );
		AssertEqual( static_cast<dp_multiset<test*>::const_reverse_iterator>( pm.find( &t2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test1E()
{
	this->set_subtitle( "iterator - reference pointer(c-string) value" );

	rp_multiset<const char[]>	     pm = { s1, s2, s3, s3, s3, s5 };
	{
		rp_multiset<const char[]>::iterator   i;
		rp_multiset<const char[]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rp_multiset<const char[]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertEqual( *i, s3 );
				AssertZero( strcmp( *i, s3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 6 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rp_multiset<const char[]>::reverse_iterator   i;
		rp_multiset<const char[]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 4 ) k = rp_multiset<const char[]>::reverse_iterator( i );
			if ( c == 5 ) {
				AssertNotEqual( i, pm.rend());
				AssertEqual( *i, s1 );
				AssertZero( strcmp( *i, s1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 6 );
		AssertEqual( static_cast<rp_multiset<const char[]>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test1F()
{
	this->set_subtitle( "iterator - deep pointer(c-string) value" );

	dp_multiset<const char[]>	     pm = { s1, s2, s3, s3, s3, s5 };
	{
		dp_multiset<const char[]>::iterator   i;
		dp_multiset<const char[]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = dp_multiset<const char[]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( *i, s3 );
				AssertZero( strcmp( *i, s3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 6 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		dp_multiset<const char[]>::reverse_iterator   i;
		dp_multiset<const char[]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 4 ) k = dp_multiset<const char[]>::reverse_iterator( i );
			if ( c == 5 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( *i, s1 );
				AssertZero( strcmp( *i, s1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 6 );
		AssertEqual( static_cast<dp_multiset<const char[]>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test20()
{
	this->set_subtitle( "iterator - reference pointer(v-array) value" );

	rp_multiset<test[]>	     pm = { v1, v2, v3, v3, v3, v5 };
	{
		rp_multiset<test[]>::iterator   i;
		rp_multiset<test[]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rp_multiset<test[]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertEqual( *i, v3 );
				AssertTrue( dp_eql<test[]>()( *i, v3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 6 );
		AssertEqual( pm.find( v3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rp_multiset<test[]>::reverse_iterator   i;
		rp_multiset<test[]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 4 ) k = rp_multiset<test[]>::reverse_iterator( i );
			if ( c == 5 ) {
				AssertNotEqual( i, pm.rend());
				AssertEqual( *i, v1 );
				AssertTrue( dp_eql<test[]>()( *i, v1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 6 );
		AssertEqual( static_cast<rp_multiset<test[]>::const_reverse_iterator>( pm.find( v2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test21()
{
	this->set_subtitle( "iterator - deep pointer(v-array) value" );

	dp_multiset<test[]>	     pm = { v1, v2, v3, v3, v3, v5 };
	{
		dp_multiset<test[]>::iterator   i;
		dp_multiset<test[]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = dp_multiset<test[]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( *i, v3 );
				AssertTrue( dp_eql<test[]>()( *i, v3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 6 );
		AssertEqual( pm.find( v3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		dp_multiset<test[]>::reverse_iterator   i;
		dp_multiset<test[]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 4 ) k = dp_multiset<test[]>::reverse_iterator( i );
			if ( c == 5 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( *i, v1 );
				AssertTrue( dp_eql<test[]>()( *i, v1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 6 );
		AssertEqual( static_cast<dp_multiset<test[]>::const_reverse_iterator>( pm.find( v2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test22()
{
	this->set_subtitle( "iterator - reference pointer(f-array) value" );

	rp_multiset<test[3]>	     pm = { w1, w2, w3, w3, w3, w5 };
	{
		rp_multiset<test[3]>::iterator   i;
		rp_multiset<test[3]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rp_multiset<test[3]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertEqual( *i, w3 );
				AssertTrue( dp_eql<test[3]>()( *i, w3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 6 );
		AssertEqual( pm.find( w3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rp_multiset<test[3]>::reverse_iterator   i;
		rp_multiset<test[3]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 4 ) k = rp_multiset<test[3]>::reverse_iterator( i );
			if ( c == 5 ) {
				AssertNotEqual( i, pm.rend());
				AssertEqual( *i, w1 );
				AssertTrue( dp_eql<test[3]>()( *i, w1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 6 );
		AssertEqual( static_cast<rp_multiset<test[3]>::const_reverse_iterator>( pm.find( w2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test23()
{
	this->set_subtitle( "iterator - deep pointer(f-array) value" );

	dp_multiset<test[3]>	     pm = { w1, w2, w3, w3, w3, w5 };
	{
		dp_multiset<test[3]>::iterator   i;
		dp_multiset<test[3]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = dp_multiset<test[3]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( *i, w3 );
				AssertTrue( dp_eql<test[3]>()( *i, w3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 6 );
		AssertEqual( pm.find( w3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		dp_multiset<test[3]>::reverse_iterator   i;
		dp_multiset<test[3]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 4 ) k = dp_multiset<test[3]>::reverse_iterator( i );
			if ( c == 5 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( *i, w1 );
				AssertTrue( dp_eql<test[3]>()( *i, w1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 6 );
		AssertEqual( static_cast<dp_multiset<test[3]>::const_reverse_iterator>( pm.find( w2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test24()
{
	this->set_subtitle( "iterator - data(int value) value" );

	std::multiset<int>	     pm = { 1, 2, 3, 3, 3, 5 };
	{
		std::multiset<int>::iterator   i;
		std::multiset<int>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = std::multiset<int>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());


				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 6 );
		AssertEqual( pm.find( 3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		std::multiset<int>::reverse_iterator   i;
		std::multiset<int>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 4 ) k = std::multiset<int>::reverse_iterator( i );
			if ( c == 5 ) {
				AssertNotEqual( i, pm.rend());


				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 6 );
		AssertEqual( static_cast<std::multiset<int>::const_reverse_iterator>( pm.find( 2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multisettest::test25()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear) - reference pointer(pointer) value" );

	rp_multiset<test*>      r1;
	rp_multiset<test*>      r2 = { &t1, &t2, &t3, &t3, &t3, &t5 };
	rp_multiset<test*>      r3 = { &t4, &t5 };

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multiset( r1, { &t1, &t2, &t3, &t3, &t3, &t5 } ));
	AssertTrue( check_multiset( r2, { &t4, &t5 } ));
	AssertTrue( check_multiset( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 6 );
	AssertEqual( r1.count( &t1 ), 1 );
	AssertEqual( r1.count( &t3 ), 3 );
	AssertEqual( r1.count( &t4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multiset( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multisettest::test26()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear) - deep pointer(pointer) value" );

	dp_multiset<test*>      r1;
	dp_multiset<test*>      r2 = { &t1, &t2, &t3, &t3, &t3, &t5 };
	dp_multiset<test*>      r3 = { &t4, &t5 };

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multiset( r1, { &t1, &t2, &t3, &t3, &t3, &t5 } ));
	AssertTrue( check_multiset( r2, { &t4, &t5 } ));
	AssertTrue( check_multiset( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 6 );
	AssertEqual( r1.count( &t1 ), 1 );
	AssertEqual( r1.count( &t3 ), 3 );
	AssertEqual( r1.count( &t4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multiset( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multisettest::test27()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear) - reference pointer(c-string) value" );

	rp_multiset<const char[]>      r1;
	rp_multiset<const char[]>      r2 = { s1, s2, s3, s3, s3, s5 };
	rp_multiset<const char[]>      r3 = { s4, s5 };

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multiset( r1, { s1, s2, s3, s3, s3, s5 } ));
	AssertTrue( check_multiset( r2, { s4, s5 } ));
	AssertTrue( check_multiset( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 6 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 3 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multiset( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multisettest::test28()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear) - deep pointer(c-string) value" );

	dp_multiset<const char[]>      r1;
	dp_multiset<const char[]>      r2 = { s1, s2, s3, s3, s3, s5 };
	dp_multiset<const char[]>      r3 = { s4, s5 };

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multiset( r1, { s1, s2, s3, s3, s3, s5 } ));
	AssertTrue( check_multiset( r2, { s4, s5 } ));
	AssertTrue( check_multiset( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 6 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 3 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multiset( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multisettest::test29()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear) - reference pointer(v-array) value" );

	rp_multiset<test[]>      r1;
	rp_multiset<test[]>      r2 = { v1, v2, v3, v3, v3, v5 };
	rp_multiset<test[]>      r3 = { v4, v5 };

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multiset( r1, { v1, v2, v3, v3, v3, v5 } ));
	AssertTrue( check_multiset( r2, { v4, v5 } ));
	AssertTrue( check_multiset( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 6 );
	AssertEqual( r1.count( v1 ), 1 );
	AssertEqual( r1.count( v3 ), 3 );
	AssertEqual( r1.count( v4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multiset( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multisettest::test2A()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear) - deep pointer(v-array) value" );

	dp_multiset<test[]>      r1;
	dp_multiset<test[]>      r2 = { v1, v2, v3, v3, v3, v5 };
	dp_multiset<test[]>      r3 = { v4, v5 };

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multiset( r1, { v1, v2, v3, v3, v3, v5 } ));
	AssertTrue( check_multiset( r2, { v4, v5 } ));
	AssertTrue( check_multiset( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 6 );
	AssertEqual( r1.count( v1 ), 1 );
	AssertEqual( r1.count( v3 ), 3 );
	AssertEqual( r1.count( v4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multiset( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multisettest::test2B()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear) - reference pointer(f-array) value" );

	rp_multiset<test[3]>      r1;
	rp_multiset<test[3]>      r2 = { w1, w2, w3, w3, w3, w5 };
	rp_multiset<test[3]>      r3 = { w4, w5 };

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multiset( r1, { w1, w2, w3, w3, w3, w5 } ));
	AssertTrue( check_multiset( r2, { w4, w5 } ));
	AssertTrue( check_multiset( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 6 );
	AssertEqual( r1.count( w1 ), 1 );
	AssertEqual( r1.count( w3 ), 3 );
	AssertEqual( r1.count( w4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multiset( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multisettest::test2C()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear) - deep pointer(f-array) value" );

	dp_multiset<test[3]>      r1;
	dp_multiset<test[3]>      r2 = { w1, w2, w3, w3, w3, w5 };
	dp_multiset<test[3]>      r3 = { w4, w5 };

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multiset( r1, { w1, w2, w3, w3, w3, w5 } ));
	AssertTrue( check_multiset( r2, { w4, w5 } ));
	AssertTrue( check_multiset( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 6 );
	AssertEqual( r1.count( w1 ), 1 );
	AssertEqual( r1.count( w3 ), 3 );
	AssertEqual( r1.count( w4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multiset( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multisettest::test2D()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear) - data(int value) value" );

	std::multiset<int>      r1;
	std::multiset<int>      r2 = { 1, 2, 3, 3, 3, 5 };
	std::multiset<int>      r3 = { 4, 5 };

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multiset( r1, { 1, 2, 3, 3, 3, 5 } ));
	AssertTrue( check_multiset( r2, { 4, 5 } ));
	AssertTrue( check_multiset( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 6 );
	AssertEqual( r1.count( 1 ), 1 );
	AssertEqual( r1.count( 3 ), 3 );
	AssertEqual( r1.count( 4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multiset( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multisettest::test2E()
{
	this->set_subtitle( "relational operators - reference pointer(pointer) value" );

	rp_multiset<test*>      r1 = { &t1, &t2 };
	rp_multiset<test*>      r2 = { &t1, &t2, &t3, &t3, &t3, &t5 };
	rp_multiset<test*>      r3 = { &t1, &t2, &t2 };
	rp_multiset<test*>      r4 = { &t1, &t2, &t3, &t3, &t3, &t5 };
	rp_multiset<test*>      r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multisettest::test2F()
{
	this->set_subtitle( "relational operators - deep pointer(pointer) value" );

	dp_multiset<test*>      r1 = { &t1, &t2 };
	dp_multiset<test*>      r2 = { &t1, &t2, &t3, &t3, &t3, &t5 };
	dp_multiset<test*>      r3 = { &t1, &t2, &t2 };
	dp_multiset<test*>      r4 = { &t1, &t2, &t3, &t3, &t3, &t5 };
	dp_multiset<test*>      r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multisettest::test30()
{
	this->set_subtitle( "relational operators - reference pointer(c-string) value" );

	rp_multiset<const char[]>      r1 = { s1, s2 };
	rp_multiset<const char[]>      r2 = { s1, s2, s3, s3, s3, s5 };
	rp_multiset<const char[]>      r3 = { s1, s2, s2 };
	rp_multiset<const char[]>      r4 = { s1, s2, s3, s3, s3, s5 };
	rp_multiset<const char[]>      r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multisettest::test31()
{
	this->set_subtitle( "relational operators - deep pointer(c-string) value" );

	dp_multiset<const char[]>      r1 = { s1, s2 };
	dp_multiset<const char[]>      r2 = { s1, s2, s3, s3, s3, s5 };
	dp_multiset<const char[]>      r3 = { s1, s2, s2 };
	dp_multiset<const char[]>      r4 = { s1, s2, s3, s3, s3, s5 };
	dp_multiset<const char[]>      r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multisettest::test32()
{
	this->set_subtitle( "relational operators - reference pointer(v-array) value" );

	rp_multiset<test[]>      r1 = { v1, v2 };
	rp_multiset<test[]>      r2 = { v1, v2, v3, v3, v3, v5 };
	rp_multiset<test[]>      r3 = { v1, v2, v2 };
	rp_multiset<test[]>      r4 = { v1, v2, v3, v3, v3, v5 };
	rp_multiset<test[]>      r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multisettest::test33()
{
	this->set_subtitle( "relational operators - deep pointer(v-array) value" );

	dp_multiset<test[]>      r1 = { v1, v2 };
	dp_multiset<test[]>      r2 = { v1, v2, v3, v3, v3, v5 };
	dp_multiset<test[]>      r3 = { v1, v2, v2 };
	dp_multiset<test[]>      r4 = { v1, v2, v3, v3, v3, v5 };
	dp_multiset<test[]>      r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multisettest::test34()
{
	this->set_subtitle( "relational operators - reference pointer(f-array) value" );

	rp_multiset<test[3]>      r1 = { w1, w2 };
	rp_multiset<test[3]>      r2 = { w1, w2, w3, w3, w3, w5 };
	rp_multiset<test[3]>      r3 = { w1, w2, w2 };
	rp_multiset<test[3]>      r4 = { w1, w2, w3, w3, w3, w5 };
	rp_multiset<test[3]>      r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multisettest::test35()
{
	this->set_subtitle( "relational operators - deep pointer(f-array) value" );

	dp_multiset<test[3]>      r1 = { w1, w2 };
	dp_multiset<test[3]>      r2 = { w1, w2, w3, w3, w3, w5 };
	dp_multiset<test[3]>      r3 = { w1, w2, w2 };
	dp_multiset<test[3]>      r4 = { w1, w2, w3, w3, w3, w5 };
	dp_multiset<test[3]>      r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multisettest::test36()
{
	this->set_subtitle( "relational operators - data(int value) value" );

	std::multiset<int>      r1 = { 1, 2 };
	std::multiset<int>      r2 = { 1, 2, 3, 3, 3, 5 };
	std::multiset<int>      r3 = { 1, 2, 2 };
	std::multiset<int>      r4 = { 1, 2, 3, 3, 3, 5 };
	std::multiset<int>      r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// Main
// -----------------------------------------------------------------------------
int main( int argc, char** argv )
{
	dp_multisettest( argc, argv ).run();
	return 0;
}

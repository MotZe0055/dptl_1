//
// dp_multimaptest.cpp test
//
//		generated by gendptest, 2018/12/14
//

#include <dptl/dp_map.hpp>
#include <dptl/utest.hpp>
#include <dptl/udata.hpp>
#include <cstring>

using namespace dptl;

// Unit Test Classes
// -----------------------------------------------------------------------------
class dp_multimaptest : public unittest, public basic_testdata
{
	int		m_cnt;

    public:
	// --- constructor/assignment/destructor ---
	void test01();
	void test02();
	void test03();
	void test04();
	void test05();
	void test06();
	void test07();
	void test08();
	void test09();
	void test0A();
	void test0B();
	void test0C();
	void test0D();
	void test0E();
	void test0F();
	void test10();
	void test11();
	void test12();

	// --- find/lower_bound/upper_bound/equal_range ---
	void test13();
	void test14();
	void test15();
	void test16();
	void test17();
	void test18();
	void test19();
	void test1A();
	void test1B();
	void test1C();
	void test1D();
	void test1E();
	void test1F();
	void test20();
	void test21();
	void test22();
	void test23();
	void test24();

	// --- emplace/insert/erase ---
	void test25();
	void test26();
	void test27();
	void test28();
	void test29();
	void test2A();
	void test2B();
	void test2C();
	void test2D();
	void test2E();
	void test2F();
	void test30();
	void test31();
	void test32();
	void test33();
	void test34();
	void test35();
	void test36();

	// --- iterator ---
	void test37();
	void test38();
	void test39();
	void test3A();
	void test3B();
	void test3C();
	void test3D();
	void test3E();
	void test3F();
	void test40();
	void test41();
	void test42();
	void test43();
	void test44();
	void test45();
	void test46();
	void test47();
	void test48();

	// --- miscellaneous (swap/count/size/empty/clear) ---
	void test49();
	void test4A();
	void test4B();
	void test4C();
	void test4D();
	void test4E();
	void test4F();
	void test50();
	void test51();
	void test52();
	void test53();
	void test54();
	void test55();
	void test56();
	void test57();
	void test58();
	void test59();
	void test5A();

	// --- relational operators ---
	void test5B();
	void test5C();
	void test5D();
	void test5E();
	void test5F();
	void test60();
	void test61();
	void test62();
	void test63();
	void test64();
	void test65();
	void test66();
	void test67();
	void test68();
	void test69();
	void test6A();
	void test6B();
	void test6C();

	dp_multimaptest( int argc, char** argv ) : unittest( argc, argv )
	{
		m_cnt = test::getCntr();
		fprintf( stderr, "*** test::getCntr() : %d\n", m_cnt );
	}

	~dp_multimaptest()
	{
		this->set_subtitle( "test class allocation" );
		AssertEqual( m_cnt, test::getCntr() );
		fprintf( stderr, "\n" );
	}
};

#include <dptl/dp_map.hpp>

// Testdata Check Utilities
// -----------------------------------------------------------------------------
template <typename K, typename T>
inline bool check_multimap( dp_multimap<K,T> const& ls,
			    std::initializer_list<typename dp_multimap<K,T>::value_pointer> const& ts )
{
	std::multimap<dp_const_pointer<K>,dp_pointer<T>>	l;

	for ( auto a : ts ) l.emplace( a.first, a.second );

	return ls == reinterpret_cast<dp_multimap<K,T> const&>( l );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test01()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(pointer) key - reference pointer(pointer) value" );

	// default constructor
	rr_multimap<test*,test*>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	rr_multimap<test*,test*>		p0( lr );
	const rr_multimap<test*,test*>	c0( lr );
	lr.emplace( &t1, &t1 );
	rr_multimap<test*,test*>		p1( lr );
	const rr_multimap<test*,test*>	c1( lr );
	lr.emplace( &t2, &t2 );
	lr.emplace( &t3, &t3 );
	lr.emplace( &t3, &t3 );
	lr.emplace( &t3, &t3 );
	lr.emplace( &t4, &t4 );
	lr.emplace( &t5, &t5 );
	rr_multimap<test*,test*>		p5( lr );
	const rr_multimap<test*,test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ &t1, &t1 }} ));
	AssertTrue( check_multimap( p5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ &t1, &t1 }} ));
	AssertTrue( check_multimap( c5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));

	// move constructor
	{
		rr_multimap<test*,test*>   lx = lr;
		rr_multimap<test*,test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// copy assignment operator
	{
		rr_multimap<test*,test*>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// move assignment operator
	{
		rr_multimap<test*,test*>   lx;

		lr = p1;
		lx = rr_multimap<test*,test*>( {{ &t5, &t5 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t2, &t2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ &t5, &t5 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		rr_multimap<test*,test*>   lx = p5;
		rr_multimap<test*,test*>::iterator	i = lx.find( &t4 );

		rr_multimap<test*,test*>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }} ));
		rr_multimap<test*,test*>   x0( i, i );
		AssertTrue( x0.empty());
		rr_multimap<test*,test*>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ &t4, &t4 }, { &t5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		rr_multimap<test*,test*>   lx = p5;
		rr_multimap<test*,test*>   x0 { };
		rr_multimap<test*,test*>   x1 {{ &t1, &t1 }};
		rr_multimap<test*,test*>   x5 {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ &t1, &t1 }} ));
		AssertTrue( check_multimap( x5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ &t1, &t1 }};
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }} ));
		lx = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }};
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test02()
{
	this->set_subtitle( "constructor/assignment/destructor, deep pointer(pointer) key - reference pointer(pointer) value" );

	// default constructor
	dr_multimap<test*,test*>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	dr_multimap<test*,test*>		p0( lr );
	const dr_multimap<test*,test*>	c0( lr );
	lr.emplace( dpl( &t1 ), &t1 );
	dr_multimap<test*,test*>		p1( lr );
	const dr_multimap<test*,test*>	c1( lr );
	lr.emplace( dpl( &t2 ), &t2 );
	lr.emplace( dpl( &t3 ), &t3 );
	lr.emplace( dpl( &t3 ), &t3 );
	lr.emplace( dpl( &t3 ), &t3 );
	lr.emplace( dpl( &t4 ), &t4 );
	lr.emplace( dpl( &t5 ), &t5 );
	dr_multimap<test*,test*>		p5( lr );
	const dr_multimap<test*,test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ &t1, &t1 }} ));
	AssertTrue( check_multimap( p5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ &t1, &t1 }} ));
	AssertTrue( check_multimap( c5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));

	// move constructor
	{
		dr_multimap<test*,test*>   lx = lr;
		dr_multimap<test*,test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// copy assignment operator
	{
		dr_multimap<test*,test*>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// move assignment operator
	{
		dr_multimap<test*,test*>   lx;

		lr = p1;
		lx = dr_multimap<test*,test*>( {{ &t5, &t5 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t2, &t2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ &t5, &t5 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		dr_multimap<test*,test*>   lx = p5;
		dr_multimap<test*,test*>::iterator	i = lx.find( &t4 );

		dr_multimap<test*,test*>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }} ));
		dr_multimap<test*,test*>   x0( i, i );
		AssertTrue( x0.empty());
		dr_multimap<test*,test*>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ &t4, &t4 }, { &t5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		dr_multimap<test*,test*>   lx = p5;
		dr_multimap<test*,test*>   x0 { };
		dr_multimap<test*,test*>   x1 {{ &t1, &t1 }};
		dr_multimap<test*,test*>   x5 {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ &t1, &t1 }} ));
		AssertTrue( check_multimap( x5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ &t1, &t1 }};
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }} ));
		lx = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }};
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test03()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(pointer) key - deep pointer(pointer) value" );

	// default constructor
	rd_multimap<test*,test*>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	rd_multimap<test*,test*>		p0( lr );
	const rd_multimap<test*,test*>	c0( lr );
	lr.emplace( &t1, dpl( &t1 ) );
	rd_multimap<test*,test*>		p1( lr );
	const rd_multimap<test*,test*>	c1( lr );
	lr.emplace( &t2, dpl( &t2 ) );
	lr.emplace( &t3, dpl( &t3 ) );
	lr.emplace( &t3, dpl( &t3 ) );
	lr.emplace( &t3, dpl( &t3 ) );
	lr.emplace( &t4, dpl( &t4 ) );
	lr.emplace( &t5, dpl( &t5 ) );
	rd_multimap<test*,test*>		p5( lr );
	const rd_multimap<test*,test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ &t1, &t1 }} ));
	AssertTrue( check_multimap( p5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ &t1, &t1 }} ));
	AssertTrue( check_multimap( c5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));

	// move constructor
	{
		rd_multimap<test*,test*>   lx = lr;
		rd_multimap<test*,test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// copy assignment operator
	{
		rd_multimap<test*,test*>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// move assignment operator
	{
		rd_multimap<test*,test*>   lx;

		lr = p1;
		lx = rd_multimap<test*,test*>( {{ &t5, &t5 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t2, &t2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ &t5, &t5 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		rd_multimap<test*,test*>   lx = p5;
		rd_multimap<test*,test*>::iterator	i = lx.find( &t4 );

		rd_multimap<test*,test*>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }} ));
		rd_multimap<test*,test*>   x0( i, i );
		AssertTrue( x0.empty());
		rd_multimap<test*,test*>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ &t4, &t4 }, { &t5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		rd_multimap<test*,test*>   lx = p5;
		rd_multimap<test*,test*>   x0 { };
		rd_multimap<test*,test*>   x1 {{ &t1, &t1 }};
		rd_multimap<test*,test*>   x5 {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ &t1, &t1 }} ));
		AssertTrue( check_multimap( x5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ &t1, &t1 }};
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }} ));
		lx = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }};
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test04()
{
	this->set_subtitle( "constructor/assignment/destructor, deep pointer(pointer) key - deep pointer(pointer) value" );

	// default constructor
	dd_multimap<test*,test*>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	dd_multimap<test*,test*>		p0( lr );
	const dd_multimap<test*,test*>	c0( lr );
	lr.emplace( dpl( &t1 ), dpl( &t1 ) );
	dd_multimap<test*,test*>		p1( lr );
	const dd_multimap<test*,test*>	c1( lr );
	lr.emplace( dpl( &t2 ), dpl( &t2 ) );
	lr.emplace( dpl( &t3 ), dpl( &t3 ) );
	lr.emplace( dpl( &t3 ), dpl( &t3 ) );
	lr.emplace( dpl( &t3 ), dpl( &t3 ) );
	lr.emplace( dpl( &t4 ), dpl( &t4 ) );
	lr.emplace( dpl( &t5 ), dpl( &t5 ) );
	dd_multimap<test*,test*>		p5( lr );
	const dd_multimap<test*,test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ &t1, &t1 }} ));
	AssertTrue( check_multimap( p5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ &t1, &t1 }} ));
	AssertTrue( check_multimap( c5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));

	// move constructor
	{
		dd_multimap<test*,test*>   lx = lr;
		dd_multimap<test*,test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// copy assignment operator
	{
		dd_multimap<test*,test*>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// move assignment operator
	{
		dd_multimap<test*,test*>   lx;

		lr = p1;
		lx = dd_multimap<test*,test*>( {{ &t5, &t5 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t2, &t2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ &t5, &t5 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		dd_multimap<test*,test*>   lx = p5;
		dd_multimap<test*,test*>::iterator	i = lx.find( &t4 );

		dd_multimap<test*,test*>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }} ));
		dd_multimap<test*,test*>   x0( i, i );
		AssertTrue( x0.empty());
		dd_multimap<test*,test*>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ &t4, &t4 }, { &t5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		dd_multimap<test*,test*>   lx = p5;
		dd_multimap<test*,test*>   x0 { };
		dd_multimap<test*,test*>   x1 {{ &t1, &t1 }};
		dd_multimap<test*,test*>   x5 {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ &t1, &t1 }} ));
		AssertTrue( check_multimap( x5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ &t1, &t1 }};
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }} ));
		lx = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }};
		AssertTrue( check_multimap( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test05()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - reference pointer(c-string) value" );

	// default constructor
	rr_multimap<const char[],const char[]>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	rr_multimap<const char[],const char[]>		p0( lr );
	const rr_multimap<const char[],const char[]>	c0( lr );
	lr.emplace( s1, s1 );
	rr_multimap<const char[],const char[]>		p1( lr );
	const rr_multimap<const char[],const char[]>	c1( lr );
	lr.emplace( s2, s2 );
	lr.emplace( s3, s3 );
	lr.emplace( s3, s3 );
	lr.emplace( s3, s3 );
	lr.emplace( s4, s4 );
	lr.emplace( s5, s5 );
	rr_multimap<const char[],const char[]>		p5( lr );
	const rr_multimap<const char[],const char[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ s1, s1 }} ));
	AssertTrue( check_multimap( p5, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ s1, s1 }} ));
	AssertTrue( check_multimap( c5, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));

	// move constructor
	{
		rr_multimap<const char[],const char[]>   lx = lr;
		rr_multimap<const char[],const char[]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 },
						 { s3, s3 }, { s4, s4 }, { s5, s5 }} ));
	}
	// copy assignment operator
	{
		rr_multimap<const char[],const char[]>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ s1, s1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 },
						 { s3, s3 }, { s4, s4 }, { s5, s5 }} ));
	}
	// move assignment operator
	{
		rr_multimap<const char[],const char[]>   lx;

		lr = p1;
		lx = rr_multimap<const char[],const char[]>( {{ s5, s5 }, { s3, s3 }, { s3, s3 }, { s3, s3 }, { s2, s2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ s5, s5 }, { s3, s3 }, { s3, s3 }, { s3, s3 }, { s2, s2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ s1, s1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		rr_multimap<const char[],const char[]>   lx = p5;
		rr_multimap<const char[],const char[]>::iterator	i = lx.find( s4 );

		rr_multimap<const char[],const char[]>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 }, { s3, s3 }} ));
		rr_multimap<const char[],const char[]>   x0( i, i );
		AssertTrue( x0.empty());
		rr_multimap<const char[],const char[]>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ s4, s4 }, { s5, s5 }} ));
	}
	// initializer constructor/assignment operator
	{
		rr_multimap<const char[],const char[]>   lx = p5;
		rr_multimap<const char[],const char[]>   x0 { };
		rr_multimap<const char[],const char[]>   x1 {{ s1, s1 }};
		rr_multimap<const char[],const char[]>   x5 {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 }, { s5, s5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ s1, s1 }} ));
		AssertTrue( check_multimap( x5, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 }, { s5, s5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, s1 }};
		AssertTrue( check_multimap( lx, {{ s1, s1 }} ));
		lx = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 }, { s5, s5 }};
		AssertTrue( check_multimap( lx, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 }, { s5, s5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test06()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - deep pointer(c-string) value" );

	// default constructor
	rd_multimap<const char[],const char[]>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	rd_multimap<const char[],const char[]>		p0( lr );
	const rd_multimap<const char[],const char[]>	c0( lr );
	lr.emplace( s1, strdup( s1 ) );
	rd_multimap<const char[],const char[]>		p1( lr );
	const rd_multimap<const char[],const char[]>	c1( lr );
	lr.emplace( s2, strdup( s2 ) );
	lr.emplace( s3, strdup( s3 ) );
	lr.emplace( s3, strdup( s3 ) );
	lr.emplace( s3, strdup( s3 ) );
	lr.emplace( s4, strdup( s4 ) );
	lr.emplace( s5, strdup( s5 ) );
	rd_multimap<const char[],const char[]>		p5( lr );
	const rd_multimap<const char[],const char[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ s1, s1 }} ));
	AssertTrue( check_multimap( p5, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ s1, s1 }} ));
	AssertTrue( check_multimap( c5, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));

	// move constructor
	{
		rd_multimap<const char[],const char[]>   lx = lr;
		rd_multimap<const char[],const char[]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 },
						 { s3, s3 }, { s4, s4 }, { s5, s5 }} ));
	}
	// copy assignment operator
	{
		rd_multimap<const char[],const char[]>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ s1, s1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 },
						 { s3, s3 }, { s4, s4 }, { s5, s5 }} ));
	}
	// move assignment operator
	{
		rd_multimap<const char[],const char[]>   lx;

		lr = p1;
		lx = rd_multimap<const char[],const char[]>( {{ s5, s5 }, { s3, s3 }, { s3, s3 }, { s3, s3 }, { s2, s2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ s5, s5 }, { s3, s3 }, { s3, s3 }, { s3, s3 }, { s2, s2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ s1, s1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		rd_multimap<const char[],const char[]>   lx = p5;
		rd_multimap<const char[],const char[]>::iterator	i = lx.find( s4 );

		rd_multimap<const char[],const char[]>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 }, { s3, s3 }} ));
		rd_multimap<const char[],const char[]>   x0( i, i );
		AssertTrue( x0.empty());
		rd_multimap<const char[],const char[]>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ s4, s4 }, { s5, s5 }} ));
	}
	// initializer constructor/assignment operator
	{
		rd_multimap<const char[],const char[]>   lx = p5;
		rd_multimap<const char[],const char[]>   x0 { };
		rd_multimap<const char[],const char[]>   x1 {{ s1, s1 }};
		rd_multimap<const char[],const char[]>   x5 {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 }, { s5, s5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ s1, s1 }} ));
		AssertTrue( check_multimap( x5, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 }, { s5, s5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, s1 }};
		AssertTrue( check_multimap( lx, {{ s1, s1 }} ));
		lx = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 }, { s5, s5 }};
		AssertTrue( check_multimap( lx, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s3, s3 }, { s5, s5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test07()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - reference pointer(v-array) value" );

	// default constructor
	rr_multimap<const char[],test[]>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	rr_multimap<const char[],test[]>		p0( lr );
	const rr_multimap<const char[],test[]>	c0( lr );
	lr.emplace( s1, v1 );
	rr_multimap<const char[],test[]>		p1( lr );
	const rr_multimap<const char[],test[]>	c1( lr );
	lr.emplace( s2, v2 );
	lr.emplace( s3, v3 );
	lr.emplace( s3, v3 );
	lr.emplace( s3, v3 );
	lr.emplace( s4, v4 );
	lr.emplace( s5, v5 );
	rr_multimap<const char[],test[]>		p5( lr );
	const rr_multimap<const char[],test[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ s1, v1 }} ));
	AssertTrue( check_multimap( p5, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ s1, v1 }} ));
	AssertTrue( check_multimap( c5, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));

	// move constructor
	{
		rr_multimap<const char[],test[]>   lx = lr;
		rr_multimap<const char[],test[]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 },
						 { s3, v3 }, { s4, v4 }, { s5, v5 }} ));
	}
	// copy assignment operator
	{
		rr_multimap<const char[],test[]>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ s1, v1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 },
						 { s3, v3 }, { s4, v4 }, { s5, v5 }} ));
	}
	// move assignment operator
	{
		rr_multimap<const char[],test[]>   lx;

		lr = p1;
		lx = rr_multimap<const char[],test[]>( {{ s5, v5 }, { s3, v3 }, { s3, v3 }, { s3, v3 }, { s2, v2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ s5, v5 }, { s3, v3 }, { s3, v3 }, { s3, v3 }, { s2, v2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ s1, v1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		rr_multimap<const char[],test[]>   lx = p5;
		rr_multimap<const char[],test[]>::iterator	i = lx.find( s4 );

		rr_multimap<const char[],test[]>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 }, { s3, v3 }} ));
		rr_multimap<const char[],test[]>   x0( i, i );
		AssertTrue( x0.empty());
		rr_multimap<const char[],test[]>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ s4, v4 }, { s5, v5 }} ));
	}
	// initializer constructor/assignment operator
	{
		rr_multimap<const char[],test[]>   lx = p5;
		rr_multimap<const char[],test[]>   x0 { };
		rr_multimap<const char[],test[]>   x1 {{ s1, v1 }};
		rr_multimap<const char[],test[]>   x5 {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 }, { s5, v5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ s1, v1 }} ));
		AssertTrue( check_multimap( x5, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 }, { s5, v5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, v1 }};
		AssertTrue( check_multimap( lx, {{ s1, v1 }} ));
		lx = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 }, { s5, v5 }};
		AssertTrue( check_multimap( lx, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 }, { s5, v5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test08()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - deep pointer(v-array) value" );

	// default constructor
	rd_multimap<const char[],test[]>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	rd_multimap<const char[],test[]>		p0( lr );
	const rd_multimap<const char[],test[]>	c0( lr );
	lr.emplace( s1, dpl( v1 ) );
	rd_multimap<const char[],test[]>		p1( lr );
	const rd_multimap<const char[],test[]>	c1( lr );
	lr.emplace( s2, dpl( v2 ) );
	lr.emplace( s3, dpl( v3 ) );
	lr.emplace( s3, dpl( v3 ) );
	lr.emplace( s3, dpl( v3 ) );
	lr.emplace( s4, dpl( v4 ) );
	lr.emplace( s5, dpl( v5 ) );
	rd_multimap<const char[],test[]>		p5( lr );
	const rd_multimap<const char[],test[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ s1, v1 }} ));
	AssertTrue( check_multimap( p5, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ s1, v1 }} ));
	AssertTrue( check_multimap( c5, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));

	// move constructor
	{
		rd_multimap<const char[],test[]>   lx = lr;
		rd_multimap<const char[],test[]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 },
						 { s3, v3 }, { s4, v4 }, { s5, v5 }} ));
	}
	// copy assignment operator
	{
		rd_multimap<const char[],test[]>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ s1, v1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 },
						 { s3, v3 }, { s4, v4 }, { s5, v5 }} ));
	}
	// move assignment operator
	{
		rd_multimap<const char[],test[]>   lx;

		lr = p1;
		lx = rd_multimap<const char[],test[]>( {{ s5, v5 }, { s3, v3 }, { s3, v3 }, { s3, v3 }, { s2, v2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ s5, v5 }, { s3, v3 }, { s3, v3 }, { s3, v3 }, { s2, v2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ s1, v1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		rd_multimap<const char[],test[]>   lx = p5;
		rd_multimap<const char[],test[]>::iterator	i = lx.find( s4 );

		rd_multimap<const char[],test[]>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 }, { s3, v3 }} ));
		rd_multimap<const char[],test[]>   x0( i, i );
		AssertTrue( x0.empty());
		rd_multimap<const char[],test[]>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ s4, v4 }, { s5, v5 }} ));
	}
	// initializer constructor/assignment operator
	{
		rd_multimap<const char[],test[]>   lx = p5;
		rd_multimap<const char[],test[]>   x0 { };
		rd_multimap<const char[],test[]>   x1 {{ s1, v1 }};
		rd_multimap<const char[],test[]>   x5 {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 }, { s5, v5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ s1, v1 }} ));
		AssertTrue( check_multimap( x5, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 }, { s5, v5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, v1 }};
		AssertTrue( check_multimap( lx, {{ s1, v1 }} ));
		lx = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 }, { s5, v5 }};
		AssertTrue( check_multimap( lx, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s3, v3 }, { s5, v5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test09()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - reference pointer(f-array) value" );

	// default constructor
	rr_multimap<const char[],test[3]>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	rr_multimap<const char[],test[3]>		p0( lr );
	const rr_multimap<const char[],test[3]>	c0( lr );
	lr.emplace( s1, w1 );
	rr_multimap<const char[],test[3]>		p1( lr );
	const rr_multimap<const char[],test[3]>	c1( lr );
	lr.emplace( s2, w2 );
	lr.emplace( s3, w3 );
	lr.emplace( s3, w3 );
	lr.emplace( s3, w3 );
	lr.emplace( s4, w4 );
	lr.emplace( s5, w5 );
	rr_multimap<const char[],test[3]>		p5( lr );
	const rr_multimap<const char[],test[3]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ s1, w1 }} ));
	AssertTrue( check_multimap( p5, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ s1, w1 }} ));
	AssertTrue( check_multimap( c5, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));

	// move constructor
	{
		rr_multimap<const char[],test[3]>   lx = lr;
		rr_multimap<const char[],test[3]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 },
						 { s3, w3 }, { s4, w4 }, { s5, w5 }} ));
	}
	// copy assignment operator
	{
		rr_multimap<const char[],test[3]>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ s1, w1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 },
						 { s3, w3 }, { s4, w4 }, { s5, w5 }} ));
	}
	// move assignment operator
	{
		rr_multimap<const char[],test[3]>   lx;

		lr = p1;
		lx = rr_multimap<const char[],test[3]>( {{ s5, w5 }, { s3, w3 }, { s3, w3 }, { s3, w3 }, { s2, w2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ s5, w5 }, { s3, w3 }, { s3, w3 }, { s3, w3 }, { s2, w2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ s1, w1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		rr_multimap<const char[],test[3]>   lx = p5;
		rr_multimap<const char[],test[3]>::iterator	i = lx.find( s4 );

		rr_multimap<const char[],test[3]>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 }, { s3, w3 }} ));
		rr_multimap<const char[],test[3]>   x0( i, i );
		AssertTrue( x0.empty());
		rr_multimap<const char[],test[3]>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ s4, w4 }, { s5, w5 }} ));
	}
	// initializer constructor/assignment operator
	{
		rr_multimap<const char[],test[3]>   lx = p5;
		rr_multimap<const char[],test[3]>   x0 { };
		rr_multimap<const char[],test[3]>   x1 {{ s1, w1 }};
		rr_multimap<const char[],test[3]>   x5 {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 }, { s5, w5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ s1, w1 }} ));
		AssertTrue( check_multimap( x5, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 }, { s5, w5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, w1 }};
		AssertTrue( check_multimap( lx, {{ s1, w1 }} ));
		lx = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 }, { s5, w5 }};
		AssertTrue( check_multimap( lx, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 }, { s5, w5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test0A()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - deep pointer(f-array) value" );

	// default constructor
	rd_multimap<const char[],test[3]>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	rd_multimap<const char[],test[3]>		p0( lr );
	const rd_multimap<const char[],test[3]>	c0( lr );
	lr.emplace( s1, dpl( w1 ) );
	rd_multimap<const char[],test[3]>		p1( lr );
	const rd_multimap<const char[],test[3]>	c1( lr );
	lr.emplace( s2, dpl( w2 ) );
	lr.emplace( s3, dpl( w3 ) );
	lr.emplace( s3, dpl( w3 ) );
	lr.emplace( s3, dpl( w3 ) );
	lr.emplace( s4, dpl( w4 ) );
	lr.emplace( s5, dpl( w5 ) );
	rd_multimap<const char[],test[3]>		p5( lr );
	const rd_multimap<const char[],test[3]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ s1, w1 }} ));
	AssertTrue( check_multimap( p5, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ s1, w1 }} ));
	AssertTrue( check_multimap( c5, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));

	// move constructor
	{
		rd_multimap<const char[],test[3]>   lx = lr;
		rd_multimap<const char[],test[3]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 },
						 { s3, w3 }, { s4, w4 }, { s5, w5 }} ));
	}
	// copy assignment operator
	{
		rd_multimap<const char[],test[3]>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ s1, w1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 },
						 { s3, w3 }, { s4, w4 }, { s5, w5 }} ));
	}
	// move assignment operator
	{
		rd_multimap<const char[],test[3]>   lx;

		lr = p1;
		lx = rd_multimap<const char[],test[3]>( {{ s5, w5 }, { s3, w3 }, { s3, w3 }, { s3, w3 }, { s2, w2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ s5, w5 }, { s3, w3 }, { s3, w3 }, { s3, w3 }, { s2, w2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ s1, w1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		rd_multimap<const char[],test[3]>   lx = p5;
		rd_multimap<const char[],test[3]>::iterator	i = lx.find( s4 );

		rd_multimap<const char[],test[3]>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 }, { s3, w3 }} ));
		rd_multimap<const char[],test[3]>   x0( i, i );
		AssertTrue( x0.empty());
		rd_multimap<const char[],test[3]>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ s4, w4 }, { s5, w5 }} ));
	}
	// initializer constructor/assignment operator
	{
		rd_multimap<const char[],test[3]>   lx = p5;
		rd_multimap<const char[],test[3]>   x0 { };
		rd_multimap<const char[],test[3]>   x1 {{ s1, w1 }};
		rd_multimap<const char[],test[3]>   x5 {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 }, { s5, w5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ s1, w1 }} ));
		AssertTrue( check_multimap( x5, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 }, { s5, w5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, w1 }};
		AssertTrue( check_multimap( lx, {{ s1, w1 }} ));
		lx = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 }, { s5, w5 }};
		AssertTrue( check_multimap( lx, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s3, w3 }, { s5, w5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test0B()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - data(int value) value" );

	// default constructor
	rn_multimap<const char[],int>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	rn_multimap<const char[],int>		p0( lr );
	const rn_multimap<const char[],int>	c0( lr );
	lr.emplace( s1, 1 );
	rn_multimap<const char[],int>		p1( lr );
	const rn_multimap<const char[],int>	c1( lr );
	lr.emplace( s2, 2 );
	lr.emplace( s3, 3 );
	lr.emplace( s3, 3 );
	lr.emplace( s3, 3 );
	lr.emplace( s4, 4 );
	lr.emplace( s5, 5 );
	rn_multimap<const char[],int>		p5( lr );
	const rn_multimap<const char[],int>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ s1, 1 }} ));
	AssertTrue( check_multimap( p5, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s3, 3 }, { s3, 3 }, { s4, 4 }, { s5, 5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ s1, 1 }} ));
	AssertTrue( check_multimap( c5, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s3, 3 }, { s3, 3 }, { s4, 4 }, { s5, 5 }} ));

	// move constructor
	{
		rn_multimap<const char[],int>   lx = lr;
		rn_multimap<const char[],int>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s3, 3 },
						 { s3, 3 }, { s4, 4 }, { s5, 5 }} ));
	}
	// copy assignment operator
	{
		rn_multimap<const char[],int>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ s1, 1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s3, 3 },
						 { s3, 3 }, { s4, 4 }, { s5, 5 }} ));
	}
	// move assignment operator
	{
		rn_multimap<const char[],int>   lx;

		lr = p1;
		lx = rn_multimap<const char[],int>( {{ s5, 5 }, { s3, 3 }, { s3, 3 }, { s3, 3 }, { s2, 2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ s5, 5 }, { s3, 3 }, { s3, 3 }, { s3, 3 }, { s2, 2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ s1, 1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		rn_multimap<const char[],int>   lx = p5;
		rn_multimap<const char[],int>::iterator	i = lx.find( s4 );

		rn_multimap<const char[],int>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s3, 3 }, { s3, 3 }} ));
		rn_multimap<const char[],int>   x0( i, i );
		AssertTrue( x0.empty());
		rn_multimap<const char[],int>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ s4, 4 }, { s5, 5 }} ));
	}
	// initializer constructor/assignment operator
	{
		rn_multimap<const char[],int>   lx = p5;
		rn_multimap<const char[],int>   x0 { };
		rn_multimap<const char[],int>   x1 {{ s1, 1 }};
		rn_multimap<const char[],int>   x5 {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s3, 3 }, { s5, 5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ s1, 1 }} ));
		AssertTrue( check_multimap( x5, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s3, 3 }, { s5, 5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, 1 }};
		AssertTrue( check_multimap( lx, {{ s1, 1 }} ));
		lx = {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s3, 3 }, { s5, 5 }};
		AssertTrue( check_multimap( lx, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s3, 3 }, { s5, 5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test0C()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - deep pointer(pointer) value" );

	// default constructor
	rd_multimap<const char[],test*>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	rd_multimap<const char[],test*>		p0( lr );
	const rd_multimap<const char[],test*>	c0( lr );
	lr.emplace( s1, dpl( &t1 ) );
	rd_multimap<const char[],test*>		p1( lr );
	const rd_multimap<const char[],test*>	c1( lr );
	lr.emplace( s2, dpl( &t2 ) );
	lr.emplace( s3, dpl( &t3 ) );
	lr.emplace( s3, dpl( &t3 ) );
	lr.emplace( s3, dpl( &t3 ) );
	lr.emplace( s4, dpl( &t4 ) );
	lr.emplace( s5, dpl( &t5 ) );
	rd_multimap<const char[],test*>		p5( lr );
	const rd_multimap<const char[],test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ s1, &t1 }} ));
	AssertTrue( check_multimap( p5, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ s1, &t1 }} ));
	AssertTrue( check_multimap( c5, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));

	// move constructor
	{
		rd_multimap<const char[],test*>   lx = lr;
		rd_multimap<const char[],test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 },
						 { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));
	}
	// copy assignment operator
	{
		rd_multimap<const char[],test*>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ s1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 },
						 { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));
	}
	// move assignment operator
	{
		rd_multimap<const char[],test*>   lx;

		lr = p1;
		lx = rd_multimap<const char[],test*>( {{ s5, &t5 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s2, &t2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ s5, &t5 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ s1, &t1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		rd_multimap<const char[],test*>   lx = p5;
		rd_multimap<const char[],test*>::iterator	i = lx.find( s4 );

		rd_multimap<const char[],test*>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }} ));
		rd_multimap<const char[],test*>   x0( i, i );
		AssertTrue( x0.empty());
		rd_multimap<const char[],test*>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ s4, &t4 }, { s5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		rd_multimap<const char[],test*>   lx = p5;
		rd_multimap<const char[],test*>   x0 { };
		rd_multimap<const char[],test*>   x1 {{ s1, &t1 }};
		rd_multimap<const char[],test*>   x5 {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ s1, &t1 }} ));
		AssertTrue( check_multimap( x5, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, &t1 }};
		AssertTrue( check_multimap( lx, {{ s1, &t1 }} ));
		lx = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s5, &t5 }};
		AssertTrue( check_multimap( lx, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test0D()
{
	this->set_subtitle( "constructor/assignment/destructor, deep pointer(c-string) key - deep pointer(pointer) value" );

	// default constructor
	dd_multimap<const char[],test*>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	dd_multimap<const char[],test*>		p0( lr );
	const dd_multimap<const char[],test*>	c0( lr );
	lr.emplace( strdup( s1 ), dpl( &t1 ) );
	dd_multimap<const char[],test*>		p1( lr );
	const dd_multimap<const char[],test*>	c1( lr );
	lr.emplace( strdup( s2 ), dpl( &t2 ) );
	lr.emplace( strdup( s3 ), dpl( &t3 ) );
	lr.emplace( strdup( s3 ), dpl( &t3 ) );
	lr.emplace( strdup( s3 ), dpl( &t3 ) );
	lr.emplace( strdup( s4 ), dpl( &t4 ) );
	lr.emplace( strdup( s5 ), dpl( &t5 ) );
	dd_multimap<const char[],test*>		p5( lr );
	const dd_multimap<const char[],test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ s1, &t1 }} ));
	AssertTrue( check_multimap( p5, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ s1, &t1 }} ));
	AssertTrue( check_multimap( c5, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));

	// move constructor
	{
		dd_multimap<const char[],test*>   lx = lr;
		dd_multimap<const char[],test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 },
						 { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));
	}
	// copy assignment operator
	{
		dd_multimap<const char[],test*>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ s1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 },
						 { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));
	}
	// move assignment operator
	{
		dd_multimap<const char[],test*>   lx;

		lr = p1;
		lx = dd_multimap<const char[],test*>( {{ s5, &t5 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s2, &t2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ s5, &t5 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ s1, &t1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		dd_multimap<const char[],test*>   lx = p5;
		dd_multimap<const char[],test*>::iterator	i = lx.find( s4 );

		dd_multimap<const char[],test*>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }} ));
		dd_multimap<const char[],test*>   x0( i, i );
		AssertTrue( x0.empty());
		dd_multimap<const char[],test*>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ s4, &t4 }, { s5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		dd_multimap<const char[],test*>   lx = p5;
		dd_multimap<const char[],test*>   x0 { };
		dd_multimap<const char[],test*>   x1 {{ s1, &t1 }};
		dd_multimap<const char[],test*>   x5 {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ s1, &t1 }} ));
		AssertTrue( check_multimap( x5, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, &t1 }};
		AssertTrue( check_multimap( lx, {{ s1, &t1 }} ));
		lx = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s5, &t5 }};
		AssertTrue( check_multimap( lx, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test0E()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(v-array) key - deep pointer(pointer) value" );

	// default constructor
	rd_multimap<test[],test*>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	rd_multimap<test[],test*>		p0( lr );
	const rd_multimap<test[],test*>	c0( lr );
	lr.emplace( v1, dpl( &t1 ) );
	rd_multimap<test[],test*>		p1( lr );
	const rd_multimap<test[],test*>	c1( lr );
	lr.emplace( v2, dpl( &t2 ) );
	lr.emplace( v3, dpl( &t3 ) );
	lr.emplace( v3, dpl( &t3 ) );
	lr.emplace( v3, dpl( &t3 ) );
	lr.emplace( v4, dpl( &t4 ) );
	lr.emplace( v5, dpl( &t5 ) );
	rd_multimap<test[],test*>		p5( lr );
	const rd_multimap<test[],test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ v1, &t1 }} ));
	AssertTrue( check_multimap( p5, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ v1, &t1 }} ));
	AssertTrue( check_multimap( c5, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));

	// move constructor
	{
		rd_multimap<test[],test*>   lx = lr;
		rd_multimap<test[],test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 },
						 { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));
	}
	// copy assignment operator
	{
		rd_multimap<test[],test*>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ v1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 },
						 { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));
	}
	// move assignment operator
	{
		rd_multimap<test[],test*>   lx;

		lr = p1;
		lx = rd_multimap<test[],test*>( {{ v5, &t5 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v2, &t2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ v5, &t5 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ v1, &t1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		rd_multimap<test[],test*>   lx = p5;
		rd_multimap<test[],test*>::iterator	i = lx.find( v4 );

		rd_multimap<test[],test*>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }} ));
		rd_multimap<test[],test*>   x0( i, i );
		AssertTrue( x0.empty());
		rd_multimap<test[],test*>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ v4, &t4 }, { v5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		rd_multimap<test[],test*>   lx = p5;
		rd_multimap<test[],test*>   x0 { };
		rd_multimap<test[],test*>   x1 {{ v1, &t1 }};
		rd_multimap<test[],test*>   x5 {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ v1, &t1 }} ));
		AssertTrue( check_multimap( x5, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ v1, &t1 }};
		AssertTrue( check_multimap( lx, {{ v1, &t1 }} ));
		lx = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v5, &t5 }};
		AssertTrue( check_multimap( lx, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test0F()
{
	this->set_subtitle( "constructor/assignment/destructor, deep pointer(v-array) key - deep pointer(pointer) value" );

	// default constructor
	dd_multimap<test[],test*>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	dd_multimap<test[],test*>		p0( lr );
	const dd_multimap<test[],test*>	c0( lr );
	lr.emplace( dpl( v1 ), dpl( &t1 ) );
	dd_multimap<test[],test*>		p1( lr );
	const dd_multimap<test[],test*>	c1( lr );
	lr.emplace( dpl( v2 ), dpl( &t2 ) );
	lr.emplace( dpl( v3 ), dpl( &t3 ) );
	lr.emplace( dpl( v3 ), dpl( &t3 ) );
	lr.emplace( dpl( v3 ), dpl( &t3 ) );
	lr.emplace( dpl( v4 ), dpl( &t4 ) );
	lr.emplace( dpl( v5 ), dpl( &t5 ) );
	dd_multimap<test[],test*>		p5( lr );
	const dd_multimap<test[],test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ v1, &t1 }} ));
	AssertTrue( check_multimap( p5, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ v1, &t1 }} ));
	AssertTrue( check_multimap( c5, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));

	// move constructor
	{
		dd_multimap<test[],test*>   lx = lr;
		dd_multimap<test[],test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 },
						 { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));
	}
	// copy assignment operator
	{
		dd_multimap<test[],test*>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ v1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 },
						 { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));
	}
	// move assignment operator
	{
		dd_multimap<test[],test*>   lx;

		lr = p1;
		lx = dd_multimap<test[],test*>( {{ v5, &t5 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v2, &t2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ v5, &t5 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ v1, &t1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		dd_multimap<test[],test*>   lx = p5;
		dd_multimap<test[],test*>::iterator	i = lx.find( v4 );

		dd_multimap<test[],test*>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }} ));
		dd_multimap<test[],test*>   x0( i, i );
		AssertTrue( x0.empty());
		dd_multimap<test[],test*>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ v4, &t4 }, { v5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		dd_multimap<test[],test*>   lx = p5;
		dd_multimap<test[],test*>   x0 { };
		dd_multimap<test[],test*>   x1 {{ v1, &t1 }};
		dd_multimap<test[],test*>   x5 {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ v1, &t1 }} ));
		AssertTrue( check_multimap( x5, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ v1, &t1 }};
		AssertTrue( check_multimap( lx, {{ v1, &t1 }} ));
		lx = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v5, &t5 }};
		AssertTrue( check_multimap( lx, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test10()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(f-array) key - deep pointer(pointer) value" );

	// default constructor
	rd_multimap<test[3],test*>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	rd_multimap<test[3],test*>		p0( lr );
	const rd_multimap<test[3],test*>	c0( lr );
	lr.emplace( w1, dpl( &t1 ) );
	rd_multimap<test[3],test*>		p1( lr );
	const rd_multimap<test[3],test*>	c1( lr );
	lr.emplace( w2, dpl( &t2 ) );
	lr.emplace( w3, dpl( &t3 ) );
	lr.emplace( w3, dpl( &t3 ) );
	lr.emplace( w3, dpl( &t3 ) );
	lr.emplace( w4, dpl( &t4 ) );
	lr.emplace( w5, dpl( &t5 ) );
	rd_multimap<test[3],test*>		p5( lr );
	const rd_multimap<test[3],test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ w1, &t1 }} ));
	AssertTrue( check_multimap( p5, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ w1, &t1 }} ));
	AssertTrue( check_multimap( c5, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));

	// move constructor
	{
		rd_multimap<test[3],test*>   lx = lr;
		rd_multimap<test[3],test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 },
						 { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));
	}
	// copy assignment operator
	{
		rd_multimap<test[3],test*>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ w1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 },
						 { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));
	}
	// move assignment operator
	{
		rd_multimap<test[3],test*>   lx;

		lr = p1;
		lx = rd_multimap<test[3],test*>( {{ w5, &t5 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w2, &t2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ w5, &t5 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ w1, &t1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		rd_multimap<test[3],test*>   lx = p5;
		rd_multimap<test[3],test*>::iterator	i = lx.find( w4 );

		rd_multimap<test[3],test*>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }} ));
		rd_multimap<test[3],test*>   x0( i, i );
		AssertTrue( x0.empty());
		rd_multimap<test[3],test*>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ w4, &t4 }, { w5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		rd_multimap<test[3],test*>   lx = p5;
		rd_multimap<test[3],test*>   x0 { };
		rd_multimap<test[3],test*>   x1 {{ w1, &t1 }};
		rd_multimap<test[3],test*>   x5 {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ w1, &t1 }} ));
		AssertTrue( check_multimap( x5, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ w1, &t1 }};
		AssertTrue( check_multimap( lx, {{ w1, &t1 }} ));
		lx = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w5, &t5 }};
		AssertTrue( check_multimap( lx, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test11()
{
	this->set_subtitle( "constructor/assignment/destructor, deep pointer(f-array) key - deep pointer(pointer) value" );

	// default constructor
	dd_multimap<test[3],test*>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	dd_multimap<test[3],test*>		p0( lr );
	const dd_multimap<test[3],test*>	c0( lr );
	lr.emplace( dpl( w1 ), dpl( &t1 ) );
	dd_multimap<test[3],test*>		p1( lr );
	const dd_multimap<test[3],test*>	c1( lr );
	lr.emplace( dpl( w2 ), dpl( &t2 ) );
	lr.emplace( dpl( w3 ), dpl( &t3 ) );
	lr.emplace( dpl( w3 ), dpl( &t3 ) );
	lr.emplace( dpl( w3 ), dpl( &t3 ) );
	lr.emplace( dpl( w4 ), dpl( &t4 ) );
	lr.emplace( dpl( w5 ), dpl( &t5 ) );
	dd_multimap<test[3],test*>		p5( lr );
	const dd_multimap<test[3],test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ w1, &t1 }} ));
	AssertTrue( check_multimap( p5, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ w1, &t1 }} ));
	AssertTrue( check_multimap( c5, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));

	// move constructor
	{
		dd_multimap<test[3],test*>   lx = lr;
		dd_multimap<test[3],test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 },
						 { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));
	}
	// copy assignment operator
	{
		dd_multimap<test[3],test*>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ w1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 },
						 { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));
	}
	// move assignment operator
	{
		dd_multimap<test[3],test*>   lx;

		lr = p1;
		lx = dd_multimap<test[3],test*>( {{ w5, &t5 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w2, &t2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ w5, &t5 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ w1, &t1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		dd_multimap<test[3],test*>   lx = p5;
		dd_multimap<test[3],test*>::iterator	i = lx.find( w4 );

		dd_multimap<test[3],test*>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }} ));
		dd_multimap<test[3],test*>   x0( i, i );
		AssertTrue( x0.empty());
		dd_multimap<test[3],test*>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ w4, &t4 }, { w5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		dd_multimap<test[3],test*>   lx = p5;
		dd_multimap<test[3],test*>   x0 { };
		dd_multimap<test[3],test*>   x1 {{ w1, &t1 }};
		dd_multimap<test[3],test*>   x5 {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ w1, &t1 }} ));
		AssertTrue( check_multimap( x5, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ w1, &t1 }};
		AssertTrue( check_multimap( lx, {{ w1, &t1 }} ));
		lx = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w5, &t5 }};
		AssertTrue( check_multimap( lx, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test12()
{
	this->set_subtitle( "constructor/assignment/destructor, data(int value) key - deep pointer(pointer) value" );

	// default constructor
	nd_multimap<int,test*>	lr;
	AssertTrue( check_multimap( lr, { } ));

	// copy constructor
	nd_multimap<int,test*>		p0( lr );
	const nd_multimap<int,test*>	c0( lr );
	lr.emplace( 1, dpl( &t1 ) );
	nd_multimap<int,test*>		p1( lr );
	const nd_multimap<int,test*>	c1( lr );
	lr.emplace( 2, dpl( &t2 ) );
	lr.emplace( 3, dpl( &t3 ) );
	lr.emplace( 3, dpl( &t3 ) );
	lr.emplace( 3, dpl( &t3 ) );
	lr.emplace( 4, dpl( &t4 ) );
	lr.emplace( 5, dpl( &t5 ) );
	nd_multimap<int,test*>		p5( lr );
	const nd_multimap<int,test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_multimap( p1, {{ 1, &t1 }} ));
	AssertTrue( check_multimap( p5, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 3, &t3 }, { 3, &t3 }, { 4, &t4 }, { 5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_multimap( c1, {{ 1, &t1 }} ));
	AssertTrue( check_multimap( c5, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 3, &t3 }, { 3, &t3 }, { 4, &t4 }, { 5, &t5 }} ));

	// move constructor
	{
		nd_multimap<int,test*>   lx = lr;
		nd_multimap<int,test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_multimap( ly, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 3, &t3 },
						 { 3, &t3 }, { 4, &t4 }, { 5, &t5 }} ));
	}
	// copy assignment operator
	{
		nd_multimap<int,test*>   lx;

		lx = p1;
		AssertTrue( check_multimap( lx, {{ 1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_multimap( lx, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 3, &t3 },
						 { 3, &t3 }, { 4, &t4 }, { 5, &t5 }} ));
	}
	// move assignment operator
	{
		nd_multimap<int,test*>   lx;

		lr = p1;
		lx = nd_multimap<int,test*>( {{ 5, &t5 }, { 3, &t3 }, { 3, &t3 }, { 3, &t3 }, { 2, &t2 }} );// move assignment by r-value
		AssertTrue( check_multimap( lx, {{ 5, &t5 }, { 3, &t3 }, { 3, &t3 }, { 3, &t3 }, { 2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_multimap( lx, {{ 1, &t1 }} ));
		AssertTrue( check_multimap( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_multimap( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		nd_multimap<int,test*>   lx = p5;
		nd_multimap<int,test*>::iterator	i = lx.find( 4 );

		nd_multimap<int,test*>   x3( lx.begin(), i );
		AssertTrue( check_multimap( x3, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 3, &t3 }, { 3, &t3 }} ));
		nd_multimap<int,test*>   x0( i, i );
		AssertTrue( x0.empty());
		nd_multimap<int,test*>   x1( i, lx.end());
		AssertTrue( check_multimap( x1, {{ 4, &t4 }, { 5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		nd_multimap<int,test*>   lx = p5;
		nd_multimap<int,test*>   x0 { };
		nd_multimap<int,test*>   x1 {{ 1, &t1 }};
		nd_multimap<int,test*>   x5 {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 3, &t3 }, { 5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_multimap( x1, {{ 1, &t1 }} ));
		AssertTrue( check_multimap( x5, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 3, &t3 }, { 5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ 1, &t1 }};
		AssertTrue( check_multimap( lx, {{ 1, &t1 }} ));
		lx = {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 3, &t3 }, { 5, &t5 }};
		AssertTrue( check_multimap( lx, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 3, &t3 }, { 5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test13()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, reference pointer(pointer) key - reference pointer(pointer) value" );

	rr_multimap<test*,test*>	pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t2, &t2 },
		      { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }, { &t4, &t4 },
		      { &t4, &t4 }, { &t1, &t1 }, { &t2, &t2 }};
	rr_multimap<test*,test*> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t2, &t2 },
					 { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }, { &t4, &t4 },
					 { &t4, &t4 }, { &t1, &t1 }, { &t2, &t2 }} ));
	print( cm );

	AssertNotEqual( pm.find( &t4 ), pm.end());
	AssertEqual( pm.find( &t4 )->first, &t4 );
	AssertEqual( pm.find( &t4 )->second, &t4 );
	AssertEqual( *pm.find( &t4 )->second, t4 );
	AssertEqual( pm.find( &t7 ), pm.end());

	AssertNotEqual( cm.find( &t4 ), cm.end());
	AssertEqual( cm.find( &t4 )->first, &t4 );
	AssertEqual( cm.find( &t4 )->second, &t4 );
	AssertEqual( *cm.find( &t4 )->second, t4 );
	AssertEqual( cm.find( &t7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const test*,test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	rr_multimap<test*,test*>::iterator		b, e;
	rr_multimap<test*,test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( &t4 );
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( &t4 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 },
					 { &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( &t8 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 }, { &t5, &t5 },
					 { &t8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( &t4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( &t8 );
	f = cm.find( &t4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 }, { &t5, &t5 },
					 { &t8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( &t4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 },
					 { &t5, &t5 }, { &t8, &t8 }} ));

	// (.<-.&t4]
	b = pm.upper_bound( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t4, &t4 },
					 { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 }} ));

	// (&t4.->.)
	c = cm.upper_bound( &t4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ &t5, &t5 }, { &t5, &t5 }, { &t8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( &t3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( &t8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test14()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, deep pointer(pointer) key - reference pointer(pointer) value" );

	dr_multimap<test*,test*>	pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t2, &t2 },
		      { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }, { &t4, &t4 },
		      { &t4, &t4 }, { &t1, &t1 }, { &t2, &t2 }};
	dr_multimap<test*,test*> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t2, &t2 },
					 { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }, { &t4, &t4 },
					 { &t4, &t4 }, { &t1, &t1 }, { &t2, &t2 }} ));
	print( cm );

	AssertNotEqual( pm.find( &t4 ), pm.end());
	AssertNotEqual( pm.find( &t4 )->first, &t4 );
	AssertTrue( dp_eql<const test*>()( pm.find( &t4 )->first, &t4 ));
	AssertEqual( pm.find( &t4 )->second, &t4 );
	AssertEqual( *pm.find( &t4 )->second, t4 );
	AssertEqual( pm.find( &t7 ), pm.end());

	AssertNotEqual( cm.find( &t4 ), cm.end());
	AssertNotEqual( cm.find( &t4 )->first, &t4 );
	AssertTrue( dp_eql<const test*>()( cm.find( &t4 )->first, &t4 ));
	AssertEqual( cm.find( &t4 )->second, &t4 );
	AssertEqual( *cm.find( &t4 )->second, t4 );
	AssertEqual( cm.find( &t7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const test*,test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	dr_multimap<test*,test*>::iterator		b, e;
	dr_multimap<test*,test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( &t4 );
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( &t4 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 },
					 { &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( &t8 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 }, { &t5, &t5 },
					 { &t8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( &t4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( &t8 );
	f = cm.find( &t4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 }, { &t5, &t5 },
					 { &t8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( &t4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 },
					 { &t5, &t5 }, { &t8, &t8 }} ));

	// (.<-.&t4]
	b = pm.upper_bound( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t4, &t4 },
					 { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 }} ));

	// (&t4.->.)
	c = cm.upper_bound( &t4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ &t5, &t5 }, { &t5, &t5 }, { &t8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( &t3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( &t8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test15()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, reference pointer(pointer) key - deep pointer(pointer) value" );

	rd_multimap<test*,test*>	pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t2, &t2 },
		      { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }, { &t4, &t4 },
		      { &t4, &t4 }, { &t1, &t1 }, { &t2, &t2 }};
	rd_multimap<test*,test*> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t2, &t2 },
					 { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }, { &t4, &t4 },
					 { &t4, &t4 }, { &t1, &t1 }, { &t2, &t2 }} ));
	print( cm );

	AssertNotEqual( pm.find( &t4 ), pm.end());
	AssertEqual( pm.find( &t4 )->first, &t4 );
	AssertNotEqual( pm.find( &t4 )->second, &t4 );
	AssertEqual( *pm.find( &t4 )->second, t4 );
	AssertEqual( pm.find( &t7 ), pm.end());

	AssertNotEqual( cm.find( &t4 ), cm.end());
	AssertEqual( cm.find( &t4 )->first, &t4 );
	AssertNotEqual( cm.find( &t4 )->second, &t4 );
	AssertEqual( *cm.find( &t4 )->second, t4 );
	AssertEqual( cm.find( &t7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const test*,test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	rd_multimap<test*,test*>::iterator		b, e;
	rd_multimap<test*,test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( &t4 );
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( &t4 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 },
					 { &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( &t8 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 }, { &t5, &t5 },
					 { &t8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( &t4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( &t8 );
	f = cm.find( &t4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 }, { &t5, &t5 },
					 { &t8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( &t4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 },
					 { &t5, &t5 }, { &t8, &t8 }} ));

	// (.<-.&t4]
	b = pm.upper_bound( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t4, &t4 },
					 { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 }} ));

	// (&t4.->.)
	c = cm.upper_bound( &t4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ &t5, &t5 }, { &t5, &t5 }, { &t8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( &t3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( &t8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test16()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, deep pointer(pointer) key - deep pointer(pointer) value" );

	dd_multimap<test*,test*>	pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t2, &t2 },
		      { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }, { &t4, &t4 },
		      { &t4, &t4 }, { &t1, &t1 }, { &t2, &t2 }};
	dd_multimap<test*,test*> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t2, &t2 },
					 { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }, { &t4, &t4 },
					 { &t4, &t4 }, { &t1, &t1 }, { &t2, &t2 }} ));
	print( cm );

	AssertNotEqual( pm.find( &t4 ), pm.end());
	AssertNotEqual( pm.find( &t4 )->first, &t4 );
	AssertTrue( dp_eql<const test*>()( pm.find( &t4 )->first, &t4 ));
	AssertNotEqual( pm.find( &t4 )->second, &t4 );
	AssertEqual( *pm.find( &t4 )->second, t4 );
	AssertEqual( pm.find( &t7 ), pm.end());

	AssertNotEqual( cm.find( &t4 ), cm.end());
	AssertNotEqual( cm.find( &t4 )->first, &t4 );
	AssertTrue( dp_eql<const test*>()( cm.find( &t4 )->first, &t4 ));
	AssertNotEqual( cm.find( &t4 )->second, &t4 );
	AssertEqual( *cm.find( &t4 )->second, t4 );
	AssertEqual( cm.find( &t7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const test*,test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	dd_multimap<test*,test*>::iterator		b, e;
	dd_multimap<test*,test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( &t4 );
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( &t4 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 },
					 { &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( &t8 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 }, { &t5, &t5 },
					 { &t8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( &t4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( &t8 );
	f = cm.find( &t4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 }, { &t5, &t5 },
					 { &t8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( &t4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 },
					 { &t5, &t5 }, { &t8, &t8 }} ));

	// (.<-.&t4]
	b = pm.upper_bound( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t4, &t4 },
					 { &t4, &t4 }, { &t4, &t4 }, { &t5, &t5 }} ));

	// (&t4.->.)
	c = cm.upper_bound( &t4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ &t5, &t5 }, { &t5, &t5 }, { &t8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ &t1, &t1 }, { &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t2, &t2 },
					 { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( &t3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( &t8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test17()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - reference pointer(c-string) value" );

	rr_multimap<const char[],const char[]>	pm = {{ s1, s1 }, { s2, s2 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s2, s2 },
		      { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 }, { s5, s5 }, { s4, s4 },
		      { s4, s4 }, { s1, s1 }, { s2, s2 }};
	rr_multimap<const char[],const char[]> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ s1, s1 }, { s2, s2 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s2, s2 },
					 { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 }, { s5, s5 }, { s4, s4 },
					 { s4, s4 }, { s1, s1 }, { s2, s2 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertEqual( pm.find( s4 )->second, s4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertEqual( cm.find( s4 )->second, s4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const char[],const char[]>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	rr_multimap<const char[],const char[]>::iterator		b, e;
	rr_multimap<const char[],const char[]>::const_iterator	c, f;

	// [s4.->.s4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ s4, s4 }, { s4, s4 }, { s4, s4 }, { s4, s4 }} ));

	// (s4.<-.s4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.s4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { s1, s1 }, { s1, s1 }, { s2, s2 }, { s2, s2 },
					 { s2, s2 }, { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 },
					 { s4, s4 }, { s4, s4 }, { s4, s4 }} ));

	// [s4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ s4, s4 }, { s4, s4 }, { s4, s4 }, { s5, s5 }, { s5, s5 },
					 { s8, s8 }} ));

	// [.->.s4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { s1, s1 }, { s1, s1 }, { s2, s2 }, { s2, s2 },
					 { s2, s2 }, { s3, s3 }, { s3, s3 }, { s3, s3 }} ));

	// (s4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ s4, s4 }, { s4, s4 }, { s4, s4 }, { s5, s5 }, { s5, s5 },
					 { s8, s8 }} ));

	// [s4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ s4, s4 }, { s4, s4 }, { s4, s4 }, { s4, s4 }, { s5, s5 },
					 { s5, s5 }, { s8, s8 }} ));

	// (.<-.s4]
	b = pm.upper_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ s1, s1 }, { s1, s1 }, { s2, s2 }, { s2, s2 }, { s2, s2 },
					 { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 }, { s4, s4 },
					 { s4, s4 }, { s4, s4 }, { s5, s5 }} ));

	// (s4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ s5, s5 }, { s5, s5 }, { s8, s8 }} ));

	// (.<-.s4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ s1, s1 }, { s1, s1 }, { s2, s2 }, { s2, s2 }, { s2, s2 },
					 { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 }} ));

	// equal range
	auto r = pm.equal_range( s3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ s3, s3 }, { s3, s3 }, { s3, s3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test18()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - deep pointer(c-string) value" );

	rd_multimap<const char[],const char[]>	pm = {{ s1, s1 }, { s2, s2 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s2, s2 },
		      { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 }, { s5, s5 }, { s4, s4 },
		      { s4, s4 }, { s1, s1 }, { s2, s2 }};
	rd_multimap<const char[],const char[]> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ s1, s1 }, { s2, s2 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s2, s2 },
					 { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 }, { s5, s5 }, { s4, s4 },
					 { s4, s4 }, { s1, s1 }, { s2, s2 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertNotEqual( pm.find( s4 )->second, s4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertNotEqual( cm.find( s4 )->second, s4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const char[],const char[]>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	rd_multimap<const char[],const char[]>::iterator		b, e;
	rd_multimap<const char[],const char[]>::const_iterator	c, f;

	// [s4.->.s4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ s4, s4 }, { s4, s4 }, { s4, s4 }, { s4, s4 }} ));

	// (s4.<-.s4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.s4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { s1, s1 }, { s1, s1 }, { s2, s2 }, { s2, s2 },
					 { s2, s2 }, { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 },
					 { s4, s4 }, { s4, s4 }, { s4, s4 }} ));

	// [s4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ s4, s4 }, { s4, s4 }, { s4, s4 }, { s5, s5 }, { s5, s5 },
					 { s8, s8 }} ));

	// [.->.s4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { s1, s1 }, { s1, s1 }, { s2, s2 }, { s2, s2 },
					 { s2, s2 }, { s3, s3 }, { s3, s3 }, { s3, s3 }} ));

	// (s4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ s4, s4 }, { s4, s4 }, { s4, s4 }, { s5, s5 }, { s5, s5 },
					 { s8, s8 }} ));

	// [s4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ s4, s4 }, { s4, s4 }, { s4, s4 }, { s4, s4 }, { s5, s5 },
					 { s5, s5 }, { s8, s8 }} ));

	// (.<-.s4]
	b = pm.upper_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ s1, s1 }, { s1, s1 }, { s2, s2 }, { s2, s2 }, { s2, s2 },
					 { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 }, { s4, s4 },
					 { s4, s4 }, { s4, s4 }, { s5, s5 }} ));

	// (s4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ s5, s5 }, { s5, s5 }, { s8, s8 }} ));

	// (.<-.s4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ s1, s1 }, { s1, s1 }, { s2, s2 }, { s2, s2 }, { s2, s2 },
					 { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 }} ));

	// equal range
	auto r = pm.equal_range( s3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ s3, s3 }, { s3, s3 }, { s3, s3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test19()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - reference pointer(v-array) value" );

	rr_multimap<const char[],test[]>	pm = {{ s1, v1 }, { s2, v2 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s2, v2 },
		      { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 }, { s5, v5 }, { s4, v4 },
		      { s4, v4 }, { s1, v1 }, { s2, v2 }};
	rr_multimap<const char[],test[]> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ s1, v1 }, { s2, v2 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s2, v2 },
					 { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 }, { s5, v5 }, { s4, v4 },
					 { s4, v4 }, { s1, v1 }, { s2, v2 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertEqual( pm.find( s4 )->second, v4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertEqual( cm.find( s4 )->second, v4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const char[],test[]>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	rr_multimap<const char[],test[]>::iterator		b, e;
	rr_multimap<const char[],test[]>::const_iterator	c, f;

	// [v4.->.v4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ s4, v4 }, { s4, v4 }, { s4, v4 }, { s4, v4 }} ));

	// (v4.<-.v4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.v4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { s1, v1 }, { s1, v1 }, { s2, v2 }, { s2, v2 },
					 { s2, v2 }, { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 },
					 { s4, v4 }, { s4, v4 }, { s4, v4 }} ));

	// [v4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ s4, v4 }, { s4, v4 }, { s4, v4 }, { s5, v5 }, { s5, v5 },
					 { s8, v8 }} ));

	// [.->.v4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { s1, v1 }, { s1, v1 }, { s2, v2 }, { s2, v2 },
					 { s2, v2 }, { s3, v3 }, { s3, v3 }, { s3, v3 }} ));

	// (v4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ s4, v4 }, { s4, v4 }, { s4, v4 }, { s5, v5 }, { s5, v5 },
					 { s8, v8 }} ));

	// [v4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ s4, v4 }, { s4, v4 }, { s4, v4 }, { s4, v4 }, { s5, v5 },
					 { s5, v5 }, { s8, v8 }} ));

	// (.<-.v4]
	b = pm.upper_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ s1, v1 }, { s1, v1 }, { s2, v2 }, { s2, v2 }, { s2, v2 },
					 { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 }, { s4, v4 },
					 { s4, v4 }, { s4, v4 }, { s5, v5 }} ));

	// (v4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ s5, v5 }, { s5, v5 }, { s8, v8 }} ));

	// (.<-.v4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ s1, v1 }, { s1, v1 }, { s2, v2 }, { s2, v2 }, { s2, v2 },
					 { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 }} ));

	// equal range
	auto r = pm.equal_range( s3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ s3, v3 }, { s3, v3 }, { s3, v3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test1A()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - deep pointer(v-array) value" );

	rd_multimap<const char[],test[]>	pm = {{ s1, v1 }, { s2, v2 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s2, v2 },
		      { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 }, { s5, v5 }, { s4, v4 },
		      { s4, v4 }, { s1, v1 }, { s2, v2 }};
	rd_multimap<const char[],test[]> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ s1, v1 }, { s2, v2 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s2, v2 },
					 { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 }, { s5, v5 }, { s4, v4 },
					 { s4, v4 }, { s1, v1 }, { s2, v2 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertNotEqual( pm.find( s4 )->second, v4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertNotEqual( cm.find( s4 )->second, v4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const char[],test[]>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	rd_multimap<const char[],test[]>::iterator		b, e;
	rd_multimap<const char[],test[]>::const_iterator	c, f;

	// [v4.->.v4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ s4, v4 }, { s4, v4 }, { s4, v4 }, { s4, v4 }} ));

	// (v4.<-.v4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.v4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { s1, v1 }, { s1, v1 }, { s2, v2 }, { s2, v2 },
					 { s2, v2 }, { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 },
					 { s4, v4 }, { s4, v4 }, { s4, v4 }} ));

	// [v4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ s4, v4 }, { s4, v4 }, { s4, v4 }, { s5, v5 }, { s5, v5 },
					 { s8, v8 }} ));

	// [.->.v4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { s1, v1 }, { s1, v1 }, { s2, v2 }, { s2, v2 },
					 { s2, v2 }, { s3, v3 }, { s3, v3 }, { s3, v3 }} ));

	// (v4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ s4, v4 }, { s4, v4 }, { s4, v4 }, { s5, v5 }, { s5, v5 },
					 { s8, v8 }} ));

	// [v4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ s4, v4 }, { s4, v4 }, { s4, v4 }, { s4, v4 }, { s5, v5 },
					 { s5, v5 }, { s8, v8 }} ));

	// (.<-.v4]
	b = pm.upper_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ s1, v1 }, { s1, v1 }, { s2, v2 }, { s2, v2 }, { s2, v2 },
					 { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 }, { s4, v4 },
					 { s4, v4 }, { s4, v4 }, { s5, v5 }} ));

	// (v4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ s5, v5 }, { s5, v5 }, { s8, v8 }} ));

	// (.<-.v4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ s1, v1 }, { s1, v1 }, { s2, v2 }, { s2, v2 }, { s2, v2 },
					 { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 }} ));

	// equal range
	auto r = pm.equal_range( s3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ s3, v3 }, { s3, v3 }, { s3, v3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test1B()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - reference pointer(f-array) value" );

	rr_multimap<const char[],test[3]>	pm = {{ s1, w1 }, { s2, w2 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s2, w2 },
		      { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 }, { s5, w5 }, { s4, w4 },
		      { s4, w4 }, { s1, w1 }, { s2, w2 }};
	rr_multimap<const char[],test[3]> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ s1, w1 }, { s2, w2 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s2, w2 },
					 { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 }, { s5, w5 }, { s4, w4 },
					 { s4, w4 }, { s1, w1 }, { s2, w2 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertEqual( pm.find( s4 )->second, w4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertEqual( cm.find( s4 )->second, w4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const char[],test[3]>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	rr_multimap<const char[],test[3]>::iterator		b, e;
	rr_multimap<const char[],test[3]>::const_iterator	c, f;

	// [w4.->.w4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ s4, w4 }, { s4, w4 }, { s4, w4 }, { s4, w4 }} ));

	// (w4.<-.w4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.w4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { s1, w1 }, { s1, w1 }, { s2, w2 }, { s2, w2 },
					 { s2, w2 }, { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 },
					 { s4, w4 }, { s4, w4 }, { s4, w4 }} ));

	// [w4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ s4, w4 }, { s4, w4 }, { s4, w4 }, { s5, w5 }, { s5, w5 },
					 { s8, w8 }} ));

	// [.->.w4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { s1, w1 }, { s1, w1 }, { s2, w2 }, { s2, w2 },
					 { s2, w2 }, { s3, w3 }, { s3, w3 }, { s3, w3 }} ));

	// (w4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ s4, w4 }, { s4, w4 }, { s4, w4 }, { s5, w5 }, { s5, w5 },
					 { s8, w8 }} ));

	// [w4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ s4, w4 }, { s4, w4 }, { s4, w4 }, { s4, w4 }, { s5, w5 },
					 { s5, w5 }, { s8, w8 }} ));

	// (.<-.w4]
	b = pm.upper_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ s1, w1 }, { s1, w1 }, { s2, w2 }, { s2, w2 }, { s2, w2 },
					 { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 }, { s4, w4 },
					 { s4, w4 }, { s4, w4 }, { s5, w5 }} ));

	// (w4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ s5, w5 }, { s5, w5 }, { s8, w8 }} ));

	// (.<-.w4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ s1, w1 }, { s1, w1 }, { s2, w2 }, { s2, w2 }, { s2, w2 },
					 { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 }} ));

	// equal range
	auto r = pm.equal_range( s3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ s3, w3 }, { s3, w3 }, { s3, w3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test1C()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - deep pointer(f-array) value" );

	rd_multimap<const char[],test[3]>	pm = {{ s1, w1 }, { s2, w2 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s2, w2 },
		      { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 }, { s5, w5 }, { s4, w4 },
		      { s4, w4 }, { s1, w1 }, { s2, w2 }};
	rd_multimap<const char[],test[3]> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ s1, w1 }, { s2, w2 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s2, w2 },
					 { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 }, { s5, w5 }, { s4, w4 },
					 { s4, w4 }, { s1, w1 }, { s2, w2 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertNotEqual( pm.find( s4 )->second, w4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertNotEqual( cm.find( s4 )->second, w4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const char[],test[3]>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	rd_multimap<const char[],test[3]>::iterator		b, e;
	rd_multimap<const char[],test[3]>::const_iterator	c, f;

	// [w4.->.w4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ s4, w4 }, { s4, w4 }, { s4, w4 }, { s4, w4 }} ));

	// (w4.<-.w4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.w4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { s1, w1 }, { s1, w1 }, { s2, w2 }, { s2, w2 },
					 { s2, w2 }, { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 },
					 { s4, w4 }, { s4, w4 }, { s4, w4 }} ));

	// [w4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ s4, w4 }, { s4, w4 }, { s4, w4 }, { s5, w5 }, { s5, w5 },
					 { s8, w8 }} ));

	// [.->.w4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { s1, w1 }, { s1, w1 }, { s2, w2 }, { s2, w2 },
					 { s2, w2 }, { s3, w3 }, { s3, w3 }, { s3, w3 }} ));

	// (w4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ s4, w4 }, { s4, w4 }, { s4, w4 }, { s5, w5 }, { s5, w5 },
					 { s8, w8 }} ));

	// [w4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ s4, w4 }, { s4, w4 }, { s4, w4 }, { s4, w4 }, { s5, w5 },
					 { s5, w5 }, { s8, w8 }} ));

	// (.<-.w4]
	b = pm.upper_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ s1, w1 }, { s1, w1 }, { s2, w2 }, { s2, w2 }, { s2, w2 },
					 { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 }, { s4, w4 },
					 { s4, w4 }, { s4, w4 }, { s5, w5 }} ));

	// (w4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ s5, w5 }, { s5, w5 }, { s8, w8 }} ));

	// (.<-.w4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ s1, w1 }, { s1, w1 }, { s2, w2 }, { s2, w2 }, { s2, w2 },
					 { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 }} ));

	// equal range
	auto r = pm.equal_range( s3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ s3, w3 }, { s3, w3 }, { s3, w3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test1D()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - data(int value) value" );

	rn_multimap<const char[],int>	pm = {{ s1, 1 }, { s2, 2 }, { s5, 5 }, { s8, 8 }, { s4, 4 }, { s2, 2 },
		      { s3, 3 }, { s3, 3 }, { s3, 3 }, { s4, 4 }, { s5, 5 }, { s4, 4 },
		      { s4, 4 }, { s1, 1 }, { s2, 2 }};
	rn_multimap<const char[],int> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ s1, 1 }, { s2, 2 }, { s5, 5 }, { s8, 8 }, { s4, 4 }, { s2, 2 },
					 { s3, 3 }, { s3, 3 }, { s3, 3 }, { s4, 4 }, { s5, 5 }, { s4, 4 },
					 { s4, 4 }, { s1, 1 }, { s2, 2 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertEqual( pm.find( s4 )->second, 4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertEqual( cm.find( s4 )->second, 4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, 0 );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, 0 );

	rn_multimap<const char[],int>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	rn_multimap<const char[],int>::iterator		b, e;
	rn_multimap<const char[],int>::const_iterator	c, f;

	// [4.->.4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ s4, 4 }, { s4, 4 }, { s4, 4 }, { s4, 4 }} ));

	// (4.<-.4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, 0 }, { s1, 1 }, { s1, 1 }, { s2, 2 }, { s2, 2 },
					 { s2, 2 }, { s3, 3 }, { s3, 3 }, { s3, 3 }, { s4, 4 },
					 { s4, 4 }, { s4, 4 }, { s4, 4 }} ));

	// [4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ s4, 4 }, { s4, 4 }, { s4, 4 }, { s5, 5 }, { s5, 5 },
					 { s8, 8 }} ));

	// [.->.4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, 0 }, { s1, 1 }, { s1, 1 }, { s2, 2 }, { s2, 2 },
					 { s2, 2 }, { s3, 3 }, { s3, 3 }, { s3, 3 }} ));

	// (4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ s4, 4 }, { s4, 4 }, { s4, 4 }, { s5, 5 }, { s5, 5 },
					 { s8, 8 }} ));

	// [4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ s4, 4 }, { s4, 4 }, { s4, 4 }, { s4, 4 }, { s5, 5 },
					 { s5, 5 }, { s8, 8 }} ));

	// (.<-.4]
	b = pm.upper_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ s1, 1 }, { s1, 1 }, { s2, 2 }, { s2, 2 }, { s2, 2 },
					 { s3, 3 }, { s3, 3 }, { s3, 3 }, { s4, 4 }, { s4, 4 },
					 { s4, 4 }, { s4, 4 }, { s5, 5 }} ));

	// (4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ s5, 5 }, { s5, 5 }, { s8, 8 }} ));

	// (.<-.4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ s1, 1 }, { s1, 1 }, { s2, 2 }, { s2, 2 }, { s2, 2 },
					 { s3, 3 }, { s3, 3 }, { s3, 3 }, { s4, 4 }} ));

	// equal range
	auto r = pm.equal_range( s3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ s3, 3 }, { s3, 3 }, { s3, 3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test1E()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - deep pointer(pointer) value" );

	rd_multimap<const char[],test*>	pm = {{ s1, &t1 }, { s2, &t2 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s2, &t2 },
		      { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }, { s4, &t4 },
		      { s4, &t4 }, { s1, &t1 }, { s2, &t2 }};
	rd_multimap<const char[],test*> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ s1, &t1 }, { s2, &t2 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s2, &t2 },
					 { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }, { s4, &t4 },
					 { s4, &t4 }, { s1, &t1 }, { s2, &t2 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertNotEqual( pm.find( s4 )->second, &t4 );
	AssertEqual( *pm.find( s4 )->second, t4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertNotEqual( cm.find( s4 )->second, &t4 );
	AssertEqual( *cm.find( s4 )->second, t4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const char[],test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	rd_multimap<const char[],test*>::iterator		b, e;
	rd_multimap<const char[],test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ s4, &t4 }, { s4, &t4 }, { s4, &t4 }, { s4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { s1, &t1 }, { s1, &t1 }, { s2, &t2 }, { s2, &t2 },
					 { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 },
					 { s4, &t4 }, { s4, &t4 }, { s4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ s4, &t4 }, { s4, &t4 }, { s4, &t4 }, { s5, &t5 }, { s5, &t5 },
					 { s8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { s1, &t1 }, { s1, &t1 }, { s2, &t2 }, { s2, &t2 },
					 { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ s4, &t4 }, { s4, &t4 }, { s4, &t4 }, { s5, &t5 }, { s5, &t5 },
					 { s8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ s4, &t4 }, { s4, &t4 }, { s4, &t4 }, { s4, &t4 }, { s5, &t5 },
					 { s5, &t5 }, { s8, &t8 }} ));

	// (.<-.&t4]
	b = pm.upper_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ s1, &t1 }, { s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s2, &t2 },
					 { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 }, { s4, &t4 },
					 { s4, &t4 }, { s4, &t4 }, { s5, &t5 }} ));

	// (&t4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ s5, &t5 }, { s5, &t5 }, { s8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ s1, &t1 }, { s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s2, &t2 },
					 { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( s3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ s3, &t3 }, { s3, &t3 }, { s3, &t3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test1F()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, deep pointer(c-string) key - deep pointer(pointer) value" );

	dd_multimap<const char[],test*>	pm = {{ s1, &t1 }, { s2, &t2 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s2, &t2 },
		      { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }, { s4, &t4 },
		      { s4, &t4 }, { s1, &t1 }, { s2, &t2 }};
	dd_multimap<const char[],test*> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ s1, &t1 }, { s2, &t2 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s2, &t2 },
					 { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }, { s4, &t4 },
					 { s4, &t4 }, { s1, &t1 }, { s2, &t2 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertNotEqual( pm.find( s4 )->first, s4 );
	AssertTrue( dp_eql<const char[]>()( pm.find( s4 )->first, s4 ));
	AssertNotEqual( pm.find( s4 )->second, &t4 );
	AssertEqual( *pm.find( s4 )->second, t4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertNotEqual( cm.find( s4 )->first, s4 );
	AssertTrue( dp_eql<const char[]>()( cm.find( s4 )->first, s4 ));
	AssertNotEqual( cm.find( s4 )->second, &t4 );
	AssertEqual( *cm.find( s4 )->second, t4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const char[],test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	dd_multimap<const char[],test*>::iterator		b, e;
	dd_multimap<const char[],test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ s4, &t4 }, { s4, &t4 }, { s4, &t4 }, { s4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { s1, &t1 }, { s1, &t1 }, { s2, &t2 }, { s2, &t2 },
					 { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 },
					 { s4, &t4 }, { s4, &t4 }, { s4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ s4, &t4 }, { s4, &t4 }, { s4, &t4 }, { s5, &t5 }, { s5, &t5 },
					 { s8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { s1, &t1 }, { s1, &t1 }, { s2, &t2 }, { s2, &t2 },
					 { s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ s4, &t4 }, { s4, &t4 }, { s4, &t4 }, { s5, &t5 }, { s5, &t5 },
					 { s8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ s4, &t4 }, { s4, &t4 }, { s4, &t4 }, { s4, &t4 }, { s5, &t5 },
					 { s5, &t5 }, { s8, &t8 }} ));

	// (.<-.&t4]
	b = pm.upper_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ s1, &t1 }, { s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s2, &t2 },
					 { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 }, { s4, &t4 },
					 { s4, &t4 }, { s4, &t4 }, { s5, &t5 }} ));

	// (&t4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ s5, &t5 }, { s5, &t5 }, { s8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ s1, &t1 }, { s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s2, &t2 },
					 { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( s3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ s3, &t3 }, { s3, &t3 }, { s3, &t3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test20()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, reference pointer(v-array) key - deep pointer(pointer) value" );

	rd_multimap<test[],test*>	pm = {{ v1, &t1 }, { v2, &t2 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v2, &t2 },
		      { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }, { v4, &t4 },
		      { v4, &t4 }, { v1, &t1 }, { v2, &t2 }};
	rd_multimap<test[],test*> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ v1, &t1 }, { v2, &t2 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v2, &t2 },
					 { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }, { v4, &t4 },
					 { v4, &t4 }, { v1, &t1 }, { v2, &t2 }} ));
	print( cm );

	AssertNotEqual( pm.find( v4 ), pm.end());
	AssertEqual( pm.find( v4 )->first, v4 );
	AssertNotEqual( pm.find( v4 )->second, &t4 );
	AssertEqual( *pm.find( v4 )->second, t4 );
	AssertEqual( pm.find( v7 ), pm.end());

	AssertNotEqual( cm.find( v4 ), cm.end());
	AssertEqual( cm.find( v4 )->first, v4 );
	AssertNotEqual( cm.find( v4 )->second, &t4 );
	AssertEqual( *cm.find( v4 )->second, t4 );
	AssertEqual( cm.find( v7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const test[],test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	rd_multimap<test[],test*>::iterator		b, e;
	rd_multimap<test[],test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( v4 );
	e = pm.upper_bound( v4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ v4, &t4 }, { v4, &t4 }, { v4, &t4 }, { v4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( v4 );
	e = pm.lower_bound( v4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( v4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { v1, &t1 }, { v1, &t1 }, { v2, &t2 }, { v2, &t2 },
					 { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 },
					 { v4, &t4 }, { v4, &t4 }, { v4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( v8 );
	e = pm.lower_bound( v4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ v4, &t4 }, { v4, &t4 }, { v4, &t4 }, { v5, &t5 }, { v5, &t5 },
					 { v8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( v4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { v1, &t1 }, { v1, &t1 }, { v2, &t2 }, { v2, &t2 },
					 { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( v8 );
	f = cm.find( v4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ v4, &t4 }, { v4, &t4 }, { v4, &t4 }, { v5, &t5 }, { v5, &t5 },
					 { v8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( v4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ v4, &t4 }, { v4, &t4 }, { v4, &t4 }, { v4, &t4 }, { v5, &t5 },
					 { v5, &t5 }, { v8, &t8 }} ));

	// (.<-.&t4]
	b = pm.upper_bound( v4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ v1, &t1 }, { v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v2, &t2 },
					 { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 }, { v4, &t4 },
					 { v4, &t4 }, { v4, &t4 }, { v5, &t5 }} ));

	// (&t4.->.)
	c = cm.upper_bound( v4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ v5, &t5 }, { v5, &t5 }, { v8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( v4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ v1, &t1 }, { v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v2, &t2 },
					 { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( v3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ v3, &t3 }, { v3, &t3 }, { v3, &t3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( v8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test21()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, deep pointer(v-array) key - deep pointer(pointer) value" );

	dd_multimap<test[],test*>	pm = {{ v1, &t1 }, { v2, &t2 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v2, &t2 },
		      { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }, { v4, &t4 },
		      { v4, &t4 }, { v1, &t1 }, { v2, &t2 }};
	dd_multimap<test[],test*> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ v1, &t1 }, { v2, &t2 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v2, &t2 },
					 { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }, { v4, &t4 },
					 { v4, &t4 }, { v1, &t1 }, { v2, &t2 }} ));
	print( cm );

	AssertNotEqual( pm.find( v4 ), pm.end());
	AssertNotEqual( pm.find( v4 )->first, v4 );
	AssertTrue( dp_eql<const test[]>()( pm.find( v4 )->first, v4 ));
	AssertNotEqual( pm.find( v4 )->second, &t4 );
	AssertEqual( *pm.find( v4 )->second, t4 );
	AssertEqual( pm.find( v7 ), pm.end());

	AssertNotEqual( cm.find( v4 ), cm.end());
	AssertNotEqual( cm.find( v4 )->first, v4 );
	AssertTrue( dp_eql<const test[]>()( cm.find( v4 )->first, v4 ));
	AssertNotEqual( cm.find( v4 )->second, &t4 );
	AssertEqual( *cm.find( v4 )->second, t4 );
	AssertEqual( cm.find( v7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const test[],test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	dd_multimap<test[],test*>::iterator		b, e;
	dd_multimap<test[],test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( v4 );
	e = pm.upper_bound( v4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ v4, &t4 }, { v4, &t4 }, { v4, &t4 }, { v4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( v4 );
	e = pm.lower_bound( v4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( v4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { v1, &t1 }, { v1, &t1 }, { v2, &t2 }, { v2, &t2 },
					 { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 },
					 { v4, &t4 }, { v4, &t4 }, { v4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( v8 );
	e = pm.lower_bound( v4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ v4, &t4 }, { v4, &t4 }, { v4, &t4 }, { v5, &t5 }, { v5, &t5 },
					 { v8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( v4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { v1, &t1 }, { v1, &t1 }, { v2, &t2 }, { v2, &t2 },
					 { v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( v8 );
	f = cm.find( v4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ v4, &t4 }, { v4, &t4 }, { v4, &t4 }, { v5, &t5 }, { v5, &t5 },
					 { v8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( v4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ v4, &t4 }, { v4, &t4 }, { v4, &t4 }, { v4, &t4 }, { v5, &t5 },
					 { v5, &t5 }, { v8, &t8 }} ));

	// (.<-.&t4]
	b = pm.upper_bound( v4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ v1, &t1 }, { v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v2, &t2 },
					 { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 }, { v4, &t4 },
					 { v4, &t4 }, { v4, &t4 }, { v5, &t5 }} ));

	// (&t4.->.)
	c = cm.upper_bound( v4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ v5, &t5 }, { v5, &t5 }, { v8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( v4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ v1, &t1 }, { v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v2, &t2 },
					 { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( v3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ v3, &t3 }, { v3, &t3 }, { v3, &t3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( v8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test22()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, reference pointer(f-array) key - deep pointer(pointer) value" );

	rd_multimap<test[3],test*>	pm = {{ w1, &t1 }, { w2, &t2 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w2, &t2 },
		      { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }, { w4, &t4 },
		      { w4, &t4 }, { w1, &t1 }, { w2, &t2 }};
	rd_multimap<test[3],test*> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ w1, &t1 }, { w2, &t2 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w2, &t2 },
					 { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }, { w4, &t4 },
					 { w4, &t4 }, { w1, &t1 }, { w2, &t2 }} ));
	print( cm );

	AssertNotEqual( pm.find( w4 ), pm.end());
	AssertEqual( pm.find( w4 )->first, w4 );
	AssertNotEqual( pm.find( w4 )->second, &t4 );
	AssertEqual( *pm.find( w4 )->second, t4 );
	AssertEqual( pm.find( w7 ), pm.end());

	AssertNotEqual( cm.find( w4 ), cm.end());
	AssertEqual( cm.find( w4 )->first, w4 );
	AssertNotEqual( cm.find( w4 )->second, &t4 );
	AssertEqual( *cm.find( w4 )->second, t4 );
	AssertEqual( cm.find( w7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const test[3],test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	rd_multimap<test[3],test*>::iterator		b, e;
	rd_multimap<test[3],test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( w4 );
	e = pm.upper_bound( w4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ w4, &t4 }, { w4, &t4 }, { w4, &t4 }, { w4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( w4 );
	e = pm.lower_bound( w4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( w4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { w1, &t1 }, { w1, &t1 }, { w2, &t2 }, { w2, &t2 },
					 { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 },
					 { w4, &t4 }, { w4, &t4 }, { w4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( w8 );
	e = pm.lower_bound( w4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ w4, &t4 }, { w4, &t4 }, { w4, &t4 }, { w5, &t5 }, { w5, &t5 },
					 { w8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( w4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { w1, &t1 }, { w1, &t1 }, { w2, &t2 }, { w2, &t2 },
					 { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( w8 );
	f = cm.find( w4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ w4, &t4 }, { w4, &t4 }, { w4, &t4 }, { w5, &t5 }, { w5, &t5 },
					 { w8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( w4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ w4, &t4 }, { w4, &t4 }, { w4, &t4 }, { w4, &t4 }, { w5, &t5 },
					 { w5, &t5 }, { w8, &t8 }} ));

	// (.<-.&t4]
	b = pm.upper_bound( w4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ w1, &t1 }, { w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w2, &t2 },
					 { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 }, { w4, &t4 },
					 { w4, &t4 }, { w4, &t4 }, { w5, &t5 }} ));

	// (&t4.->.)
	c = cm.upper_bound( w4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ w5, &t5 }, { w5, &t5 }, { w8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( w4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ w1, &t1 }, { w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w2, &t2 },
					 { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( w3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ w3, &t3 }, { w3, &t3 }, { w3, &t3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( w8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test23()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, deep pointer(f-array) key - deep pointer(pointer) value" );

	dd_multimap<test[3],test*>	pm = {{ w1, &t1 }, { w2, &t2 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w2, &t2 },
		      { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }, { w4, &t4 },
		      { w4, &t4 }, { w1, &t1 }, { w2, &t2 }};
	dd_multimap<test[3],test*> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ w1, &t1 }, { w2, &t2 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w2, &t2 },
					 { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }, { w4, &t4 },
					 { w4, &t4 }, { w1, &t1 }, { w2, &t2 }} ));
	print( cm );

	AssertNotEqual( pm.find( w4 ), pm.end());
	AssertNotEqual( pm.find( w4 )->first, w4 );
	AssertTrue( dp_eql<const test[3]>()( pm.find( w4 )->first, w4 ));
	AssertNotEqual( pm.find( w4 )->second, &t4 );
	AssertEqual( *pm.find( w4 )->second, t4 );
	AssertEqual( pm.find( w7 ), pm.end());

	AssertNotEqual( cm.find( w4 ), cm.end());
	AssertNotEqual( cm.find( w4 )->first, w4 );
	AssertTrue( dp_eql<const test[3]>()( cm.find( w4 )->first, w4 ));
	AssertNotEqual( cm.find( w4 )->second, &t4 );
	AssertEqual( *cm.find( w4 )->second, t4 );
	AssertEqual( cm.find( w7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	rr_multimap<const test[3],test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	dd_multimap<test[3],test*>::iterator		b, e;
	dd_multimap<test[3],test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( w4 );
	e = pm.upper_bound( w4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ w4, &t4 }, { w4, &t4 }, { w4, &t4 }, { w4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( w4 );
	e = pm.lower_bound( w4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( w4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ nullptr, nullptr }, { w1, &t1 }, { w1, &t1 }, { w2, &t2 }, { w2, &t2 },
					 { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 },
					 { w4, &t4 }, { w4, &t4 }, { w4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( w8 );
	e = pm.lower_bound( w4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ w4, &t4 }, { w4, &t4 }, { w4, &t4 }, { w5, &t5 }, { w5, &t5 },
					 { w8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( w4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ nullptr, nullptr }, { w1, &t1 }, { w1, &t1 }, { w2, &t2 }, { w2, &t2 },
					 { w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( w8 );
	f = cm.find( w4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ w4, &t4 }, { w4, &t4 }, { w4, &t4 }, { w5, &t5 }, { w5, &t5 },
					 { w8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( w4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ w4, &t4 }, { w4, &t4 }, { w4, &t4 }, { w4, &t4 }, { w5, &t5 },
					 { w5, &t5 }, { w8, &t8 }} ));

	// (.<-.&t4]
	b = pm.upper_bound( w4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ w1, &t1 }, { w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w2, &t2 },
					 { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 }, { w4, &t4 },
					 { w4, &t4 }, { w4, &t4 }, { w5, &t5 }} ));

	// (&t4.->.)
	c = cm.upper_bound( w4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ w5, &t5 }, { w5, &t5 }, { w8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( w4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ w1, &t1 }, { w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w2, &t2 },
					 { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( w3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ w3, &t3 }, { w3, &t3 }, { w3, &t3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( w8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test24()
{
	this->set_subtitle( "find/lower_bound/upper_bound/equal_range, data(int value) key - deep pointer(pointer) value" );

	nd_multimap<int,test*>	pm = {{ 1, &t1 }, { 2, &t2 }, { 5, &t5 }, { 8, &t8 }, { 4, &t4 }, { 2, &t2 },
		      { 3, &t3 }, { 3, &t3 }, { 3, &t3 }, { 4, &t4 }, { 5, &t5 }, { 4, &t4 },
		      { 4, &t4 }, { 1, &t1 }, { 2, &t2 }};
	nd_multimap<int,test*> const& cm = pm;

	AssertTrue( check_multimap( pm, {{ 1, &t1 }, { 2, &t2 }, { 5, &t5 }, { 8, &t8 }, { 4, &t4 }, { 2, &t2 },
					 { 3, &t3 }, { 3, &t3 }, { 3, &t3 }, { 4, &t4 }, { 5, &t5 }, { 4, &t4 },
					 { 4, &t4 }, { 1, &t1 }, { 2, &t2 }} ));
	print( cm );

	AssertNotEqual( pm.find( 4 ), pm.end());
	AssertEqual( pm.find( 4 )->first, 4 );
	AssertNotEqual( pm.find( 4 )->second, &t4 );
	AssertEqual( *pm.find( 4 )->second, t4 );
	AssertEqual( pm.find( 7 ), pm.end());

	AssertNotEqual( cm.find( 4 ), cm.end());
	AssertEqual( cm.find( 4 )->first, 4 );
	AssertNotEqual( cm.find( 4 )->second, &t4 );
	AssertEqual( *cm.find( 4 )->second, t4 );
	AssertEqual( cm.find( 7 ), cm.end());

	// null key
	AssertEqual( pm.find( 0 ), pm.end());
	AssertEqual( cm.find( 0 ), cm.end());
	pm.emplace( 0, nullptr );
	AssertNotEqual( pm.find( 0 ), pm.end());
	AssertEqual( pm.find( 0 )->first, 0 );
	AssertEqual( pm.find( 0 )->second, nullptr );

	nr_multimap<int,test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	nd_multimap<int,test*>::iterator		b, e;
	nd_multimap<int,test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( 4 );
	e = pm.upper_bound( 4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_multimap( l1, {{ 4, &t4 }, { 4, &t4 }, { 4, &t4 }, { 4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( 4 );
	e = pm.lower_bound( 4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_multimap( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( 4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_multimap( l2, {{ 0, nullptr }, { 1, &t1 }, { 1, &t1 }, { 2, &t2 }, { 2, &t2 },
					 { 2, &t2 }, { 3, &t3 }, { 3, &t3 }, { 3, &t3 }, { 4, &t4 },
					 { 4, &t4 }, { 4, &t4 }, { 4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( 8 );
	e = pm.lower_bound( 4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_multimap( r2, {{ 4, &t4 }, { 4, &t4 }, { 4, &t4 }, { 5, &t5 }, { 5, &t5 },
					 { 8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( 4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_multimap( l3, {{ 0, nullptr }, { 1, &t1 }, { 1, &t1 }, { 2, &t2 }, { 2, &t2 },
					 { 2, &t2 }, { 3, &t3 }, { 3, &t3 }, { 3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( 8 );
	f = cm.find( 4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_multimap( r3, {{ 4, &t4 }, { 4, &t4 }, { 4, &t4 }, { 5, &t5 }, { 5, &t5 },
					 { 8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( 4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_multimap( l4, {{ 4, &t4 }, { 4, &t4 }, { 4, &t4 }, { 4, &t4 }, { 5, &t5 },
					 { 5, &t5 }, { 8, &t8 }} ));

	// (.<-.&t4]
	b = pm.upper_bound( 4 );
	e = pm.find( 0 );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_multimap( r4, {{ 1, &t1 }, { 1, &t1 }, { 2, &t2 }, { 2, &t2 }, { 2, &t2 },
					 { 3, &t3 }, { 3, &t3 }, { 3, &t3 }, { 4, &t4 }, { 4, &t4 },
					 { 4, &t4 }, { 4, &t4 }, { 5, &t5 }} ));

	// (&t4.->.)
	c = cm.upper_bound( 4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_multimap( l5, {{ 5, &t5 }, { 5, &t5 }, { 8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( 4 );
	e = pm.find( 0 );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_multimap( r5, {{ 1, &t1 }, { 1, &t1 }, { 2, &t2 }, { 2, &t2 }, { 2, &t2 },
					 { 3, &t3 }, { 3, &t3 }, { 3, &t3 }, { 4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( 3 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_multimap( er, {{ 3, &t3 }, { 3, &t3 }, { 3, &t3 }} ));

	// boundary
	AssertEqual( pm.lower_bound( 0 ), pm.find( 0 ));
	AssertEqual( pm.upper_bound( 8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test25()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(pointer) key - reference pointer(pointer) value" );

	typedef typename rr_multimap<test*,test*>::iterator	iterator;
	typedef typename rr_multimap<test*,test*>::const_iterator	const_iterator;
	typedef	typename rr_multimap<test*,test*>::value_type	pair;

	rr_multimap<const test*,test*>	m1 = {{ &t1, &t1 }, { &t2, &t2 }};
	rr_multimap<const test*,test*>	m2;
	rr_multimap<const test*,test*>	m3 = {{ &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }};

	// emplace
	{
		rr_multimap<test*,test*>		pm;
		rr_multimap<test*,test*>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// insert
	{
		rr_multimap<test*,test*>		pm;
		rr_multimap<test*,test*>		pi;
		rr_multimap<test*,test*>		il;
		rr_multimap<test*,test*>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ &t1, &t1 }, { &t2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ &t2, &t2 }, { &t3, &t3 }, { &t3, &t4 }, { &t3, &t5 }, { &t5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( il, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t4 }, { &t3, &t5 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( it, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// erase
	{
		rr_multimap<test*,test*>	p {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr } };
		rr_multimap<test*,test*>	p1( p );

		AssertEqual( p1.erase( &t4 ), 1 );
		AssertTrue( check_multimap( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( &t7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( &t1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( &t8 ), 1 );
		AssertTrue( check_multimap( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t3, &t3 }} ));

		rr_multimap<test*,test*>	q1( p );
		rr_multimap<test*,test*>	q2( p );
		rr_multimap<test*,test*>	q3( p );
		rr_multimap<test*,test*>	q4( p );

		q1.erase( q1.find( &t4 ), q1.upper_bound( &t4 ));
		AssertTrue( check_multimap( q1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( &t4 ));
		AssertTrue( check_multimap( q2, {{ &t5, &t5 }, { &t8, &t8 }} ));
		q3.erase( q3.find( &t4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ &t1, &t1 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( &t4 ), q4.find( &t4 ));
		AssertTrue( check_multimap( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test26()
{
	this->set_subtitle( "emplace/insert/erase, deep pointer(pointer) key - reference pointer(pointer) value" );

	typedef typename dr_multimap<test*,test*>::iterator	iterator;
	typedef typename dr_multimap<test*,test*>::const_iterator	const_iterator;
	typedef	typename dr_multimap<test*,test*>::value_type	pair;

	rr_multimap<const test*,test*>	m1 = {{ &t1, &t1 }, { &t2, &t2 }};
	rr_multimap<const test*,test*>	m2;
	rr_multimap<const test*,test*>	m3 = {{ &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }};

	// emplace
	{
		dr_multimap<test*,test*>		pm;
		dr_multimap<test*,test*>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// insert
	{
		dr_multimap<test*,test*>		pm;
		dr_multimap<test*,test*>		pi;
		dr_multimap<test*,test*>		il;
		dr_multimap<test*,test*>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ &t1, &t1 }, { &t2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ &t2, &t2 }, { &t3, &t3 }, { &t3, &t4 }, { &t3, &t5 }, { &t5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( il, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t4 }, { &t3, &t5 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( it, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// erase
	{
		dr_multimap<test*,test*>	p {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr } };
		dr_multimap<test*,test*>	p1( p );

		AssertEqual( p1.erase( &t4 ), 1 );
		AssertTrue( check_multimap( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( &t7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( &t1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( &t8 ), 1 );
		AssertTrue( check_multimap( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t3, &t3 }} ));

		dr_multimap<test*,test*>	q1( p );
		dr_multimap<test*,test*>	q2( p );
		dr_multimap<test*,test*>	q3( p );
		dr_multimap<test*,test*>	q4( p );

		q1.erase( q1.find( &t4 ), q1.upper_bound( &t4 ));
		AssertTrue( check_multimap( q1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( &t4 ));
		AssertTrue( check_multimap( q2, {{ &t5, &t5 }, { &t8, &t8 }} ));
		q3.erase( q3.find( &t4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ &t1, &t1 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( &t4 ), q4.find( &t4 ));
		AssertTrue( check_multimap( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test27()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(pointer) key - deep pointer(pointer) value" );

	typedef typename rd_multimap<test*,test*>::iterator	iterator;
	typedef typename rd_multimap<test*,test*>::const_iterator	const_iterator;
	typedef	typename rd_multimap<test*,test*>::value_type	pair;

	rr_multimap<const test*,test*>	m1 = {{ &t1, &t1 }, { &t2, &t2 }};
	rr_multimap<const test*,test*>	m2;
	rr_multimap<const test*,test*>	m3 = {{ &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }};

	// emplace
	{
		rd_multimap<test*,test*>		pm;
		rd_multimap<test*,test*>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// insert
	{
		rd_multimap<test*,test*>		pm;
		rd_multimap<test*,test*>		pi;
		rd_multimap<test*,test*>		il;
		rd_multimap<test*,test*>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ &t1, &t1 }, { &t2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ &t2, &t2 }, { &t3, &t3 }, { &t3, &t4 }, { &t3, &t5 }, { &t5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( il, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t4 }, { &t3, &t5 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( it, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// erase
	{
		rd_multimap<test*,test*>	p {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr } };
		rd_multimap<test*,test*>	p1( p );

		AssertEqual( p1.erase( &t4 ), 1 );
		AssertTrue( check_multimap( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( &t7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( &t1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( &t8 ), 1 );
		AssertTrue( check_multimap( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t3, &t3 }} ));

		rd_multimap<test*,test*>	q1( p );
		rd_multimap<test*,test*>	q2( p );
		rd_multimap<test*,test*>	q3( p );
		rd_multimap<test*,test*>	q4( p );

		q1.erase( q1.find( &t4 ), q1.upper_bound( &t4 ));
		AssertTrue( check_multimap( q1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( &t4 ));
		AssertTrue( check_multimap( q2, {{ &t5, &t5 }, { &t8, &t8 }} ));
		q3.erase( q3.find( &t4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ &t1, &t1 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( &t4 ), q4.find( &t4 ));
		AssertTrue( check_multimap( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test28()
{
	this->set_subtitle( "emplace/insert/erase, deep pointer(pointer) key - deep pointer(pointer) value" );

	typedef typename dd_multimap<test*,test*>::iterator	iterator;
	typedef typename dd_multimap<test*,test*>::const_iterator	const_iterator;
	typedef	typename dd_multimap<test*,test*>::value_type	pair;

	rr_multimap<const test*,test*>	m1 = {{ &t1, &t1 }, { &t2, &t2 }};
	rr_multimap<const test*,test*>	m2;
	rr_multimap<const test*,test*>	m3 = {{ &t2, &t2 }, { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }};

	// emplace
	{
		dd_multimap<test*,test*>		pm;
		dd_multimap<test*,test*>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// insert
	{
		dd_multimap<test*,test*>		pm;
		dd_multimap<test*,test*>		pi;
		dd_multimap<test*,test*>		il;
		dd_multimap<test*,test*>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ &t1, &t1 }, { &t2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ &t2, &t2 }, { &t3, &t3 }, { &t3, &t4 }, { &t3, &t5 }, { &t5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( il, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t4 }, { &t3, &t5 }, { &t5, &t5 }} ));
		AssertTrue( check_multimap( it, {{ &t1, &t1 }, { &t2, &t2 }, { &t2, &t2 }, { &t3, &t3 },
						 { &t3, &t3 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// erase
	{
		dd_multimap<test*,test*>	p {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr } };
		dd_multimap<test*,test*>	p1( p );

		AssertEqual( p1.erase( &t4 ), 1 );
		AssertTrue( check_multimap( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( &t7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( &t1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( &t8 ), 1 );
		AssertTrue( check_multimap( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t3, &t3 }} ));

		dd_multimap<test*,test*>	q1( p );
		dd_multimap<test*,test*>	q2( p );
		dd_multimap<test*,test*>	q3( p );
		dd_multimap<test*,test*>	q4( p );

		q1.erase( q1.find( &t4 ), q1.upper_bound( &t4 ));
		AssertTrue( check_multimap( q1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( &t4 ));
		AssertTrue( check_multimap( q2, {{ &t5, &t5 }, { &t8, &t8 }} ));
		q3.erase( q3.find( &t4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ &t1, &t1 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( &t4 ), q4.find( &t4 ));
		AssertTrue( check_multimap( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test29()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - reference pointer(c-string) value" );

	typedef typename rr_multimap<const char[],const char[]>::iterator	iterator;
	typedef typename rr_multimap<const char[],const char[]>::const_iterator	const_iterator;
	typedef	typename rr_multimap<const char[],const char[]>::value_type	pair;

	rr_multimap<const char[],const char[]>	m1 = {{ s1, s1 }, { s2, s2 }};
	rr_multimap<const char[],const char[]>	m2;
	rr_multimap<const char[],const char[]>	m3 = {{ s2, s2 }, { s3, s3 }, { s3, s3 }, { s3, s3 }, { s5, s5 }};

	// emplace
	{
		rr_multimap<const char[],const char[]>		pm;
		rr_multimap<const char[],const char[]>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, s1 }, { s2, s2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ s1, s1 }, { s2, s2 }, { s2, s2 }, { s3, s3 },
						 { s3, s3 }, { s3, s3 }, { s5, s5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, s1 }, { s2, s2 }, { s2, s2 }, { s3, s3 },
						 { s3, s3 }, { s3, s3 }, { s5, s5 }} ));
	}

	// insert
	{
		rr_multimap<const char[],const char[]>		pm;
		rr_multimap<const char[],const char[]>		pi;
		rr_multimap<const char[],const char[]>		il;
		rr_multimap<const char[],const char[]>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, s1 }, { s2, s2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_multimap( il, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_multimap( it, {{ s1, s1 }, { s2, s2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_multimap( il, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_multimap( it, {{ s1, s1 }, { s2, s2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s2, s2 }, { s3, s3 }, { s3, s4 }, { s3, s5 }, { s5, s5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ s1, s1 }, { s2, s2 }, { s2, s2 }, { s3, s3 },
						 { s3, s3 }, { s3, s3 }, { s5, s5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, s1 }, { s2, s2 }, { s2, s2 }, { s3, s3 },
						 { s3, s3 }, { s3, s3 }, { s5, s5 }} ));
		AssertTrue( check_multimap( il, {{ s1, s1 }, { s2, s2 }, { s2, s2 }, { s3, s3 },
						 { s3, s4 }, { s3, s5 }, { s5, s5 }} ));
		AssertTrue( check_multimap( it, {{ s1, s1 }, { s2, s2 }, { s2, s2 }, { s3, s3 },
						 { s3, s3 }, { s3, s3 }, { s5, s5 }} ));
	}

	// erase
	{
		rr_multimap<const char[],const char[]>	p {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr } };
		rr_multimap<const char[],const char[]>	p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s3, s3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, s1 }, { s5, s5 }, { s3, s3 }} ));

		rr_multimap<const char[],const char[]>	q1( p );
		rr_multimap<const char[],const char[]>	q2( p );
		rr_multimap<const char[],const char[]>	q3( p );
		rr_multimap<const char[],const char[]>	q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_multimap( q1, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s3, s3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_multimap( q2, {{ s5, s5 }, { s8, s8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ s1, s1 }, { s3, s3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_multimap( q4, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test2A()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - deep pointer(c-string) value" );

	typedef typename rd_multimap<const char[],const char[]>::iterator	iterator;
	typedef typename rd_multimap<const char[],const char[]>::const_iterator	const_iterator;
	typedef	typename rd_multimap<const char[],const char[]>::value_type	pair;

	rr_multimap<const char[],const char[]>	m1 = {{ s1, s1 }, { s2, s2 }};
	rr_multimap<const char[],const char[]>	m2;
	rr_multimap<const char[],const char[]>	m3 = {{ s2, s2 }, { s3, s3 }, { s3, s3 }, { s3, s3 }, { s5, s5 }};

	// emplace
	{
		rd_multimap<const char[],const char[]>		pm;
		rd_multimap<const char[],const char[]>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, s1 }, { s2, s2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ s1, s1 }, { s2, s2 }, { s2, s2 }, { s3, s3 },
						 { s3, s3 }, { s3, s3 }, { s5, s5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, s1 }, { s2, s2 }, { s2, s2 }, { s3, s3 },
						 { s3, s3 }, { s3, s3 }, { s5, s5 }} ));
	}

	// insert
	{
		rd_multimap<const char[],const char[]>		pm;
		rd_multimap<const char[],const char[]>		pi;
		rd_multimap<const char[],const char[]>		il;
		rd_multimap<const char[],const char[]>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, s1 }, { s2, s2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_multimap( il, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_multimap( it, {{ s1, s1 }, { s2, s2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_multimap( il, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_multimap( it, {{ s1, s1 }, { s2, s2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s2, s2 }, { s3, s3 }, { s3, s4 }, { s3, s5 }, { s5, s5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ s1, s1 }, { s2, s2 }, { s2, s2 }, { s3, s3 },
						 { s3, s3 }, { s3, s3 }, { s5, s5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, s1 }, { s2, s2 }, { s2, s2 }, { s3, s3 },
						 { s3, s3 }, { s3, s3 }, { s5, s5 }} ));
		AssertTrue( check_multimap( il, {{ s1, s1 }, { s2, s2 }, { s2, s2 }, { s3, s3 },
						 { s3, s4 }, { s3, s5 }, { s5, s5 }} ));
		AssertTrue( check_multimap( it, {{ s1, s1 }, { s2, s2 }, { s2, s2 }, { s3, s3 },
						 { s3, s3 }, { s3, s3 }, { s5, s5 }} ));
	}

	// erase
	{
		rd_multimap<const char[],const char[]>	p {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr } };
		rd_multimap<const char[],const char[]>	p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s3, s3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, s1 }, { s5, s5 }, { s3, s3 }} ));

		rd_multimap<const char[],const char[]>	q1( p );
		rd_multimap<const char[],const char[]>	q2( p );
		rd_multimap<const char[],const char[]>	q3( p );
		rd_multimap<const char[],const char[]>	q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_multimap( q1, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s3, s3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_multimap( q2, {{ s5, s5 }, { s8, s8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ s1, s1 }, { s3, s3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_multimap( q4, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test2B()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - reference pointer(v-array) value" );

	typedef typename rr_multimap<const char[],test[]>::iterator	iterator;
	typedef typename rr_multimap<const char[],test[]>::const_iterator	const_iterator;
	typedef	typename rr_multimap<const char[],test[]>::value_type	pair;

	rr_multimap<const char[],test[]>	m1 = {{ s1, v1 }, { s2, v2 }};
	rr_multimap<const char[],test[]>	m2;
	rr_multimap<const char[],test[]>	m3 = {{ s2, v2 }, { s3, v3 }, { s3, v3 }, { s3, v3 }, { s5, v5 }};

	// emplace
	{
		rr_multimap<const char[],test[]>		pm;
		rr_multimap<const char[],test[]>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, v1 }, { s2, v2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ s1, v1 }, { s2, v2 }, { s2, v2 }, { s3, v3 },
						 { s3, v3 }, { s3, v3 }, { s5, v5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, v1 }, { s2, v2 }, { s2, v2 }, { s3, v3 },
						 { s3, v3 }, { s3, v3 }, { s5, v5 }} ));
	}

	// insert
	{
		rr_multimap<const char[],test[]>		pm;
		rr_multimap<const char[],test[]>		pi;
		rr_multimap<const char[],test[]>		il;
		rr_multimap<const char[],test[]>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, v1 }, { s2, v2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_multimap( il, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_multimap( it, {{ s1, v1 }, { s2, v2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_multimap( il, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_multimap( it, {{ s1, v1 }, { s2, v2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s2, v2 }, { s3, v3 }, { s3, v4 }, { s3, v5 }, { s5, v5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ s1, v1 }, { s2, v2 }, { s2, v2 }, { s3, v3 },
						 { s3, v3 }, { s3, v3 }, { s5, v5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, v1 }, { s2, v2 }, { s2, v2 }, { s3, v3 },
						 { s3, v3 }, { s3, v3 }, { s5, v5 }} ));
		AssertTrue( check_multimap( il, {{ s1, v1 }, { s2, v2 }, { s2, v2 }, { s3, v3 },
						 { s3, v4 }, { s3, v5 }, { s5, v5 }} ));
		AssertTrue( check_multimap( it, {{ s1, v1 }, { s2, v2 }, { s2, v2 }, { s3, v3 },
						 { s3, v3 }, { s3, v3 }, { s5, v5 }} ));
	}

	// erase
	{
		rr_multimap<const char[],test[]>	p {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr } };
		rr_multimap<const char[],test[]>	p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s3, v3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, v1 }, { s5, v5 }, { s3, v3 }} ));

		rr_multimap<const char[],test[]>	q1( p );
		rr_multimap<const char[],test[]>	q2( p );
		rr_multimap<const char[],test[]>	q3( p );
		rr_multimap<const char[],test[]>	q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_multimap( q1, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s3, v3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_multimap( q2, {{ s5, v5 }, { s8, v8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ s1, v1 }, { s3, v3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_multimap( q4, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test2C()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - deep pointer(v-array) value" );

	typedef typename rd_multimap<const char[],test[]>::iterator	iterator;
	typedef typename rd_multimap<const char[],test[]>::const_iterator	const_iterator;
	typedef	typename rd_multimap<const char[],test[]>::value_type	pair;

	rr_multimap<const char[],test[]>	m1 = {{ s1, v1 }, { s2, v2 }};
	rr_multimap<const char[],test[]>	m2;
	rr_multimap<const char[],test[]>	m3 = {{ s2, v2 }, { s3, v3 }, { s3, v3 }, { s3, v3 }, { s5, v5 }};

	// emplace
	{
		rd_multimap<const char[],test[]>		pm;
		rd_multimap<const char[],test[]>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, v1 }, { s2, v2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ s1, v1 }, { s2, v2 }, { s2, v2 }, { s3, v3 },
						 { s3, v3 }, { s3, v3 }, { s5, v5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, v1 }, { s2, v2 }, { s2, v2 }, { s3, v3 },
						 { s3, v3 }, { s3, v3 }, { s5, v5 }} ));
	}

	// insert
	{
		rd_multimap<const char[],test[]>		pm;
		rd_multimap<const char[],test[]>		pi;
		rd_multimap<const char[],test[]>		il;
		rd_multimap<const char[],test[]>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, v1 }, { s2, v2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_multimap( il, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_multimap( it, {{ s1, v1 }, { s2, v2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_multimap( il, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_multimap( it, {{ s1, v1 }, { s2, v2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s2, v2 }, { s3, v3 }, { s3, v4 }, { s3, v5 }, { s5, v5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ s1, v1 }, { s2, v2 }, { s2, v2 }, { s3, v3 },
						 { s3, v3 }, { s3, v3 }, { s5, v5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, v1 }, { s2, v2 }, { s2, v2 }, { s3, v3 },
						 { s3, v3 }, { s3, v3 }, { s5, v5 }} ));
		AssertTrue( check_multimap( il, {{ s1, v1 }, { s2, v2 }, { s2, v2 }, { s3, v3 },
						 { s3, v4 }, { s3, v5 }, { s5, v5 }} ));
		AssertTrue( check_multimap( it, {{ s1, v1 }, { s2, v2 }, { s2, v2 }, { s3, v3 },
						 { s3, v3 }, { s3, v3 }, { s5, v5 }} ));
	}

	// erase
	{
		rd_multimap<const char[],test[]>	p {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr } };
		rd_multimap<const char[],test[]>	p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s3, v3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, v1 }, { s5, v5 }, { s3, v3 }} ));

		rd_multimap<const char[],test[]>	q1( p );
		rd_multimap<const char[],test[]>	q2( p );
		rd_multimap<const char[],test[]>	q3( p );
		rd_multimap<const char[],test[]>	q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_multimap( q1, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s3, v3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_multimap( q2, {{ s5, v5 }, { s8, v8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ s1, v1 }, { s3, v3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_multimap( q4, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test2D()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - reference pointer(f-array) value" );

	typedef typename rr_multimap<const char[],test[3]>::iterator	iterator;
	typedef typename rr_multimap<const char[],test[3]>::const_iterator	const_iterator;
	typedef	typename rr_multimap<const char[],test[3]>::value_type	pair;

	rr_multimap<const char[],test[3]>	m1 = {{ s1, w1 }, { s2, w2 }};
	rr_multimap<const char[],test[3]>	m2;
	rr_multimap<const char[],test[3]>	m3 = {{ s2, w2 }, { s3, w3 }, { s3, w3 }, { s3, w3 }, { s5, w5 }};

	// emplace
	{
		rr_multimap<const char[],test[3]>		pm;
		rr_multimap<const char[],test[3]>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, w1 }, { s2, w2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ s1, w1 }, { s2, w2 }, { s2, w2 }, { s3, w3 },
						 { s3, w3 }, { s3, w3 }, { s5, w5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, w1 }, { s2, w2 }, { s2, w2 }, { s3, w3 },
						 { s3, w3 }, { s3, w3 }, { s5, w5 }} ));
	}

	// insert
	{
		rr_multimap<const char[],test[3]>		pm;
		rr_multimap<const char[],test[3]>		pi;
		rr_multimap<const char[],test[3]>		il;
		rr_multimap<const char[],test[3]>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, w1 }, { s2, w2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_multimap( il, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_multimap( it, {{ s1, w1 }, { s2, w2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_multimap( il, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_multimap( it, {{ s1, w1 }, { s2, w2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s2, w2 }, { s3, w3 }, { s3, w4 }, { s3, w5 }, { s5, w5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ s1, w1 }, { s2, w2 }, { s2, w2 }, { s3, w3 },
						 { s3, w3 }, { s3, w3 }, { s5, w5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, w1 }, { s2, w2 }, { s2, w2 }, { s3, w3 },
						 { s3, w3 }, { s3, w3 }, { s5, w5 }} ));
		AssertTrue( check_multimap( il, {{ s1, w1 }, { s2, w2 }, { s2, w2 }, { s3, w3 },
						 { s3, w4 }, { s3, w5 }, { s5, w5 }} ));
		AssertTrue( check_multimap( it, {{ s1, w1 }, { s2, w2 }, { s2, w2 }, { s3, w3 },
						 { s3, w3 }, { s3, w3 }, { s5, w5 }} ));
	}

	// erase
	{
		rr_multimap<const char[],test[3]>	p {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr } };
		rr_multimap<const char[],test[3]>	p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s3, w3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, w1 }, { s5, w5 }, { s3, w3 }} ));

		rr_multimap<const char[],test[3]>	q1( p );
		rr_multimap<const char[],test[3]>	q2( p );
		rr_multimap<const char[],test[3]>	q3( p );
		rr_multimap<const char[],test[3]>	q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_multimap( q1, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s3, w3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_multimap( q2, {{ s5, w5 }, { s8, w8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ s1, w1 }, { s3, w3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_multimap( q4, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test2E()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - deep pointer(f-array) value" );

	typedef typename rd_multimap<const char[],test[3]>::iterator	iterator;
	typedef typename rd_multimap<const char[],test[3]>::const_iterator	const_iterator;
	typedef	typename rd_multimap<const char[],test[3]>::value_type	pair;

	rr_multimap<const char[],test[3]>	m1 = {{ s1, w1 }, { s2, w2 }};
	rr_multimap<const char[],test[3]>	m2;
	rr_multimap<const char[],test[3]>	m3 = {{ s2, w2 }, { s3, w3 }, { s3, w3 }, { s3, w3 }, { s5, w5 }};

	// emplace
	{
		rd_multimap<const char[],test[3]>		pm;
		rd_multimap<const char[],test[3]>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, w1 }, { s2, w2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ s1, w1 }, { s2, w2 }, { s2, w2 }, { s3, w3 },
						 { s3, w3 }, { s3, w3 }, { s5, w5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, w1 }, { s2, w2 }, { s2, w2 }, { s3, w3 },
						 { s3, w3 }, { s3, w3 }, { s5, w5 }} ));
	}

	// insert
	{
		rd_multimap<const char[],test[3]>		pm;
		rd_multimap<const char[],test[3]>		pi;
		rd_multimap<const char[],test[3]>		il;
		rd_multimap<const char[],test[3]>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, w1 }, { s2, w2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_multimap( il, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_multimap( it, {{ s1, w1 }, { s2, w2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_multimap( il, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_multimap( it, {{ s1, w1 }, { s2, w2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s2, w2 }, { s3, w3 }, { s3, w4 }, { s3, w5 }, { s5, w5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ s1, w1 }, { s2, w2 }, { s2, w2 }, { s3, w3 },
						 { s3, w3 }, { s3, w3 }, { s5, w5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, w1 }, { s2, w2 }, { s2, w2 }, { s3, w3 },
						 { s3, w3 }, { s3, w3 }, { s5, w5 }} ));
		AssertTrue( check_multimap( il, {{ s1, w1 }, { s2, w2 }, { s2, w2 }, { s3, w3 },
						 { s3, w4 }, { s3, w5 }, { s5, w5 }} ));
		AssertTrue( check_multimap( it, {{ s1, w1 }, { s2, w2 }, { s2, w2 }, { s3, w3 },
						 { s3, w3 }, { s3, w3 }, { s5, w5 }} ));
	}

	// erase
	{
		rd_multimap<const char[],test[3]>	p {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr } };
		rd_multimap<const char[],test[3]>	p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s3, w3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, w1 }, { s5, w5 }, { s3, w3 }} ));

		rd_multimap<const char[],test[3]>	q1( p );
		rd_multimap<const char[],test[3]>	q2( p );
		rd_multimap<const char[],test[3]>	q3( p );
		rd_multimap<const char[],test[3]>	q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_multimap( q1, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s3, w3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_multimap( q2, {{ s5, w5 }, { s8, w8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ s1, w1 }, { s3, w3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_multimap( q4, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test2F()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - data(int value) value" );

	typedef typename rn_multimap<const char[],int>::iterator	iterator;
	typedef typename rn_multimap<const char[],int>::const_iterator	const_iterator;
	typedef	typename rn_multimap<const char[],int>::value_type	pair;

	rn_multimap<const char[],int>	m1 = {{ s1, 1 }, { s2, 2 }};
	rn_multimap<const char[],int>	m2;
	rn_multimap<const char[],int>	m3 = {{ s2, 2 }, { s3, 3 }, { s3, 3 }, { s3, 3 }, { s5, 5 }};

	// emplace
	{
		rn_multimap<const char[],int>		pm;
		rn_multimap<const char[],int>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ s1, 1 }, { s2, 2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, 1 }, { s2, 2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ s1, 1 }, { s2, 2 }, { s2, 2 }, { s3, 3 },
						 { s3, 3 }, { s3, 3 }, { s5, 5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, 1 }, { s2, 2 }, { s2, 2 }, { s3, 3 },
						 { s3, 3 }, { s3, 3 }, { s5, 5 }} ));
	}

	// insert
	{
		rn_multimap<const char[],int>		pm;
		rn_multimap<const char[],int>		pi;
		rn_multimap<const char[],int>		il;
		rn_multimap<const char[],int>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, 1 }, { s2, 2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ s1, 1 }, { s2, 2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, 1 }, { s2, 2 }} ));
		AssertTrue( check_multimap( il, {{ s1, 1 }, { s2, 2 }} ));
		AssertTrue( check_multimap( it, {{ s1, 1 }, { s2, 2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ s1, 1 }, { s2, 2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, 1 }, { s2, 2 }} ));
		AssertTrue( check_multimap( il, {{ s1, 1 }, { s2, 2 }} ));
		AssertTrue( check_multimap( it, {{ s1, 1 }, { s2, 2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s2, 2 }, { s3, 3 }, { s3, 4 }, { s3, 5 }, { s5, 5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ s1, 1 }, { s2, 2 }, { s2, 2 }, { s3, 3 },
						 { s3, 3 }, { s3, 3 }, { s5, 5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, 1 }, { s2, 2 }, { s2, 2 }, { s3, 3 },
						 { s3, 3 }, { s3, 3 }, { s5, 5 }} ));
		AssertTrue( check_multimap( il, {{ s1, 1 }, { s2, 2 }, { s2, 2 }, { s3, 3 },
						 { s3, 4 }, { s3, 5 }, { s5, 5 }} ));
		AssertTrue( check_multimap( it, {{ s1, 1 }, { s2, 2 }, { s2, 2 }, { s3, 3 },
						 { s3, 3 }, { s3, 3 }, { s5, 5 }} ));
	}

	// erase
	{
		rn_multimap<const char[],int>	p {{ s1, 1 }, { s5, 5 }, { s8, 8 }, { s4, 4 }, { s3, 3 }, { nullptr, 0 } };
		rn_multimap<const char[],int>	p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, 1 }, { s5, 5 }, { s8, 8 }, { s3, 3 }, { nullptr, 0 }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, 1 }, { s5, 5 }, { s3, 3 }} ));

		rn_multimap<const char[],int>	q1( p );
		rn_multimap<const char[],int>	q2( p );
		rn_multimap<const char[],int>	q3( p );
		rn_multimap<const char[],int>	q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_multimap( q1, {{ s1, 1 }, { s5, 5 }, { s8, 8 }, { s3, 3 }, { nullptr, 0 }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_multimap( q2, {{ s5, 5 }, { s8, 8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ s1, 1 }, { s3, 3 }, { nullptr, 0 }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_multimap( q4, {{ s1, 1 }, { s5, 5 }, { s8, 8 }, { s4, 4 }, { s3, 3 }, { nullptr, 0 }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ s1, 1 }, { s5, 5 }, { s8, 8 }, { s4, 4 }, { s3, 3 }, { nullptr, 0 }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ s1, 1 }, { s5, 5 }, { s8, 8 }, { s4, 4 }, { s3, 3 }, { nullptr, 0 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test30()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - deep pointer(pointer) value" );

	typedef typename rd_multimap<const char[],test*>::iterator	iterator;
	typedef typename rd_multimap<const char[],test*>::const_iterator	const_iterator;
	typedef	typename rd_multimap<const char[],test*>::value_type	pair;

	rr_multimap<const char[],test*>	m1 = {{ s1, &t1 }, { s2, &t2 }};
	rr_multimap<const char[],test*>	m2;
	rr_multimap<const char[],test*>	m3 = {{ s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s5, &t5 }};

	// emplace
	{
		rd_multimap<const char[],test*>		pm;
		rd_multimap<const char[],test*>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, &t1 }, { s2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s3, &t3 },
						 { s3, &t3 }, { s3, &t3 }, { s5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s3, &t3 },
						 { s3, &t3 }, { s3, &t3 }, { s5, &t5 }} ));
	}

	// insert
	{
		rd_multimap<const char[],test*>		pm;
		rd_multimap<const char[],test*>		pi;
		rd_multimap<const char[],test*>		il;
		rd_multimap<const char[],test*>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, &t1 }, { s2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ s1, &t1 }, { s2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ s1, &t1 }, { s2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s2, &t2 }, { s3, &t3 }, { s3, &t4 }, { s3, &t5 }, { s5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s3, &t3 },
						 { s3, &t3 }, { s3, &t3 }, { s5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s3, &t3 },
						 { s3, &t3 }, { s3, &t3 }, { s5, &t5 }} ));
		AssertTrue( check_multimap( il, {{ s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s3, &t3 },
						 { s3, &t4 }, { s3, &t5 }, { s5, &t5 }} ));
		AssertTrue( check_multimap( it, {{ s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s3, &t3 },
						 { s3, &t3 }, { s3, &t3 }, { s5, &t5 }} ));
	}

	// erase
	{
		rd_multimap<const char[],test*>	p {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr } };
		rd_multimap<const char[],test*>	p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, &t1 }, { s5, &t5 }, { s3, &t3 }} ));

		rd_multimap<const char[],test*>	q1( p );
		rd_multimap<const char[],test*>	q2( p );
		rd_multimap<const char[],test*>	q3( p );
		rd_multimap<const char[],test*>	q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_multimap( q1, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_multimap( q2, {{ s5, &t5 }, { s8, &t8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ s1, &t1 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_multimap( q4, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test31()
{
	this->set_subtitle( "emplace/insert/erase, deep pointer(c-string) key - deep pointer(pointer) value" );

	typedef typename dd_multimap<const char[],test*>::iterator	iterator;
	typedef typename dd_multimap<const char[],test*>::const_iterator	const_iterator;
	typedef	typename dd_multimap<const char[],test*>::value_type	pair;

	rr_multimap<const char[],test*>	m1 = {{ s1, &t1 }, { s2, &t2 }};
	rr_multimap<const char[],test*>	m2;
	rr_multimap<const char[],test*>	m3 = {{ s2, &t2 }, { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s5, &t5 }};

	// emplace
	{
		dd_multimap<const char[],test*>		pm;
		dd_multimap<const char[],test*>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, &t1 }, { s2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s3, &t3 },
						 { s3, &t3 }, { s3, &t3 }, { s5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s3, &t3 },
						 { s3, &t3 }, { s3, &t3 }, { s5, &t5 }} ));
	}

	// insert
	{
		dd_multimap<const char[],test*>		pm;
		dd_multimap<const char[],test*>		pi;
		dd_multimap<const char[],test*>		il;
		dd_multimap<const char[],test*>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, &t1 }, { s2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ s1, &t1 }, { s2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ s1, &t1 }, { s2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s2, &t2 }, { s3, &t3 }, { s3, &t4 }, { s3, &t5 }, { s5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s3, &t3 },
						 { s3, &t3 }, { s3, &t3 }, { s5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s3, &t3 },
						 { s3, &t3 }, { s3, &t3 }, { s5, &t5 }} ));
		AssertTrue( check_multimap( il, {{ s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s3, &t3 },
						 { s3, &t4 }, { s3, &t5 }, { s5, &t5 }} ));
		AssertTrue( check_multimap( it, {{ s1, &t1 }, { s2, &t2 }, { s2, &t2 }, { s3, &t3 },
						 { s3, &t3 }, { s3, &t3 }, { s5, &t5 }} ));
	}

	// erase
	{
		dd_multimap<const char[],test*>	p {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr } };
		dd_multimap<const char[],test*>	p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_multimap( p1, {{ s1, &t1 }, { s5, &t5 }, { s3, &t3 }} ));

		dd_multimap<const char[],test*>	q1( p );
		dd_multimap<const char[],test*>	q2( p );
		dd_multimap<const char[],test*>	q3( p );
		dd_multimap<const char[],test*>	q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_multimap( q1, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_multimap( q2, {{ s5, &t5 }, { s8, &t8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ s1, &t1 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_multimap( q4, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test32()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(v-array) key - deep pointer(pointer) value" );

	typedef typename rd_multimap<test[],test*>::iterator	iterator;
	typedef typename rd_multimap<test[],test*>::const_iterator	const_iterator;
	typedef	typename rd_multimap<test[],test*>::value_type	pair;

	rr_multimap<const test[],test*>	m1 = {{ v1, &t1 }, { v2, &t2 }};
	rr_multimap<const test[],test*>	m2;
	rr_multimap<const test[],test*>	m3 = {{ v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v5, &t5 }};

	// emplace
	{
		rd_multimap<test[],test*>		pm;
		rd_multimap<test[],test*>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ v1, &t1 }, { v2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v3, &t3 },
						 { v3, &t3 }, { v3, &t3 }, { v5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v3, &t3 },
						 { v3, &t3 }, { v3, &t3 }, { v5, &t5 }} ));
	}

	// insert
	{
		rd_multimap<test[],test*>		pm;
		rd_multimap<test[],test*>		pi;
		rd_multimap<test[],test*>		il;
		rd_multimap<test[],test*>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ v1, &t1 }, { v2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ v1, &t1 }, { v2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ v1, &t1 }, { v2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ v2, &t2 }, { v3, &t3 }, { v3, &t4 }, { v3, &t5 }, { v5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v3, &t3 },
						 { v3, &t3 }, { v3, &t3 }, { v5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v3, &t3 },
						 { v3, &t3 }, { v3, &t3 }, { v5, &t5 }} ));
		AssertTrue( check_multimap( il, {{ v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v3, &t3 },
						 { v3, &t4 }, { v3, &t5 }, { v5, &t5 }} ));
		AssertTrue( check_multimap( it, {{ v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v3, &t3 },
						 { v3, &t3 }, { v3, &t3 }, { v5, &t5 }} ));
	}

	// erase
	{
		rd_multimap<test[],test*>	p {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr } };
		rd_multimap<test[],test*>	p1( p );

		AssertEqual( p1.erase( v4 ), 1 );
		AssertTrue( check_multimap( p1, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( v7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( v1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( v8 ), 1 );
		AssertTrue( check_multimap( p1, {{ v1, &t1 }, { v5, &t5 }, { v3, &t3 }} ));

		rd_multimap<test[],test*>	q1( p );
		rd_multimap<test[],test*>	q2( p );
		rd_multimap<test[],test*>	q3( p );
		rd_multimap<test[],test*>	q4( p );

		q1.erase( q1.find( v4 ), q1.upper_bound( v4 ));
		AssertTrue( check_multimap( q1, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( v4 ));
		AssertTrue( check_multimap( q2, {{ v5, &t5 }, { v8, &t8 }} ));
		q3.erase( q3.find( v4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ v1, &t1 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( v4 ), q4.find( v4 ));
		AssertTrue( check_multimap( q4, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test33()
{
	this->set_subtitle( "emplace/insert/erase, deep pointer(v-array) key - deep pointer(pointer) value" );

	typedef typename dd_multimap<test[],test*>::iterator	iterator;
	typedef typename dd_multimap<test[],test*>::const_iterator	const_iterator;
	typedef	typename dd_multimap<test[],test*>::value_type	pair;

	rr_multimap<const test[],test*>	m1 = {{ v1, &t1 }, { v2, &t2 }};
	rr_multimap<const test[],test*>	m2;
	rr_multimap<const test[],test*>	m3 = {{ v2, &t2 }, { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v5, &t5 }};

	// emplace
	{
		dd_multimap<test[],test*>		pm;
		dd_multimap<test[],test*>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ v1, &t1 }, { v2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v3, &t3 },
						 { v3, &t3 }, { v3, &t3 }, { v5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v3, &t3 },
						 { v3, &t3 }, { v3, &t3 }, { v5, &t5 }} ));
	}

	// insert
	{
		dd_multimap<test[],test*>		pm;
		dd_multimap<test[],test*>		pi;
		dd_multimap<test[],test*>		il;
		dd_multimap<test[],test*>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ v1, &t1 }, { v2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ v1, &t1 }, { v2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ v1, &t1 }, { v2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ v2, &t2 }, { v3, &t3 }, { v3, &t4 }, { v3, &t5 }, { v5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v3, &t3 },
						 { v3, &t3 }, { v3, &t3 }, { v5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v3, &t3 },
						 { v3, &t3 }, { v3, &t3 }, { v5, &t5 }} ));
		AssertTrue( check_multimap( il, {{ v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v3, &t3 },
						 { v3, &t4 }, { v3, &t5 }, { v5, &t5 }} ));
		AssertTrue( check_multimap( it, {{ v1, &t1 }, { v2, &t2 }, { v2, &t2 }, { v3, &t3 },
						 { v3, &t3 }, { v3, &t3 }, { v5, &t5 }} ));
	}

	// erase
	{
		dd_multimap<test[],test*>	p {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr } };
		dd_multimap<test[],test*>	p1( p );

		AssertEqual( p1.erase( v4 ), 1 );
		AssertTrue( check_multimap( p1, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( v7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( v1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( v8 ), 1 );
		AssertTrue( check_multimap( p1, {{ v1, &t1 }, { v5, &t5 }, { v3, &t3 }} ));

		dd_multimap<test[],test*>	q1( p );
		dd_multimap<test[],test*>	q2( p );
		dd_multimap<test[],test*>	q3( p );
		dd_multimap<test[],test*>	q4( p );

		q1.erase( q1.find( v4 ), q1.upper_bound( v4 ));
		AssertTrue( check_multimap( q1, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( v4 ));
		AssertTrue( check_multimap( q2, {{ v5, &t5 }, { v8, &t8 }} ));
		q3.erase( q3.find( v4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ v1, &t1 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( v4 ), q4.find( v4 ));
		AssertTrue( check_multimap( q4, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test34()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(f-array) key - deep pointer(pointer) value" );

	typedef typename rd_multimap<test[3],test*>::iterator	iterator;
	typedef typename rd_multimap<test[3],test*>::const_iterator	const_iterator;
	typedef	typename rd_multimap<test[3],test*>::value_type	pair;

	rr_multimap<const test[3],test*>	m1 = {{ w1, &t1 }, { w2, &t2 }};
	rr_multimap<const test[3],test*>	m2;
	rr_multimap<const test[3],test*>	m3 = {{ w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w5, &t5 }};

	// emplace
	{
		rd_multimap<test[3],test*>		pm;
		rd_multimap<test[3],test*>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ w1, &t1 }, { w2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w3, &t3 },
						 { w3, &t3 }, { w3, &t3 }, { w5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w3, &t3 },
						 { w3, &t3 }, { w3, &t3 }, { w5, &t5 }} ));
	}

	// insert
	{
		rd_multimap<test[3],test*>		pm;
		rd_multimap<test[3],test*>		pi;
		rd_multimap<test[3],test*>		il;
		rd_multimap<test[3],test*>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ w1, &t1 }, { w2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ w1, &t1 }, { w2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ w1, &t1 }, { w2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ w2, &t2 }, { w3, &t3 }, { w3, &t4 }, { w3, &t5 }, { w5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w3, &t3 },
						 { w3, &t3 }, { w3, &t3 }, { w5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w3, &t3 },
						 { w3, &t3 }, { w3, &t3 }, { w5, &t5 }} ));
		AssertTrue( check_multimap( il, {{ w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w3, &t3 },
						 { w3, &t4 }, { w3, &t5 }, { w5, &t5 }} ));
		AssertTrue( check_multimap( it, {{ w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w3, &t3 },
						 { w3, &t3 }, { w3, &t3 }, { w5, &t5 }} ));
	}

	// erase
	{
		rd_multimap<test[3],test*>	p {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr } };
		rd_multimap<test[3],test*>	p1( p );

		AssertEqual( p1.erase( w4 ), 1 );
		AssertTrue( check_multimap( p1, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( w7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( w1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( w8 ), 1 );
		AssertTrue( check_multimap( p1, {{ w1, &t1 }, { w5, &t5 }, { w3, &t3 }} ));

		rd_multimap<test[3],test*>	q1( p );
		rd_multimap<test[3],test*>	q2( p );
		rd_multimap<test[3],test*>	q3( p );
		rd_multimap<test[3],test*>	q4( p );

		q1.erase( q1.find( w4 ), q1.upper_bound( w4 ));
		AssertTrue( check_multimap( q1, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( w4 ));
		AssertTrue( check_multimap( q2, {{ w5, &t5 }, { w8, &t8 }} ));
		q3.erase( q3.find( w4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ w1, &t1 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( w4 ), q4.find( w4 ));
		AssertTrue( check_multimap( q4, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test35()
{
	this->set_subtitle( "emplace/insert/erase, deep pointer(f-array) key - deep pointer(pointer) value" );

	typedef typename dd_multimap<test[3],test*>::iterator	iterator;
	typedef typename dd_multimap<test[3],test*>::const_iterator	const_iterator;
	typedef	typename dd_multimap<test[3],test*>::value_type	pair;

	rr_multimap<const test[3],test*>	m1 = {{ w1, &t1 }, { w2, &t2 }};
	rr_multimap<const test[3],test*>	m2;
	rr_multimap<const test[3],test*>	m3 = {{ w2, &t2 }, { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w5, &t5 }};

	// emplace
	{
		dd_multimap<test[3],test*>		pm;
		dd_multimap<test[3],test*>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ w1, &t1 }, { w2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w3, &t3 },
						 { w3, &t3 }, { w3, &t3 }, { w5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w3, &t3 },
						 { w3, &t3 }, { w3, &t3 }, { w5, &t5 }} ));
	}

	// insert
	{
		dd_multimap<test[3],test*>		pm;
		dd_multimap<test[3],test*>		pi;
		dd_multimap<test[3],test*>		il;
		dd_multimap<test[3],test*>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ w1, &t1 }, { w2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ w1, &t1 }, { w2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ w1, &t1 }, { w2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ w2, &t2 }, { w3, &t3 }, { w3, &t4 }, { w3, &t5 }, { w5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w3, &t3 },
						 { w3, &t3 }, { w3, &t3 }, { w5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w3, &t3 },
						 { w3, &t3 }, { w3, &t3 }, { w5, &t5 }} ));
		AssertTrue( check_multimap( il, {{ w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w3, &t3 },
						 { w3, &t4 }, { w3, &t5 }, { w5, &t5 }} ));
		AssertTrue( check_multimap( it, {{ w1, &t1 }, { w2, &t2 }, { w2, &t2 }, { w3, &t3 },
						 { w3, &t3 }, { w3, &t3 }, { w5, &t5 }} ));
	}

	// erase
	{
		dd_multimap<test[3],test*>	p {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr } };
		dd_multimap<test[3],test*>	p1( p );

		AssertEqual( p1.erase( w4 ), 1 );
		AssertTrue( check_multimap( p1, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( w7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( w1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( w8 ), 1 );
		AssertTrue( check_multimap( p1, {{ w1, &t1 }, { w5, &t5 }, { w3, &t3 }} ));

		dd_multimap<test[3],test*>	q1( p );
		dd_multimap<test[3],test*>	q2( p );
		dd_multimap<test[3],test*>	q3( p );
		dd_multimap<test[3],test*>	q4( p );

		q1.erase( q1.find( w4 ), q1.upper_bound( w4 ));
		AssertTrue( check_multimap( q1, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( w4 ));
		AssertTrue( check_multimap( q2, {{ w5, &t5 }, { w8, &t8 }} ));
		q3.erase( q3.find( w4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ w1, &t1 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( w4 ), q4.find( w4 ));
		AssertTrue( check_multimap( q4, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test36()
{
	this->set_subtitle( "emplace/insert/erase, data(int value) key - deep pointer(pointer) value" );

	typedef typename nd_multimap<int,test*>::iterator	iterator;
	typedef typename nd_multimap<int,test*>::const_iterator	const_iterator;
	typedef	typename nd_multimap<int,test*>::value_type	pair;

	nr_multimap<int,test*>	m1 = {{ 1, &t1 }, { 2, &t2 }};
	nr_multimap<int,test*>	m2;
	nr_multimap<int,test*>	m3 = {{ 2, &t2 }, { 3, &t3 }, { 3, &t3 }, { 3, &t3 }, { 5, &t5 }};

	// emplace
	{
		nd_multimap<int,test*>		pm;
		nd_multimap<int,test*>		pi;
		iterator		r;
		const_iterator		j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );	// deep compaire
		}
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );	// deep compaire
		}

		AssertTrue( check_multimap( pm, {{ 1, &t1 }, { 2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ 1, &t1 }, { 2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r->first );
		}
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}

		AssertTrue( check_multimap( pm, {{ 1, &t1 }, { 2, &t2 }, { 2, &t2 }, { 3, &t3 },
						 { 3, &t3 }, { 3, &t3 }, { 5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ 1, &t1 }, { 2, &t2 }, { 2, &t2 }, { 3, &t3 },
						 { 3, &t3 }, { 3, &t3 }, { 5, &t5 }} ));
	}

	// insert
	{
		nd_multimap<int,test*>		pm;
		nd_multimap<int,test*>		pi;
		nd_multimap<int,test*>		il;
		nd_multimap<int,test*>		it;
		const_iterator		r;
		iterator		j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ 1, &t1 }, { 2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_multimap( pm, {{ 1, &t1 }, { 2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ 1, &t1 }, { 2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ 1, &t1 }, { 2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ 1, &t1 }, { 2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_multimap( pm, {{ 1, &t1 }, { 2, &t2 }} ));
		AssertTrue( check_multimap( pi, {{ 1, &t1 }, { 2, &t2 }} ));
		AssertTrue( check_multimap( il, {{ 1, &t1 }, { 2, &t2 }} ));
		AssertTrue( check_multimap( it, {{ 1, &t1 }, { 2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r->first );
		}
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ 2, &t2 }, { 3, &t3 }, { 3, &t4 }, { 3, &t5 }, { 5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_multimap( pm, {{ 1, &t1 }, { 2, &t2 }, { 2, &t2 }, { 3, &t3 },
						 { 3, &t3 }, { 3, &t3 }, { 5, &t5 }} ));
		AssertTrue( check_multimap( pi, {{ 1, &t1 }, { 2, &t2 }, { 2, &t2 }, { 3, &t3 },
						 { 3, &t3 }, { 3, &t3 }, { 5, &t5 }} ));
		AssertTrue( check_multimap( il, {{ 1, &t1 }, { 2, &t2 }, { 2, &t2 }, { 3, &t3 },
						 { 3, &t4 }, { 3, &t5 }, { 5, &t5 }} ));
		AssertTrue( check_multimap( it, {{ 1, &t1 }, { 2, &t2 }, { 2, &t2 }, { 3, &t3 },
						 { 3, &t3 }, { 3, &t3 }, { 5, &t5 }} ));
	}

	// erase
	{
		nd_multimap<int,test*>	p {{ 1, &t1 }, { 5, &t5 }, { 8, &t8 }, { 4, &t4 }, { 3, &t3 }, { 0, nullptr } };
		nd_multimap<int,test*>	p1( p );

		AssertEqual( p1.erase( 4 ), 1 );
		AssertTrue( check_multimap( p1, {{ 1, &t1 }, { 5, &t5 }, { 8, &t8 }, { 3, &t3 }, { 0, nullptr }} ));
		AssertZero( p1.erase( 7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( 1 ));		// m.erase( itor ) -> void ??
		//p1.erase( p1.begin() );					// c++98 feature remained in c++11
		AssertEqual( p1.erase( 8 ), 1 );
		AssertTrue( check_multimap( p1, {{ 1, &t1 }, { 5, &t5 }, { 3, &t3 }} ));

		nd_multimap<int,test*>	q1( p );
		nd_multimap<int,test*>	q2( p );
		nd_multimap<int,test*>	q3( p );
		nd_multimap<int,test*>	q4( p );

		q1.erase( q1.find( 4 ), q1.upper_bound( 4 ));
		AssertTrue( check_multimap( q1, {{ 1, &t1 }, { 5, &t5 }, { 8, &t8 }, { 3, &t3 }, { 0, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_multimap( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( 4 ));
		AssertTrue( check_multimap( q2, {{ 5, &t5 }, { 8, &t8 }} ));
		q3.erase( q3.find( 4 ), q3.end());
		AssertTrue( check_multimap( q3, {{ 1, &t1 }, { 3, &t3 }, { 0, nullptr }} ));
		q4.erase( q4.find( 4 ), q4.find( 4 ));
		AssertTrue( check_multimap( q4, {{ 1, &t1 }, { 5, &t5 }, { 8, &t8 }, { 4, &t4 }, { 3, &t3 }, { 0, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_multimap( q4, {{ 1, &t1 }, { 5, &t5 }, { 8, &t8 }, { 4, &t4 }, { 3, &t3 }, { 0, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_multimap( q4, {{ 1, &t1 }, { 5, &t5 }, { 8, &t8 }, { 4, &t4 }, { 3, &t3 }, { 0, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test37()
{
	this->set_subtitle( "iterator, reference pointer(pointer) key - reference pointer(pointer) value" );

	rr_multimap<test*,test*>	pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	{
		rr_multimap<test*,test*>::iterator   i;
		rr_multimap<test*,test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rr_multimap<test*,test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( &t3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rr_multimap<test*,test*>::reverse_iterator   i;
		rr_multimap<test*,test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = rr_multimap<test*,test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<rr_multimap<test*,test*>::const_reverse_iterator>( pm.find( &t2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test38()
{
	this->set_subtitle( "iterator, deep pointer(pointer) key - reference pointer(pointer) value" );

	dr_multimap<test*,test*>	pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	{
		dr_multimap<test*,test*>::iterator   i;
		dr_multimap<test*,test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = dr_multimap<test*,test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( &t3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		dr_multimap<test*,test*>::reverse_iterator   i;
		dr_multimap<test*,test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = dr_multimap<test*,test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<dr_multimap<test*,test*>::const_reverse_iterator>( pm.find( &t2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test39()
{
	this->set_subtitle( "iterator, reference pointer(pointer) key - deep pointer(pointer) value" );

	rd_multimap<test*,test*>	pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	{
		rd_multimap<test*,test*>::iterator   i;
		rd_multimap<test*,test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rd_multimap<test*,test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( &t3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rd_multimap<test*,test*>::reverse_iterator   i;
		rd_multimap<test*,test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = rd_multimap<test*,test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<rd_multimap<test*,test*>::const_reverse_iterator>( pm.find( &t2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test3A()
{
	this->set_subtitle( "iterator, deep pointer(pointer) key - deep pointer(pointer) value" );

	dd_multimap<test*,test*>	pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	{
		dd_multimap<test*,test*>::iterator   i;
		dd_multimap<test*,test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = dd_multimap<test*,test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( &t3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		dd_multimap<test*,test*>::reverse_iterator   i;
		dd_multimap<test*,test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = dd_multimap<test*,test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<dd_multimap<test*,test*>::const_reverse_iterator>( pm.find( &t2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test3B()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - reference pointer(c-string) value" );

	rr_multimap<const char[],const char[]>	pm = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	{
		rr_multimap<const char[],const char[]>::iterator   i;
		rr_multimap<const char[],const char[]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rr_multimap<const char[],const char[]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertEqual( i->second, s3 );
				AssertZero( strcmp( i->second, s3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rr_multimap<const char[],const char[]>::reverse_iterator   i;
		rr_multimap<const char[],const char[]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = rr_multimap<const char[],const char[]>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertEqual( i->second, s1 );
				AssertZero( strcmp( i->second, s1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<rr_multimap<const char[],const char[]>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test3C()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - deep pointer(c-string) value" );

	rd_multimap<const char[],const char[]>	pm = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	{
		rd_multimap<const char[],const char[]>::iterator   i;
		rd_multimap<const char[],const char[]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rd_multimap<const char[],const char[]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, s3 );
				AssertZero( strcmp( i->second, s3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rd_multimap<const char[],const char[]>::reverse_iterator   i;
		rd_multimap<const char[],const char[]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = rd_multimap<const char[],const char[]>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, s1 );
				AssertZero( strcmp( i->second, s1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<rd_multimap<const char[],const char[]>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test3D()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - reference pointer(v-array) value" );

	rr_multimap<const char[],test[]>	pm = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	{
		rr_multimap<const char[],test[]>::iterator   i;
		rr_multimap<const char[],test[]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rr_multimap<const char[],test[]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertEqual( i->second, v3 );
				AssertZero( dp_cmp<test[]>()( i->second, v3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rr_multimap<const char[],test[]>::reverse_iterator   i;
		rr_multimap<const char[],test[]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = rr_multimap<const char[],test[]>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertEqual( i->second, v1 );
				AssertZero( dp_cmp<test[]>()( i->second, v1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<rr_multimap<const char[],test[]>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test3E()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - deep pointer(v-array) value" );

	rd_multimap<const char[],test[]>	pm = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	{
		rd_multimap<const char[],test[]>::iterator   i;
		rd_multimap<const char[],test[]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rd_multimap<const char[],test[]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, v3 );
				AssertZero( dp_cmp<test[]>()( i->second, v3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rd_multimap<const char[],test[]>::reverse_iterator   i;
		rd_multimap<const char[],test[]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = rd_multimap<const char[],test[]>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, v1 );
				AssertZero( dp_cmp<test[]>()( i->second, v1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<rd_multimap<const char[],test[]>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test3F()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - reference pointer(f-array) value" );

	rr_multimap<const char[],test[3]>	pm = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	{
		rr_multimap<const char[],test[3]>::iterator   i;
		rr_multimap<const char[],test[3]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rr_multimap<const char[],test[3]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertEqual( i->second, w3 );
				AssertZero( dp_cmp<test[3]>()( i->second, w3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rr_multimap<const char[],test[3]>::reverse_iterator   i;
		rr_multimap<const char[],test[3]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = rr_multimap<const char[],test[3]>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertEqual( i->second, w1 );
				AssertZero( dp_cmp<test[3]>()( i->second, w1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<rr_multimap<const char[],test[3]>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test40()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - deep pointer(f-array) value" );

	rd_multimap<const char[],test[3]>	pm = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	{
		rd_multimap<const char[],test[3]>::iterator   i;
		rd_multimap<const char[],test[3]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rd_multimap<const char[],test[3]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, w3 );
				AssertZero( dp_cmp<test[3]>()( i->second, w3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rd_multimap<const char[],test[3]>::reverse_iterator   i;
		rd_multimap<const char[],test[3]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = rd_multimap<const char[],test[3]>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, w1 );
				AssertZero( dp_cmp<test[3]>()( i->second, w1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<rd_multimap<const char[],test[3]>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test41()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - data(int value) value" );

	rn_multimap<const char[],int>	pm = {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }};
	{
		rn_multimap<const char[],int>::iterator   i;
		rn_multimap<const char[],int>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rn_multimap<const char[],int>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());


				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rn_multimap<const char[],int>::reverse_iterator   i;
		rn_multimap<const char[],int>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = rn_multimap<const char[],int>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());


				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<rn_multimap<const char[],int>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test42()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - deep pointer(pointer) value" );

	rd_multimap<const char[],test*>	pm = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	{
		rd_multimap<const char[],test*>::iterator   i;
		rd_multimap<const char[],test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rd_multimap<const char[],test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rd_multimap<const char[],test*>::reverse_iterator   i;
		rd_multimap<const char[],test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = rd_multimap<const char[],test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<rd_multimap<const char[],test*>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test43()
{
	this->set_subtitle( "iterator, deep pointer(c-string) key - deep pointer(pointer) value" );

	dd_multimap<const char[],test*>	pm = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	{
		dd_multimap<const char[],test*>::iterator   i;
		dd_multimap<const char[],test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = dd_multimap<const char[],test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		dd_multimap<const char[],test*>::reverse_iterator   i;
		dd_multimap<const char[],test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = dd_multimap<const char[],test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<dd_multimap<const char[],test*>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test44()
{
	this->set_subtitle( "iterator, reference pointer(v-array) key - deep pointer(pointer) value" );

	rd_multimap<test[],test*>	pm = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	{
		rd_multimap<test[],test*>::iterator   i;
		rd_multimap<test[],test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rd_multimap<test[],test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( v3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rd_multimap<test[],test*>::reverse_iterator   i;
		rd_multimap<test[],test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = rd_multimap<test[],test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<rd_multimap<test[],test*>::const_reverse_iterator>( pm.find( v2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test45()
{
	this->set_subtitle( "iterator, deep pointer(v-array) key - deep pointer(pointer) value" );

	dd_multimap<test[],test*>	pm = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	{
		dd_multimap<test[],test*>::iterator   i;
		dd_multimap<test[],test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = dd_multimap<test[],test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( v3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		dd_multimap<test[],test*>::reverse_iterator   i;
		dd_multimap<test[],test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = dd_multimap<test[],test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<dd_multimap<test[],test*>::const_reverse_iterator>( pm.find( v2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test46()
{
	this->set_subtitle( "iterator, reference pointer(f-array) key - deep pointer(pointer) value" );

	rd_multimap<test[3],test*>	pm = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	{
		rd_multimap<test[3],test*>::iterator   i;
		rd_multimap<test[3],test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = rd_multimap<test[3],test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( w3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		rd_multimap<test[3],test*>::reverse_iterator   i;
		rd_multimap<test[3],test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = rd_multimap<test[3],test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<rd_multimap<test[3],test*>::const_reverse_iterator>( pm.find( w2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test47()
{
	this->set_subtitle( "iterator, deep pointer(f-array) key - deep pointer(pointer) value" );

	dd_multimap<test[3],test*>	pm = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	{
		dd_multimap<test[3],test*>::iterator   i;
		dd_multimap<test[3],test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = dd_multimap<test[3],test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( w3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		dd_multimap<test[3],test*>::reverse_iterator   i;
		dd_multimap<test[3],test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = dd_multimap<test[3],test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<dd_multimap<test[3],test*>::const_reverse_iterator>( pm.find( w2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test48()
{
	this->set_subtitle( "iterator, data(int value) key - deep pointer(pointer) value" );

	nd_multimap<int,test*>	pm = {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }};
	{
		nd_multimap<int,test*>::iterator   i;
		nd_multimap<int,test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = nd_multimap<int,test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( 3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		nd_multimap<int,test*>::reverse_iterator   i;
		nd_multimap<int,test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = nd_multimap<int,test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<nd_multimap<int,test*>::const_reverse_iterator>( pm.find( 2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test49()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(pointer) key - reference pointer(pointer) value" );

	rr_multimap<test*,test*>	r1;
	rr_multimap<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	rr_multimap<test*,test*>	r3 = {{ &t4, &t4 }, { &t5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	AssertTrue( check_multimap( r2, {{ &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( &t1 ), 1 );
	AssertEqual( r1.count( &t3 ), 1 );
	AssertEqual( r1.count( &t4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test4A()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), deep pointer(pointer) key - reference pointer(pointer) value" );

	dr_multimap<test*,test*>	r1;
	dr_multimap<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	dr_multimap<test*,test*>	r3 = {{ &t4, &t4 }, { &t5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	AssertTrue( check_multimap( r2, {{ &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( &t1 ), 1 );
	AssertEqual( r1.count( &t3 ), 1 );
	AssertEqual( r1.count( &t4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test4B()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(pointer) key - deep pointer(pointer) value" );

	rd_multimap<test*,test*>	r1;
	rd_multimap<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	rd_multimap<test*,test*>	r3 = {{ &t4, &t4 }, { &t5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	AssertTrue( check_multimap( r2, {{ &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( &t1 ), 1 );
	AssertEqual( r1.count( &t3 ), 1 );
	AssertEqual( r1.count( &t4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test4C()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), deep pointer(pointer) key - deep pointer(pointer) value" );

	dd_multimap<test*,test*>	r1;
	dd_multimap<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	dd_multimap<test*,test*>	r3 = {{ &t4, &t4 }, { &t5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	AssertTrue( check_multimap( r2, {{ &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( &t1 ), 1 );
	AssertEqual( r1.count( &t3 ), 1 );
	AssertEqual( r1.count( &t4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test4D()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - reference pointer(c-string) value" );

	rr_multimap<const char[],const char[]>	r1;
	rr_multimap<const char[],const char[]>	r2 = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	rr_multimap<const char[],const char[]>	r3 = {{ s4, s4 }, { s5, s5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
	AssertTrue( check_multimap( r2, {{ s4, s4 }, { s5, s5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test4E()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - deep pointer(c-string) value" );

	rd_multimap<const char[],const char[]>	r1;
	rd_multimap<const char[],const char[]>	r2 = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	rd_multimap<const char[],const char[]>	r3 = {{ s4, s4 }, { s5, s5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
	AssertTrue( check_multimap( r2, {{ s4, s4 }, { s5, s5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test4F()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - reference pointer(v-array) value" );

	rr_multimap<const char[],test[]>	r1;
	rr_multimap<const char[],test[]>	r2 = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	rr_multimap<const char[],test[]>	r3 = {{ s4, v4 }, { s5, v5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
	AssertTrue( check_multimap( r2, {{ s4, v4 }, { s5, v5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test50()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - deep pointer(v-array) value" );

	rd_multimap<const char[],test[]>	r1;
	rd_multimap<const char[],test[]>	r2 = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	rd_multimap<const char[],test[]>	r3 = {{ s4, v4 }, { s5, v5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
	AssertTrue( check_multimap( r2, {{ s4, v4 }, { s5, v5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test51()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - reference pointer(f-array) value" );

	rr_multimap<const char[],test[3]>	r1;
	rr_multimap<const char[],test[3]>	r2 = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	rr_multimap<const char[],test[3]>	r3 = {{ s4, w4 }, { s5, w5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
	AssertTrue( check_multimap( r2, {{ s4, w4 }, { s5, w5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test52()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - deep pointer(f-array) value" );

	rd_multimap<const char[],test[3]>	r1;
	rd_multimap<const char[],test[3]>	r2 = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	rd_multimap<const char[],test[3]>	r3 = {{ s4, w4 }, { s5, w5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
	AssertTrue( check_multimap( r2, {{ s4, w4 }, { s5, w5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test53()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - data(int value) value" );

	rn_multimap<const char[],int>	r1;
	rn_multimap<const char[],int>	r2 = {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }};
	rn_multimap<const char[],int>	r3 = {{ s4, 4 }, { s5, 5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }} ));
	AssertTrue( check_multimap( r2, {{ s4, 4 }, { s5, 5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test54()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - deep pointer(pointer) value" );

	rd_multimap<const char[],test*>	r1;
	rd_multimap<const char[],test*>	r2 = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	rd_multimap<const char[],test*>	r3 = {{ s4, &t4 }, { s5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
	AssertTrue( check_multimap( r2, {{ s4, &t4 }, { s5, &t5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test55()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), deep pointer(c-string) key - deep pointer(pointer) value" );

	dd_multimap<const char[],test*>	r1;
	dd_multimap<const char[],test*>	r2 = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	dd_multimap<const char[],test*>	r3 = {{ s4, &t4 }, { s5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
	AssertTrue( check_multimap( r2, {{ s4, &t4 }, { s5, &t5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test56()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(v-array) key - deep pointer(pointer) value" );

	rd_multimap<test[],test*>	r1;
	rd_multimap<test[],test*>	r2 = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	rd_multimap<test[],test*>	r3 = {{ v4, &t4 }, { v5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
	AssertTrue( check_multimap( r2, {{ v4, &t4 }, { v5, &t5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( v1 ), 1 );
	AssertEqual( r1.count( v3 ), 1 );
	AssertEqual( r1.count( v4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test57()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), deep pointer(v-array) key - deep pointer(pointer) value" );

	dd_multimap<test[],test*>	r1;
	dd_multimap<test[],test*>	r2 = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	dd_multimap<test[],test*>	r3 = {{ v4, &t4 }, { v5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
	AssertTrue( check_multimap( r2, {{ v4, &t4 }, { v5, &t5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( v1 ), 1 );
	AssertEqual( r1.count( v3 ), 1 );
	AssertEqual( r1.count( v4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test58()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(f-array) key - deep pointer(pointer) value" );

	rd_multimap<test[3],test*>	r1;
	rd_multimap<test[3],test*>	r2 = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	rd_multimap<test[3],test*>	r3 = {{ w4, &t4 }, { w5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
	AssertTrue( check_multimap( r2, {{ w4, &t4 }, { w5, &t5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( w1 ), 1 );
	AssertEqual( r1.count( w3 ), 1 );
	AssertEqual( r1.count( w4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test59()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), deep pointer(f-array) key - deep pointer(pointer) value" );

	dd_multimap<test[3],test*>	r1;
	dd_multimap<test[3],test*>	r2 = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	dd_multimap<test[3],test*>	r3 = {{ w4, &t4 }, { w5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
	AssertTrue( check_multimap( r2, {{ w4, &t4 }, { w5, &t5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( w1 ), 1 );
	AssertEqual( r1.count( w3 ), 1 );
	AssertEqual( r1.count( w4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test5A()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), data(int value) key - deep pointer(pointer) value" );

	nd_multimap<int,test*>	r1;
	nd_multimap<int,test*>	r2 = {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }};
	nd_multimap<int,test*>	r3 = {{ 4, &t4 }, { 5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_multimap( r1, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }} ));
	AssertTrue( check_multimap( r2, {{ 4, &t4 }, { 5, &t5 }} ));
	AssertTrue( check_multimap( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( 1 ), 1 );
	AssertEqual( r1.count( 3 ), 1 );
	AssertEqual( r1.count( 4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_multimap( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test5B()
{
	this->set_subtitle( "relational operators, reference pointer(pointer) key - reference pointer(pointer) value" );

	rr_multimap<test*,test*>	r1 = {{ &t1, &t1 }, { &t2, &t2 }};
	rr_multimap<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	rr_multimap<test*,test*>	r3 = {{ &t1, &t1 }, { &t3, &t3 }, { &t2, &t2 }};
	rr_multimap<test*,test*>	r4 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	rr_multimap<test*,test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test5C()
{
	this->set_subtitle( "relational operators, deep pointer(pointer) key - reference pointer(pointer) value" );

	dr_multimap<test*,test*>	r1 = {{ &t1, &t1 }, { &t2, &t2 }};
	dr_multimap<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	dr_multimap<test*,test*>	r3 = {{ &t1, &t1 }, { &t3, &t3 }, { &t2, &t2 }};
	dr_multimap<test*,test*>	r4 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	dr_multimap<test*,test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test5D()
{
	this->set_subtitle( "relational operators, reference pointer(pointer) key - deep pointer(pointer) value" );

	rd_multimap<test*,test*>	r1 = {{ &t1, &t1 }, { &t2, &t2 }};
	rd_multimap<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	rd_multimap<test*,test*>	r3 = {{ &t1, &t1 }, { &t3, &t3 }, { &t2, &t2 }};
	rd_multimap<test*,test*>	r4 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	rd_multimap<test*,test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test5E()
{
	this->set_subtitle( "relational operators, deep pointer(pointer) key - deep pointer(pointer) value" );

	dd_multimap<test*,test*>	r1 = {{ &t1, &t1 }, { &t2, &t2 }};
	dd_multimap<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	dd_multimap<test*,test*>	r3 = {{ &t1, &t1 }, { &t3, &t3 }, { &t2, &t2 }};
	dd_multimap<test*,test*>	r4 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	dd_multimap<test*,test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test5F()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - reference pointer(c-string) value" );

	rr_multimap<const char[],const char[]>	r1 = {{ s1, s1 }, { s2, s2 }};
	rr_multimap<const char[],const char[]>	r2 = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	rr_multimap<const char[],const char[]>	r3 = {{ s1, s1 }, { s3, s3 }, { s2, s2 }};
	rr_multimap<const char[],const char[]>	r4 = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	rr_multimap<const char[],const char[]>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test60()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - deep pointer(c-string) value" );

	rd_multimap<const char[],const char[]>	r1 = {{ s1, s1 }, { s2, s2 }};
	rd_multimap<const char[],const char[]>	r2 = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	rd_multimap<const char[],const char[]>	r3 = {{ s1, s1 }, { s3, s3 }, { s2, s2 }};
	rd_multimap<const char[],const char[]>	r4 = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	rd_multimap<const char[],const char[]>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test61()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - reference pointer(v-array) value" );

	rr_multimap<const char[],test[]>	r1 = {{ s1, v1 }, { s2, v2 }};
	rr_multimap<const char[],test[]>	r2 = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	rr_multimap<const char[],test[]>	r3 = {{ s1, v1 }, { s3, v3 }, { s2, v2 }};
	rr_multimap<const char[],test[]>	r4 = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	rr_multimap<const char[],test[]>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test62()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - deep pointer(v-array) value" );

	rd_multimap<const char[],test[]>	r1 = {{ s1, v1 }, { s2, v2 }};
	rd_multimap<const char[],test[]>	r2 = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	rd_multimap<const char[],test[]>	r3 = {{ s1, v1 }, { s3, v3 }, { s2, v2 }};
	rd_multimap<const char[],test[]>	r4 = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	rd_multimap<const char[],test[]>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test63()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - reference pointer(f-array) value" );

	rr_multimap<const char[],test[3]>	r1 = {{ s1, w1 }, { s2, w2 }};
	rr_multimap<const char[],test[3]>	r2 = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	rr_multimap<const char[],test[3]>	r3 = {{ s1, w1 }, { s3, w3 }, { s2, w2 }};
	rr_multimap<const char[],test[3]>	r4 = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	rr_multimap<const char[],test[3]>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test64()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - deep pointer(f-array) value" );

	rd_multimap<const char[],test[3]>	r1 = {{ s1, w1 }, { s2, w2 }};
	rd_multimap<const char[],test[3]>	r2 = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	rd_multimap<const char[],test[3]>	r3 = {{ s1, w1 }, { s3, w3 }, { s2, w2 }};
	rd_multimap<const char[],test[3]>	r4 = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	rd_multimap<const char[],test[3]>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test65()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - data(int value) value" );

	rn_multimap<const char[],int>	r1 = {{ s1, 1 }, { s2, 2 }};
	rn_multimap<const char[],int>	r2 = {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }};
	rn_multimap<const char[],int>	r3 = {{ s1, 1 }, { s3, 3 }, { s2, 2 }};
	rn_multimap<const char[],int>	r4 = {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }};
	rn_multimap<const char[],int>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test66()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - deep pointer(pointer) value" );

	rd_multimap<const char[],test*>	r1 = {{ s1, &t1 }, { s2, &t2 }};
	rd_multimap<const char[],test*>	r2 = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	rd_multimap<const char[],test*>	r3 = {{ s1, &t1 }, { s3, &t3 }, { s2, &t2 }};
	rd_multimap<const char[],test*>	r4 = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	rd_multimap<const char[],test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test67()
{
	this->set_subtitle( "relational operators, deep pointer(c-string) key - deep pointer(pointer) value" );

	dd_multimap<const char[],test*>	r1 = {{ s1, &t1 }, { s2, &t2 }};
	dd_multimap<const char[],test*>	r2 = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	dd_multimap<const char[],test*>	r3 = {{ s1, &t1 }, { s3, &t3 }, { s2, &t2 }};
	dd_multimap<const char[],test*>	r4 = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	dd_multimap<const char[],test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test68()
{
	this->set_subtitle( "relational operators, reference pointer(v-array) key - deep pointer(pointer) value" );

	rd_multimap<test[],test*>	r1 = {{ v1, &t1 }, { v2, &t2 }};
	rd_multimap<test[],test*>	r2 = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	rd_multimap<test[],test*>	r3 = {{ v1, &t1 }, { v3, &t3 }, { v2, &t2 }};
	rd_multimap<test[],test*>	r4 = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	rd_multimap<test[],test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test69()
{
	this->set_subtitle( "relational operators, deep pointer(v-array) key - deep pointer(pointer) value" );

	dd_multimap<test[],test*>	r1 = {{ v1, &t1 }, { v2, &t2 }};
	dd_multimap<test[],test*>	r2 = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	dd_multimap<test[],test*>	r3 = {{ v1, &t1 }, { v3, &t3 }, { v2, &t2 }};
	dd_multimap<test[],test*>	r4 = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	dd_multimap<test[],test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test6A()
{
	this->set_subtitle( "relational operators, reference pointer(f-array) key - deep pointer(pointer) value" );

	rd_multimap<test[3],test*>	r1 = {{ w1, &t1 }, { w2, &t2 }};
	rd_multimap<test[3],test*>	r2 = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	rd_multimap<test[3],test*>	r3 = {{ w1, &t1 }, { w3, &t3 }, { w2, &t2 }};
	rd_multimap<test[3],test*>	r4 = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	rd_multimap<test[3],test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test6B()
{
	this->set_subtitle( "relational operators, deep pointer(f-array) key - deep pointer(pointer) value" );

	dd_multimap<test[3],test*>	r1 = {{ w1, &t1 }, { w2, &t2 }};
	dd_multimap<test[3],test*>	r2 = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	dd_multimap<test[3],test*>	r3 = {{ w1, &t1 }, { w3, &t3 }, { w2, &t2 }};
	dd_multimap<test[3],test*>	r4 = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	dd_multimap<test[3],test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_multimaptest::test6C()
{
	this->set_subtitle( "relational operators, data(int value) key - deep pointer(pointer) value" );

	nd_multimap<int,test*>	r1 = {{ 1, &t1 }, { 2, &t2 }};
	nd_multimap<int,test*>	r2 = {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }};
	nd_multimap<int,test*>	r3 = {{ 1, &t1 }, { 3, &t3 }, { 2, &t2 }};
	nd_multimap<int,test*>	r4 = {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }};
	nd_multimap<int,test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// Main
// -----------------------------------------------------------------------------
int main( int argc, char** argv )
{
	dp_multimaptest( argc, argv ).run();
	return 0;
}

//
// dp_maptest.cpp test
//
//		generated by gendptest, 2018/12/21
//

#include <dptl/dp_map.hpp>
#include <dptl/utest.hpp>
#include <dptl/udata.hpp>
#include <cstring>

using namespace dptl;

// Unit Test Classes
// -----------------------------------------------------------------------------
class dp_maptest : public unittest, public basic_testdata
{
	int		m_cnt;

    public:
	// --- constructor/assignment/destructor ---
	void test01();
	void test02();
	void test03();
	void test04();
	void test05();
	void test06();
	void test07();
	void test08();
	void test09();
	void test0A();
	void test0B();
	void test0C();
	void test0D();
	void test0E();
	void test0F();
	void test10();
	void test11();
	void test12();

	// --- at/operator[]/find/lower_bound/upper_bound/equal_range ---
	void test13();
	void test14();
	void test15();
	void test16();
	void test17();
	void test18();
	void test19();
	void test1A();
	void test1B();
	void test1C();
	void test1D();
	void test1E();
	void test1F();
	void test20();
	void test21();
	void test22();
	void test23();
	void test24();

	// --- emplace/insert/erase ---
	void test25();
	void test26();
	void test27();
	void test28();
	void test29();
	void test2A();
	void test2B();
	void test2C();
	void test2D();
	void test2E();
	void test2F();
	void test30();
	void test31();
	void test32();
	void test33();
	void test34();
	void test35();
	void test36();

	// --- iterator ---
	void test37();
	void test38();
	void test39();
	void test3A();
	void test3B();
	void test3C();
	void test3D();
	void test3E();
	void test3F();
	void test40();
	void test41();
	void test42();
	void test43();
	void test44();
	void test45();
	void test46();
	void test47();
	void test48();

	// --- miscellaneous (swap/count/size/empty/clear) ---
	void test49();
	void test4A();
	void test4B();
	void test4C();
	void test4D();
	void test4E();
	void test4F();
	void test50();
	void test51();
	void test52();
	void test53();
	void test54();
	void test55();
	void test56();
	void test57();
	void test58();
	void test59();
	void test5A();

	// --- relational operators ---
	void test5B();
	void test5C();
	void test5D();
	void test5E();
	void test5F();
	void test60();
	void test61();
	void test62();
	void test63();
	void test64();
	void test65();
	void test66();
	void test67();
	void test68();
	void test69();
	void test6A();
	void test6B();
	void test6C();

	dp_maptest( int argc, char** argv ) : unittest( argc, argv )
	{
		m_cnt = test::getCntr();
		fprintf( stderr, "*** test::getCntr() : %d\n", m_cnt );
	}

	~dp_maptest()
	{
		this->set_subtitle( "test class allocation" );
		AssertEqual( m_cnt, test::getCntr() );
		fprintf( stderr, "\n" );
	}
};

#include <dptl/dp_map.hpp>

// Testdata Check Utilities
// -----------------------------------------------------------------------------
template <typename K, typename T>
inline bool check_map( __dp_map<K,T> const& ls,
		       std::initializer_list<typename __dp_map<K,T>::value_pointer> const& ts )
{
	std::map<dp_const_pointer<K>,dp_pointer<T>>	l;

	for ( auto a : ts ) l.emplace( a.first, a.second );

	return ls == reinterpret_cast<__dp_map<K,T> const&>( l );
}

// -----------------------------------------------------------------------------
void dp_maptest::test01()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(pointer) key - reference pointer(pointer) value" );

	// default constructor
	drr_map<test*,test*>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	drr_map<test*,test*>	p0( lr );
	const drr_map<test*,test*>	c0( lr );
	lr.emplace( &t1, &t1 );
	drr_map<test*,test*>	p1( lr );
	const drr_map<test*,test*>	c1( lr );
	lr.emplace( &t2, &t2 );
	lr.emplace( &t3, &t3 );
	lr.emplace( &t4, &t4 );
	lr.emplace( &t5, &t5 );
	drr_map<test*,test*>	p5( lr );
	const drr_map<test*,test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ &t1, &t1 }} ));
	AssertTrue( check_map( p5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ &t1, &t1 }} ));
	AssertTrue( check_map( c5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));

	// move constructor
	{
		drr_map<test*,test*>   lx = lr;
		drr_map<test*,test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// copy assignment operator
	{
		drr_map<test*,test*>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ &t1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// move assignment operator
	{
		drr_map<test*,test*>   lx;

		lr = p1;
		lx = drr_map<test*,test*>( {{ &t5, &t5 }, { &t3, &t3 }, { &t2, &t2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ &t5, &t5 }, { &t3, &t3 }, { &t2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ &t1, &t1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		drr_map<test*,test*>   lx = p5;
		drr_map<test*,test*>::iterator	i = lx.find( &t4 );

		drr_map<test*,test*>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }} ));
		drr_map<test*,test*>   x0( i, i );
		AssertTrue( x0.empty());
		drr_map<test*,test*>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ &t4, &t4 }, { &t5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		drr_map<test*,test*>   lx = p5;
		drr_map<test*,test*>   x0 { };
		drr_map<test*,test*>   x1 {{ &t1, &t1 }};
		drr_map<test*,test*>   x5 {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ &t1, &t1 }} ));
		AssertTrue( check_map( x5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ &t1, &t1 }};
		AssertTrue( check_map( lx, {{ &t1, &t1 }} ));
		lx = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }};
		AssertTrue( check_map( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test02()
{
	this->set_subtitle( "constructor/assignment/destructor, deep pointer(pointer) key - reference pointer(pointer) value" );

	// default constructor
	dpr_map<test*,test*>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	dpr_map<test*,test*>	p0( lr );
	const dpr_map<test*,test*>	c0( lr );
	lr.emplace( dpl( &t1 ), &t1 );
	dpr_map<test*,test*>	p1( lr );
	const dpr_map<test*,test*>	c1( lr );
	lr.emplace( dpl( &t2 ), &t2 );
	lr.emplace( dpl( &t3 ), &t3 );
	lr.emplace( dpl( &t4 ), &t4 );
	lr.emplace( dpl( &t5 ), &t5 );
	dpr_map<test*,test*>	p5( lr );
	const dpr_map<test*,test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ &t1, &t1 }} ));
	AssertTrue( check_map( p5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ &t1, &t1 }} ));
	AssertTrue( check_map( c5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));

	// move constructor
	{
		dpr_map<test*,test*>   lx = lr;
		dpr_map<test*,test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// copy assignment operator
	{
		dpr_map<test*,test*>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ &t1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// move assignment operator
	{
		dpr_map<test*,test*>   lx;

		lr = p1;
		lx = dpr_map<test*,test*>( {{ &t5, &t5 }, { &t3, &t3 }, { &t2, &t2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ &t5, &t5 }, { &t3, &t3 }, { &t2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ &t1, &t1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		dpr_map<test*,test*>   lx = p5;
		dpr_map<test*,test*>::iterator	i = lx.find( &t4 );

		dpr_map<test*,test*>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }} ));
		dpr_map<test*,test*>   x0( i, i );
		AssertTrue( x0.empty());
		dpr_map<test*,test*>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ &t4, &t4 }, { &t5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		dpr_map<test*,test*>   lx = p5;
		dpr_map<test*,test*>   x0 { };
		dpr_map<test*,test*>   x1 {{ &t1, &t1 }};
		dpr_map<test*,test*>   x5 {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ &t1, &t1 }} ));
		AssertTrue( check_map( x5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ &t1, &t1 }};
		AssertTrue( check_map( lx, {{ &t1, &t1 }} ));
		lx = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }};
		AssertTrue( check_map( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test03()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(pointer) key - deep pointer(pointer) value" );

	// default constructor
	drp_map<test*,test*>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	drp_map<test*,test*>	p0( lr );
	const drp_map<test*,test*>	c0( lr );
	lr.emplace( &t1, dpl( &t1 ) );
	drp_map<test*,test*>	p1( lr );
	const drp_map<test*,test*>	c1( lr );
	lr.emplace( &t2, dpl( &t2 ) );
	lr.emplace( &t3, dpl( &t3 ) );
	lr.emplace( &t4, dpl( &t4 ) );
	lr.emplace( &t5, dpl( &t5 ) );
	drp_map<test*,test*>	p5( lr );
	const drp_map<test*,test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ &t1, &t1 }} ));
	AssertTrue( check_map( p5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ &t1, &t1 }} ));
	AssertTrue( check_map( c5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));

	// move constructor
	{
		drp_map<test*,test*>   lx = lr;
		drp_map<test*,test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// copy assignment operator
	{
		drp_map<test*,test*>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ &t1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// move assignment operator
	{
		drp_map<test*,test*>   lx;

		lr = p1;
		lx = drp_map<test*,test*>( {{ &t5, &t5 }, { &t3, &t3 }, { &t2, &t2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ &t5, &t5 }, { &t3, &t3 }, { &t2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ &t1, &t1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		drp_map<test*,test*>   lx = p5;
		drp_map<test*,test*>::iterator	i = lx.find( &t4 );

		drp_map<test*,test*>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }} ));
		drp_map<test*,test*>   x0( i, i );
		AssertTrue( x0.empty());
		drp_map<test*,test*>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ &t4, &t4 }, { &t5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		drp_map<test*,test*>   lx = p5;
		drp_map<test*,test*>   x0 { };
		drp_map<test*,test*>   x1 {{ &t1, &t1 }};
		drp_map<test*,test*>   x5 {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ &t1, &t1 }} ));
		AssertTrue( check_map( x5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ &t1, &t1 }};
		AssertTrue( check_map( lx, {{ &t1, &t1 }} ));
		lx = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }};
		AssertTrue( check_map( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test04()
{
	this->set_subtitle( "constructor/assignment/destructor, deep pointer(pointer) key - deep pointer(pointer) value" );

	// default constructor
	dpp_map<test*,test*>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	dpp_map<test*,test*>	p0( lr );
	const dpp_map<test*,test*>	c0( lr );
	lr.emplace( dpl( &t1 ), dpl( &t1 ) );
	dpp_map<test*,test*>	p1( lr );
	const dpp_map<test*,test*>	c1( lr );
	lr.emplace( dpl( &t2 ), dpl( &t2 ) );
	lr.emplace( dpl( &t3 ), dpl( &t3 ) );
	lr.emplace( dpl( &t4 ), dpl( &t4 ) );
	lr.emplace( dpl( &t5 ), dpl( &t5 ) );
	dpp_map<test*,test*>	p5( lr );
	const dpp_map<test*,test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ &t1, &t1 }} ));
	AssertTrue( check_map( p5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ &t1, &t1 }} ));
	AssertTrue( check_map( c5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));

	// move constructor
	{
		dpp_map<test*,test*>   lx = lr;
		dpp_map<test*,test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// copy assignment operator
	{
		dpp_map<test*,test*>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ &t1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
	// move assignment operator
	{
		dpp_map<test*,test*>   lx;

		lr = p1;
		lx = dpp_map<test*,test*>( {{ &t5, &t5 }, { &t3, &t3 }, { &t2, &t2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ &t5, &t5 }, { &t3, &t3 }, { &t2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ &t1, &t1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		dpp_map<test*,test*>   lx = p5;
		dpp_map<test*,test*>::iterator	i = lx.find( &t4 );

		dpp_map<test*,test*>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }} ));
		dpp_map<test*,test*>   x0( i, i );
		AssertTrue( x0.empty());
		dpp_map<test*,test*>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ &t4, &t4 }, { &t5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		dpp_map<test*,test*>   lx = p5;
		dpp_map<test*,test*>   x0 { };
		dpp_map<test*,test*>   x1 {{ &t1, &t1 }};
		dpp_map<test*,test*>   x5 {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ &t1, &t1 }} ));
		AssertTrue( check_map( x5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ &t1, &t1 }};
		AssertTrue( check_map( lx, {{ &t1, &t1 }} ));
		lx = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }};
		AssertTrue( check_map( lx, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test05()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - reference pointer(c-string) value" );

	// default constructor
	drr_map<const char[],const char[]>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	drr_map<const char[],const char[]>	p0( lr );
	const drr_map<const char[],const char[]>	c0( lr );
	lr.emplace( s1, s1 );
	drr_map<const char[],const char[]>	p1( lr );
	const drr_map<const char[],const char[]>	c1( lr );
	lr.emplace( s2, s2 );
	lr.emplace( s3, s3 );
	lr.emplace( s4, s4 );
	lr.emplace( s5, s5 );
	drr_map<const char[],const char[]>	p5( lr );
	const drr_map<const char[],const char[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ s1, s1 }} ));
	AssertTrue( check_map( p5, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ s1, s1 }} ));
	AssertTrue( check_map( c5, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));

	// move constructor
	{
		drr_map<const char[],const char[]>   lx = lr;
		drr_map<const char[],const char[]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));
	}
	// copy assignment operator
	{
		drr_map<const char[],const char[]>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ s1, s1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));
	}
	// move assignment operator
	{
		drr_map<const char[],const char[]>   lx;

		lr = p1;
		lx = drr_map<const char[],const char[]>( {{ s5, s5 }, { s3, s3 }, { s2, s2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ s5, s5 }, { s3, s3 }, { s2, s2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ s1, s1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		drr_map<const char[],const char[]>   lx = p5;
		drr_map<const char[],const char[]>::iterator	i = lx.find( s4 );

		drr_map<const char[],const char[]>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ s1, s1 }, { s2, s2 }, { s3, s3 }} ));
		drr_map<const char[],const char[]>   x0( i, i );
		AssertTrue( x0.empty());
		drr_map<const char[],const char[]>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ s4, s4 }, { s5, s5 }} ));
	}
	// initializer constructor/assignment operator
	{
		drr_map<const char[],const char[]>   lx = p5;
		drr_map<const char[],const char[]>   x0 { };
		drr_map<const char[],const char[]>   x1 {{ s1, s1 }};
		drr_map<const char[],const char[]>   x5 {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ s1, s1 }} ));
		AssertTrue( check_map( x5, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, s1 }};
		AssertTrue( check_map( lx, {{ s1, s1 }} ));
		lx = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }};
		AssertTrue( check_map( lx, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test06()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - deep pointer(c-string) value" );

	// default constructor
	drp_map<const char[],const char[]>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	drp_map<const char[],const char[]>	p0( lr );
	const drp_map<const char[],const char[]>	c0( lr );
	lr.emplace( s1, strdup( s1 ) );
	drp_map<const char[],const char[]>	p1( lr );
	const drp_map<const char[],const char[]>	c1( lr );
	lr.emplace( s2, strdup( s2 ) );
	lr.emplace( s3, strdup( s3 ) );
	lr.emplace( s4, strdup( s4 ) );
	lr.emplace( s5, strdup( s5 ) );
	drp_map<const char[],const char[]>	p5( lr );
	const drp_map<const char[],const char[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ s1, s1 }} ));
	AssertTrue( check_map( p5, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ s1, s1 }} ));
	AssertTrue( check_map( c5, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));

	// move constructor
	{
		drp_map<const char[],const char[]>   lx = lr;
		drp_map<const char[],const char[]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));
	}
	// copy assignment operator
	{
		drp_map<const char[],const char[]>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ s1, s1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));
	}
	// move assignment operator
	{
		drp_map<const char[],const char[]>   lx;

		lr = p1;
		lx = drp_map<const char[],const char[]>( {{ s5, s5 }, { s3, s3 }, { s2, s2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ s5, s5 }, { s3, s3 }, { s2, s2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ s1, s1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		drp_map<const char[],const char[]>   lx = p5;
		drp_map<const char[],const char[]>::iterator	i = lx.find( s4 );

		drp_map<const char[],const char[]>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ s1, s1 }, { s2, s2 }, { s3, s3 }} ));
		drp_map<const char[],const char[]>   x0( i, i );
		AssertTrue( x0.empty());
		drp_map<const char[],const char[]>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ s4, s4 }, { s5, s5 }} ));
	}
	// initializer constructor/assignment operator
	{
		drp_map<const char[],const char[]>   lx = p5;
		drp_map<const char[],const char[]>   x0 { };
		drp_map<const char[],const char[]>   x1 {{ s1, s1 }};
		drp_map<const char[],const char[]>   x5 {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ s1, s1 }} ));
		AssertTrue( check_map( x5, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, s1 }};
		AssertTrue( check_map( lx, {{ s1, s1 }} ));
		lx = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }};
		AssertTrue( check_map( lx, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }, { s5, s5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test07()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - reference pointer(v-array) value" );

	// default constructor
	drr_map<const char[],test[]>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	drr_map<const char[],test[]>	p0( lr );
	const drr_map<const char[],test[]>	c0( lr );
	lr.emplace( s1, v1 );
	drr_map<const char[],test[]>	p1( lr );
	const drr_map<const char[],test[]>	c1( lr );
	lr.emplace( s2, v2 );
	lr.emplace( s3, v3 );
	lr.emplace( s4, v4 );
	lr.emplace( s5, v5 );
	drr_map<const char[],test[]>	p5( lr );
	const drr_map<const char[],test[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ s1, v1 }} ));
	AssertTrue( check_map( p5, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ s1, v1 }} ));
	AssertTrue( check_map( c5, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));

	// move constructor
	{
		drr_map<const char[],test[]>   lx = lr;
		drr_map<const char[],test[]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));
	}
	// copy assignment operator
	{
		drr_map<const char[],test[]>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ s1, v1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));
	}
	// move assignment operator
	{
		drr_map<const char[],test[]>   lx;

		lr = p1;
		lx = drr_map<const char[],test[]>( {{ s5, v5 }, { s3, v3 }, { s2, v2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ s5, v5 }, { s3, v3 }, { s2, v2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ s1, v1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		drr_map<const char[],test[]>   lx = p5;
		drr_map<const char[],test[]>::iterator	i = lx.find( s4 );

		drr_map<const char[],test[]>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ s1, v1 }, { s2, v2 }, { s3, v3 }} ));
		drr_map<const char[],test[]>   x0( i, i );
		AssertTrue( x0.empty());
		drr_map<const char[],test[]>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ s4, v4 }, { s5, v5 }} ));
	}
	// initializer constructor/assignment operator
	{
		drr_map<const char[],test[]>   lx = p5;
		drr_map<const char[],test[]>   x0 { };
		drr_map<const char[],test[]>   x1 {{ s1, v1 }};
		drr_map<const char[],test[]>   x5 {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ s1, v1 }} ));
		AssertTrue( check_map( x5, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, v1 }};
		AssertTrue( check_map( lx, {{ s1, v1 }} ));
		lx = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }};
		AssertTrue( check_map( lx, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test08()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - deep pointer(v-array) value" );

	// default constructor
	drp_map<const char[],test[]>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	drp_map<const char[],test[]>	p0( lr );
	const drp_map<const char[],test[]>	c0( lr );
	lr.emplace( s1, dpl( v1 ) );
	drp_map<const char[],test[]>	p1( lr );
	const drp_map<const char[],test[]>	c1( lr );
	lr.emplace( s2, dpl( v2 ) );
	lr.emplace( s3, dpl( v3 ) );
	lr.emplace( s4, dpl( v4 ) );
	lr.emplace( s5, dpl( v5 ) );
	drp_map<const char[],test[]>	p5( lr );
	const drp_map<const char[],test[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ s1, v1 }} ));
	AssertTrue( check_map( p5, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ s1, v1 }} ));
	AssertTrue( check_map( c5, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));

	// move constructor
	{
		drp_map<const char[],test[]>   lx = lr;
		drp_map<const char[],test[]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));
	}
	// copy assignment operator
	{
		drp_map<const char[],test[]>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ s1, v1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));
	}
	// move assignment operator
	{
		drp_map<const char[],test[]>   lx;

		lr = p1;
		lx = drp_map<const char[],test[]>( {{ s5, v5 }, { s3, v3 }, { s2, v2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ s5, v5 }, { s3, v3 }, { s2, v2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ s1, v1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		drp_map<const char[],test[]>   lx = p5;
		drp_map<const char[],test[]>::iterator	i = lx.find( s4 );

		drp_map<const char[],test[]>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ s1, v1 }, { s2, v2 }, { s3, v3 }} ));
		drp_map<const char[],test[]>   x0( i, i );
		AssertTrue( x0.empty());
		drp_map<const char[],test[]>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ s4, v4 }, { s5, v5 }} ));
	}
	// initializer constructor/assignment operator
	{
		drp_map<const char[],test[]>   lx = p5;
		drp_map<const char[],test[]>   x0 { };
		drp_map<const char[],test[]>   x1 {{ s1, v1 }};
		drp_map<const char[],test[]>   x5 {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ s1, v1 }} ));
		AssertTrue( check_map( x5, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, v1 }};
		AssertTrue( check_map( lx, {{ s1, v1 }} ));
		lx = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }};
		AssertTrue( check_map( lx, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }, { s5, v5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test09()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - reference pointer(f-array) value" );

	// default constructor
	drr_map<const char[],test[3]>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	drr_map<const char[],test[3]>	p0( lr );
	const drr_map<const char[],test[3]>	c0( lr );
	lr.emplace( s1, w1 );
	drr_map<const char[],test[3]>	p1( lr );
	const drr_map<const char[],test[3]>	c1( lr );
	lr.emplace( s2, w2 );
	lr.emplace( s3, w3 );
	lr.emplace( s4, w4 );
	lr.emplace( s5, w5 );
	drr_map<const char[],test[3]>	p5( lr );
	const drr_map<const char[],test[3]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ s1, w1 }} ));
	AssertTrue( check_map( p5, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ s1, w1 }} ));
	AssertTrue( check_map( c5, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));

	// move constructor
	{
		drr_map<const char[],test[3]>   lx = lr;
		drr_map<const char[],test[3]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));
	}
	// copy assignment operator
	{
		drr_map<const char[],test[3]>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ s1, w1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));
	}
	// move assignment operator
	{
		drr_map<const char[],test[3]>   lx;

		lr = p1;
		lx = drr_map<const char[],test[3]>( {{ s5, w5 }, { s3, w3 }, { s2, w2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ s5, w5 }, { s3, w3 }, { s2, w2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ s1, w1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		drr_map<const char[],test[3]>   lx = p5;
		drr_map<const char[],test[3]>::iterator	i = lx.find( s4 );

		drr_map<const char[],test[3]>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ s1, w1 }, { s2, w2 }, { s3, w3 }} ));
		drr_map<const char[],test[3]>   x0( i, i );
		AssertTrue( x0.empty());
		drr_map<const char[],test[3]>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ s4, w4 }, { s5, w5 }} ));
	}
	// initializer constructor/assignment operator
	{
		drr_map<const char[],test[3]>   lx = p5;
		drr_map<const char[],test[3]>   x0 { };
		drr_map<const char[],test[3]>   x1 {{ s1, w1 }};
		drr_map<const char[],test[3]>   x5 {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ s1, w1 }} ));
		AssertTrue( check_map( x5, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, w1 }};
		AssertTrue( check_map( lx, {{ s1, w1 }} ));
		lx = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }};
		AssertTrue( check_map( lx, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test0A()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - deep pointer(f-array) value" );

	// default constructor
	drp_map<const char[],test[3]>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	drp_map<const char[],test[3]>	p0( lr );
	const drp_map<const char[],test[3]>	c0( lr );
	lr.emplace( s1, dpl( w1 ) );
	drp_map<const char[],test[3]>	p1( lr );
	const drp_map<const char[],test[3]>	c1( lr );
	lr.emplace( s2, dpl( w2 ) );
	lr.emplace( s3, dpl( w3 ) );
	lr.emplace( s4, dpl( w4 ) );
	lr.emplace( s5, dpl( w5 ) );
	drp_map<const char[],test[3]>	p5( lr );
	const drp_map<const char[],test[3]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ s1, w1 }} ));
	AssertTrue( check_map( p5, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ s1, w1 }} ));
	AssertTrue( check_map( c5, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));

	// move constructor
	{
		drp_map<const char[],test[3]>   lx = lr;
		drp_map<const char[],test[3]>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));
	}
	// copy assignment operator
	{
		drp_map<const char[],test[3]>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ s1, w1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));
	}
	// move assignment operator
	{
		drp_map<const char[],test[3]>   lx;

		lr = p1;
		lx = drp_map<const char[],test[3]>( {{ s5, w5 }, { s3, w3 }, { s2, w2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ s5, w5 }, { s3, w3 }, { s2, w2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ s1, w1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		drp_map<const char[],test[3]>   lx = p5;
		drp_map<const char[],test[3]>::iterator	i = lx.find( s4 );

		drp_map<const char[],test[3]>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ s1, w1 }, { s2, w2 }, { s3, w3 }} ));
		drp_map<const char[],test[3]>   x0( i, i );
		AssertTrue( x0.empty());
		drp_map<const char[],test[3]>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ s4, w4 }, { s5, w5 }} ));
	}
	// initializer constructor/assignment operator
	{
		drp_map<const char[],test[3]>   lx = p5;
		drp_map<const char[],test[3]>   x0 { };
		drp_map<const char[],test[3]>   x1 {{ s1, w1 }};
		drp_map<const char[],test[3]>   x5 {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ s1, w1 }} ));
		AssertTrue( check_map( x5, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, w1 }};
		AssertTrue( check_map( lx, {{ s1, w1 }} ));
		lx = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }};
		AssertTrue( check_map( lx, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }, { s5, w5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test0B()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - data(int value) value" );

	// default constructor
	drn_map<const char[],int>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	drn_map<const char[],int>	p0( lr );
	const drn_map<const char[],int>	c0( lr );
	lr.emplace( s1, 1 );
	drn_map<const char[],int>	p1( lr );
	const drn_map<const char[],int>	c1( lr );
	lr.emplace( s2, 2 );
	lr.emplace( s3, 3 );
	lr.emplace( s4, 4 );
	lr.emplace( s5, 5 );
	drn_map<const char[],int>	p5( lr );
	const drn_map<const char[],int>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ s1, 1 }} ));
	AssertTrue( check_map( p5, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s4, 4 }, { s5, 5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ s1, 1 }} ));
	AssertTrue( check_map( c5, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s4, 4 }, { s5, 5 }} ));

	// move constructor
	{
		drn_map<const char[],int>   lx = lr;
		drn_map<const char[],int>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s4, 4 }, { s5, 5 }} ));
	}
	// copy assignment operator
	{
		drn_map<const char[],int>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ s1, 1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s4, 4 }, { s5, 5 }} ));
	}
	// move assignment operator
	{
		drn_map<const char[],int>   lx;

		lr = p1;
		lx = drn_map<const char[],int>( {{ s5, 5 }, { s3, 3 }, { s2, 2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ s5, 5 }, { s3, 3 }, { s2, 2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ s1, 1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		drn_map<const char[],int>   lx = p5;
		drn_map<const char[],int>::iterator	i = lx.find( s4 );

		drn_map<const char[],int>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ s1, 1 }, { s2, 2 }, { s3, 3 }} ));
		drn_map<const char[],int>   x0( i, i );
		AssertTrue( x0.empty());
		drn_map<const char[],int>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ s4, 4 }, { s5, 5 }} ));
	}
	// initializer constructor/assignment operator
	{
		drn_map<const char[],int>   lx = p5;
		drn_map<const char[],int>   x0 { };
		drn_map<const char[],int>   x1 {{ s1, 1 }};
		drn_map<const char[],int>   x5 {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s4, 4 }, { s5, 5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ s1, 1 }} ));
		AssertTrue( check_map( x5, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s4, 4 }, { s5, 5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, 1 }};
		AssertTrue( check_map( lx, {{ s1, 1 }} ));
		lx = {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s4, 4 }, { s5, 5 }};
		AssertTrue( check_map( lx, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s4, 4 }, { s5, 5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test0C()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(c-string) key - deep pointer(pointer) value" );

	// default constructor
	drp_map<const char[],test*>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	drp_map<const char[],test*>	p0( lr );
	const drp_map<const char[],test*>	c0( lr );
	lr.emplace( s1, dpl( &t1 ) );
	drp_map<const char[],test*>	p1( lr );
	const drp_map<const char[],test*>	c1( lr );
	lr.emplace( s2, dpl( &t2 ) );
	lr.emplace( s3, dpl( &t3 ) );
	lr.emplace( s4, dpl( &t4 ) );
	lr.emplace( s5, dpl( &t5 ) );
	drp_map<const char[],test*>	p5( lr );
	const drp_map<const char[],test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ s1, &t1 }} ));
	AssertTrue( check_map( p5, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ s1, &t1 }} ));
	AssertTrue( check_map( c5, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));

	// move constructor
	{
		drp_map<const char[],test*>   lx = lr;
		drp_map<const char[],test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));
	}
	// copy assignment operator
	{
		drp_map<const char[],test*>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ s1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));
	}
	// move assignment operator
	{
		drp_map<const char[],test*>   lx;

		lr = p1;
		lx = drp_map<const char[],test*>( {{ s5, &t5 }, { s3, &t3 }, { s2, &t2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ s5, &t5 }, { s3, &t3 }, { s2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ s1, &t1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		drp_map<const char[],test*>   lx = p5;
		drp_map<const char[],test*>::iterator	i = lx.find( s4 );

		drp_map<const char[],test*>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }} ));
		drp_map<const char[],test*>   x0( i, i );
		AssertTrue( x0.empty());
		drp_map<const char[],test*>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ s4, &t4 }, { s5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		drp_map<const char[],test*>   lx = p5;
		drp_map<const char[],test*>   x0 { };
		drp_map<const char[],test*>   x1 {{ s1, &t1 }};
		drp_map<const char[],test*>   x5 {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ s1, &t1 }} ));
		AssertTrue( check_map( x5, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, &t1 }};
		AssertTrue( check_map( lx, {{ s1, &t1 }} ));
		lx = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }};
		AssertTrue( check_map( lx, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test0D()
{
	this->set_subtitle( "constructor/assignment/destructor, deep pointer(c-string) key - deep pointer(pointer) value" );

	// default constructor
	dpp_map<const char[],test*>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	dpp_map<const char[],test*>	p0( lr );
	const dpp_map<const char[],test*>	c0( lr );
	lr.emplace( strdup( s1 ), dpl( &t1 ) );
	dpp_map<const char[],test*>	p1( lr );
	const dpp_map<const char[],test*>	c1( lr );
	lr.emplace( strdup( s2 ), dpl( &t2 ) );
	lr.emplace( strdup( s3 ), dpl( &t3 ) );
	lr.emplace( strdup( s4 ), dpl( &t4 ) );
	lr.emplace( strdup( s5 ), dpl( &t5 ) );
	dpp_map<const char[],test*>	p5( lr );
	const dpp_map<const char[],test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ s1, &t1 }} ));
	AssertTrue( check_map( p5, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ s1, &t1 }} ));
	AssertTrue( check_map( c5, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));

	// move constructor
	{
		dpp_map<const char[],test*>   lx = lr;
		dpp_map<const char[],test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));
	}
	// copy assignment operator
	{
		dpp_map<const char[],test*>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ s1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));
	}
	// move assignment operator
	{
		dpp_map<const char[],test*>   lx;

		lr = p1;
		lx = dpp_map<const char[],test*>( {{ s5, &t5 }, { s3, &t3 }, { s2, &t2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ s5, &t5 }, { s3, &t3 }, { s2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ s1, &t1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		dpp_map<const char[],test*>   lx = p5;
		dpp_map<const char[],test*>::iterator	i = lx.find( s4 );

		dpp_map<const char[],test*>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }} ));
		dpp_map<const char[],test*>   x0( i, i );
		AssertTrue( x0.empty());
		dpp_map<const char[],test*>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ s4, &t4 }, { s5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		dpp_map<const char[],test*>   lx = p5;
		dpp_map<const char[],test*>   x0 { };
		dpp_map<const char[],test*>   x1 {{ s1, &t1 }};
		dpp_map<const char[],test*>   x5 {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ s1, &t1 }} ));
		AssertTrue( check_map( x5, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ s1, &t1 }};
		AssertTrue( check_map( lx, {{ s1, &t1 }} ));
		lx = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }};
		AssertTrue( check_map( lx, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test0E()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(v-array) key - deep pointer(pointer) value" );

	// default constructor
	drp_map<test[],test*>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	drp_map<test[],test*>	p0( lr );
	const drp_map<test[],test*>	c0( lr );
	lr.emplace( v1, dpl( &t1 ) );
	drp_map<test[],test*>	p1( lr );
	const drp_map<test[],test*>	c1( lr );
	lr.emplace( v2, dpl( &t2 ) );
	lr.emplace( v3, dpl( &t3 ) );
	lr.emplace( v4, dpl( &t4 ) );
	lr.emplace( v5, dpl( &t5 ) );
	drp_map<test[],test*>	p5( lr );
	const drp_map<test[],test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ v1, &t1 }} ));
	AssertTrue( check_map( p5, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ v1, &t1 }} ));
	AssertTrue( check_map( c5, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));

	// move constructor
	{
		drp_map<test[],test*>   lx = lr;
		drp_map<test[],test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));
	}
	// copy assignment operator
	{
		drp_map<test[],test*>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ v1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));
	}
	// move assignment operator
	{
		drp_map<test[],test*>   lx;

		lr = p1;
		lx = drp_map<test[],test*>( {{ v5, &t5 }, { v3, &t3 }, { v2, &t2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ v5, &t5 }, { v3, &t3 }, { v2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ v1, &t1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		drp_map<test[],test*>   lx = p5;
		drp_map<test[],test*>::iterator	i = lx.find( v4 );

		drp_map<test[],test*>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }} ));
		drp_map<test[],test*>   x0( i, i );
		AssertTrue( x0.empty());
		drp_map<test[],test*>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ v4, &t4 }, { v5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		drp_map<test[],test*>   lx = p5;
		drp_map<test[],test*>   x0 { };
		drp_map<test[],test*>   x1 {{ v1, &t1 }};
		drp_map<test[],test*>   x5 {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ v1, &t1 }} ));
		AssertTrue( check_map( x5, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ v1, &t1 }};
		AssertTrue( check_map( lx, {{ v1, &t1 }} ));
		lx = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }};
		AssertTrue( check_map( lx, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test0F()
{
	this->set_subtitle( "constructor/assignment/destructor, deep pointer(v-array) key - deep pointer(pointer) value" );

	// default constructor
	dpp_map<test[],test*>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	dpp_map<test[],test*>	p0( lr );
	const dpp_map<test[],test*>	c0( lr );
	lr.emplace( dpl( v1 ), dpl( &t1 ) );
	dpp_map<test[],test*>	p1( lr );
	const dpp_map<test[],test*>	c1( lr );
	lr.emplace( dpl( v2 ), dpl( &t2 ) );
	lr.emplace( dpl( v3 ), dpl( &t3 ) );
	lr.emplace( dpl( v4 ), dpl( &t4 ) );
	lr.emplace( dpl( v5 ), dpl( &t5 ) );
	dpp_map<test[],test*>	p5( lr );
	const dpp_map<test[],test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ v1, &t1 }} ));
	AssertTrue( check_map( p5, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ v1, &t1 }} ));
	AssertTrue( check_map( c5, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));

	// move constructor
	{
		dpp_map<test[],test*>   lx = lr;
		dpp_map<test[],test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));
	}
	// copy assignment operator
	{
		dpp_map<test[],test*>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ v1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));
	}
	// move assignment operator
	{
		dpp_map<test[],test*>   lx;

		lr = p1;
		lx = dpp_map<test[],test*>( {{ v5, &t5 }, { v3, &t3 }, { v2, &t2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ v5, &t5 }, { v3, &t3 }, { v2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ v1, &t1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		dpp_map<test[],test*>   lx = p5;
		dpp_map<test[],test*>::iterator	i = lx.find( v4 );

		dpp_map<test[],test*>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }} ));
		dpp_map<test[],test*>   x0( i, i );
		AssertTrue( x0.empty());
		dpp_map<test[],test*>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ v4, &t4 }, { v5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		dpp_map<test[],test*>   lx = p5;
		dpp_map<test[],test*>   x0 { };
		dpp_map<test[],test*>   x1 {{ v1, &t1 }};
		dpp_map<test[],test*>   x5 {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ v1, &t1 }} ));
		AssertTrue( check_map( x5, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ v1, &t1 }};
		AssertTrue( check_map( lx, {{ v1, &t1 }} ));
		lx = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }};
		AssertTrue( check_map( lx, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test10()
{
	this->set_subtitle( "constructor/assignment/destructor, reference pointer(f-array) key - deep pointer(pointer) value" );

	// default constructor
	drp_map<test[3],test*>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	drp_map<test[3],test*>	p0( lr );
	const drp_map<test[3],test*>	c0( lr );
	lr.emplace( w1, dpl( &t1 ) );
	drp_map<test[3],test*>	p1( lr );
	const drp_map<test[3],test*>	c1( lr );
	lr.emplace( w2, dpl( &t2 ) );
	lr.emplace( w3, dpl( &t3 ) );
	lr.emplace( w4, dpl( &t4 ) );
	lr.emplace( w5, dpl( &t5 ) );
	drp_map<test[3],test*>	p5( lr );
	const drp_map<test[3],test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ w1, &t1 }} ));
	AssertTrue( check_map( p5, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ w1, &t1 }} ));
	AssertTrue( check_map( c5, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));

	// move constructor
	{
		drp_map<test[3],test*>   lx = lr;
		drp_map<test[3],test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));
	}
	// copy assignment operator
	{
		drp_map<test[3],test*>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ w1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));
	}
	// move assignment operator
	{
		drp_map<test[3],test*>   lx;

		lr = p1;
		lx = drp_map<test[3],test*>( {{ w5, &t5 }, { w3, &t3 }, { w2, &t2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ w5, &t5 }, { w3, &t3 }, { w2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ w1, &t1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		drp_map<test[3],test*>   lx = p5;
		drp_map<test[3],test*>::iterator	i = lx.find( w4 );

		drp_map<test[3],test*>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }} ));
		drp_map<test[3],test*>   x0( i, i );
		AssertTrue( x0.empty());
		drp_map<test[3],test*>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ w4, &t4 }, { w5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		drp_map<test[3],test*>   lx = p5;
		drp_map<test[3],test*>   x0 { };
		drp_map<test[3],test*>   x1 {{ w1, &t1 }};
		drp_map<test[3],test*>   x5 {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ w1, &t1 }} ));
		AssertTrue( check_map( x5, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ w1, &t1 }};
		AssertTrue( check_map( lx, {{ w1, &t1 }} ));
		lx = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }};
		AssertTrue( check_map( lx, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test11()
{
	this->set_subtitle( "constructor/assignment/destructor, deep pointer(f-array) key - deep pointer(pointer) value" );

	// default constructor
	dpp_map<test[3],test*>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	dpp_map<test[3],test*>	p0( lr );
	const dpp_map<test[3],test*>	c0( lr );
	lr.emplace( dpl( w1 ), dpl( &t1 ) );
	dpp_map<test[3],test*>	p1( lr );
	const dpp_map<test[3],test*>	c1( lr );
	lr.emplace( dpl( w2 ), dpl( &t2 ) );
	lr.emplace( dpl( w3 ), dpl( &t3 ) );
	lr.emplace( dpl( w4 ), dpl( &t4 ) );
	lr.emplace( dpl( w5 ), dpl( &t5 ) );
	dpp_map<test[3],test*>	p5( lr );
	const dpp_map<test[3],test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ w1, &t1 }} ));
	AssertTrue( check_map( p5, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ w1, &t1 }} ));
	AssertTrue( check_map( c5, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));

	// move constructor
	{
		dpp_map<test[3],test*>   lx = lr;
		dpp_map<test[3],test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));
	}
	// copy assignment operator
	{
		dpp_map<test[3],test*>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ w1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));
	}
	// move assignment operator
	{
		dpp_map<test[3],test*>   lx;

		lr = p1;
		lx = dpp_map<test[3],test*>( {{ w5, &t5 }, { w3, &t3 }, { w2, &t2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ w5, &t5 }, { w3, &t3 }, { w2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ w1, &t1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		dpp_map<test[3],test*>   lx = p5;
		dpp_map<test[3],test*>::iterator	i = lx.find( w4 );

		dpp_map<test[3],test*>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }} ));
		dpp_map<test[3],test*>   x0( i, i );
		AssertTrue( x0.empty());
		dpp_map<test[3],test*>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ w4, &t4 }, { w5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		dpp_map<test[3],test*>   lx = p5;
		dpp_map<test[3],test*>   x0 { };
		dpp_map<test[3],test*>   x1 {{ w1, &t1 }};
		dpp_map<test[3],test*>   x5 {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ w1, &t1 }} ));
		AssertTrue( check_map( x5, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ w1, &t1 }};
		AssertTrue( check_map( lx, {{ w1, &t1 }} ));
		lx = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }};
		AssertTrue( check_map( lx, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test12()
{
	this->set_subtitle( "constructor/assignment/destructor, data(int value) key - deep pointer(pointer) value" );

	// default constructor
	dnp_map<int,test*>	lr;
	AssertTrue( check_map( lr, { } ));

	// copy constructor
	dnp_map<int,test*>	p0( lr );
	const dnp_map<int,test*>	c0( lr );
	lr.emplace( 1, dpl( &t1 ) );
	dnp_map<int,test*>	p1( lr );
	const dnp_map<int,test*>	c1( lr );
	lr.emplace( 2, dpl( &t2 ) );
	lr.emplace( 3, dpl( &t3 ) );
	lr.emplace( 4, dpl( &t4 ) );
	lr.emplace( 5, dpl( &t5 ) );
	dnp_map<int,test*>	p5( lr );
	const dnp_map<int,test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_map( p1, {{ 1, &t1 }} ));
	AssertTrue( check_map( p5, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 4, &t4 }, { 5, &t5 }} ));
	AssertTrue( c0.empty());
	AssertTrue( check_map( c1, {{ 1, &t1 }} ));
	AssertTrue( check_map( c5, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 4, &t4 }, { 5, &t5 }} ));

	// move constructor
	{
		dnp_map<int,test*>   lx = lr;
		dnp_map<int,test*>   ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_map( ly, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 4, &t4 }, { 5, &t5 }} ));
	}
	// copy assignment operator
	{
		dnp_map<int,test*>   lx;

		lx = p1;
		AssertTrue( check_map( lx, {{ 1, &t1 }} ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_map( lx, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 4, &t4 }, { 5, &t5 }} ));
	}
	// move assignment operator
	{
		dnp_map<int,test*>   lx;

		lr = p1;
		lx = dnp_map<int,test*>( {{ 5, &t5 }, { 3, &t3 }, { 2, &t2 }} );	// move assignment by r-value
		AssertTrue( check_map( lx, {{ 5, &t5 }, { 3, &t3 }, { 2, &t2 }} ));

		lx = std::move( lr );							// move assignment by std::move()
		AssertTrue( check_map( lx, {{ 1, &t1 }} ));
		AssertTrue( check_map( lr, {} ));					// not mandatory

		lx = std::move( lx );
		AssertTrue( check_map( lx, {} ));					// not mandatory
	}
	// iterator constructor
	{
		dnp_map<int,test*>   lx = p5;
		dnp_map<int,test*>::iterator	i = lx.find( 4 );

		dnp_map<int,test*>   x3( lx.begin(), i );
		AssertTrue( check_map( x3, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }} ));
		dnp_map<int,test*>   x0( i, i );
		AssertTrue( x0.empty());
		dnp_map<int,test*>   x1( i, lx.end());
		AssertTrue( check_map( x1, {{ 4, &t4 }, { 5, &t5 }} ));
	}
	// initializer constructor/assignment operator
	{
		dnp_map<int,test*>   lx = p5;
		dnp_map<int,test*>   x0 { };
		dnp_map<int,test*>   x1 {{ 1, &t1 }};
		dnp_map<int,test*>   x5 {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 4, &t4 }, { 5, &t5 }};

		AssertTrue( x0.empty());
		AssertTrue( check_map( x1, {{ 1, &t1 }} ));
		AssertTrue( check_map( x5, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 4, &t4 }, { 5, &t5 }} ));

		lx = { };
		AssertTrue( lx.empty());
		lx = {{ 1, &t1 }};
		AssertTrue( check_map( lx, {{ 1, &t1 }} ));
		lx = {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 4, &t4 }, { 5, &t5 }};
		AssertTrue( check_map( lx, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 4, &t4 }, { 5, &t5 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test13()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, reference pointer(pointer) key - reference pointer(pointer) value" );

	drr_map<test*,test*>	pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t2, &t2 },
				  { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }, { &t4, &t4 },
				  { &t4, &t4 }, { &t1, &t1 }, { &t2, &t2 }};
	drr_map<test*,test*> const& cm = pm;

	AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }} ));
	print( cm );

	AssertNotEqual( pm.find( &t4 ), pm.end());
	AssertEqual( pm.find( &t4 )->first, &t4 );
	AssertEqual( pm.find( &t4 )->second, &t4 );
	AssertEqual( *pm.find( &t4 )->second, t4 );
	AssertEqual( pm.find( &t7 ), pm.end());

	AssertNotEqual( cm.find( &t4 ), cm.end());
	AssertEqual( cm.find( &t4 )->first, &t4 );
	AssertEqual( cm.find( &t4 )->second, &t4 );
	AssertEqual( *cm.find( &t4 )->second, t4 );
	AssertEqual( cm.find( &t7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertEqual( pm.at( &t2 ), &t2 );
	AssertEqual( *pm.at( &t2 ), t2 );
	AssertEqual( cm.at( &t3 ), &t3 );
	AssertEqual( *cm.at( &t3 ), t3 );
	try {
		AssertEqual( pm.at( &t7 ), &t7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertEqual( pm[ &t5 ] = pm.at( &t8 ), &t8 );
	AssertEqual( *pm[ &t5 ], t8 );
	AssertEqual( pm[ &t7 ] = &t7, &t7 );
	AssertEqual( *pm[ &t7 ], t7 );

	pm[ &t5 ] = &t5;
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 },
				    { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { &t7, &t7 }} ));

	drr_map<const test*,test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	drr_map<test*,test*>::iterator		b, e;
	drr_map<test*,test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( &t4 );
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ &t4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( &t4 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( &t8 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( &t4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( &t8 );
	f = cm.find( &t4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( &t4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ &t4, &t4 }, { &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// (.<-.&t4]
	b = pm.find( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// (&t4.->.)
	c = cm.upper_bound( &t4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( &t1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ &t1, &t1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( &t8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test14()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, deep pointer(pointer) key - reference pointer(pointer) value" );

	dpr_map<test*,test*>	pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t2, &t2 },
				  { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }, { &t4, &t4 },
				  { &t4, &t4 }, { &t1, &t1 }, { &t2, &t2 }};
	dpr_map<test*,test*> const& cm = pm;

	AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }} ));
	print( cm );

	AssertNotEqual( pm.find( &t4 ), pm.end());
	AssertNotEqual( pm.find( &t4 )->first, &t4 );
	AssertTrue( dp_eql<const test*>()( pm.find( &t4 )->first, &t4 ));
	AssertEqual( pm.find( &t4 )->second, &t4 );
	AssertEqual( *pm.find( &t4 )->second, t4 );
	AssertEqual( pm.find( &t7 ), pm.end());

	AssertNotEqual( cm.find( &t4 ), cm.end());
	AssertNotEqual( cm.find( &t4 )->first, &t4 );
	AssertTrue( dp_eql<const test*>()( cm.find( &t4 )->first, &t4 ));
	AssertEqual( cm.find( &t4 )->second, &t4 );
	AssertEqual( *cm.find( &t4 )->second, t4 );
	AssertEqual( cm.find( &t7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertEqual( pm.at( &t2 ), &t2 );
	AssertEqual( *pm.at( &t2 ), t2 );
	AssertEqual( cm.at( &t3 ), &t3 );
	AssertEqual( *cm.at( &t3 ), t3 );
	try {
		AssertEqual( pm.at( &t7 ), &t7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertEqual( pm[ dpl( &t5 ) ] = pm.at( &t8 ), &t8 );
	AssertEqual( *pm[ dpl( &t5 ) ], t8 );
	AssertEqual( pm[ dpl( &t7 ) ] = &t7, &t7 );
	AssertEqual( *pm[ dpl( &t7 ) ], t7 );

	pm[ dpl( &t5 ) ] = &t5;
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 },
				    { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { &t7, &t7 }} ));

	drr_map<const test*,test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	dpr_map<test*,test*>::iterator		b, e;
	dpr_map<test*,test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( &t4 );
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ &t4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( &t4 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( &t8 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( &t4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( &t8 );
	f = cm.find( &t4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( &t4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ &t4, &t4 }, { &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// (.<-.&t4]
	b = pm.find( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// (&t4.->.)
	c = cm.upper_bound( &t4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( &t1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ &t1, &t1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( &t8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test15()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, reference pointer(pointer) key - deep pointer(pointer) value" );

	drp_map<test*,test*>	pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t2, &t2 },
				  { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }, { &t4, &t4 },
				  { &t4, &t4 }, { &t1, &t1 }, { &t2, &t2 }};
	drp_map<test*,test*> const& cm = pm;

	AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }} ));
	print( cm );

	AssertNotEqual( pm.find( &t4 ), pm.end());
	AssertEqual( pm.find( &t4 )->first, &t4 );
	AssertNotEqual( pm.find( &t4 )->second, &t4 );
	AssertEqual( *pm.find( &t4 )->second, t4 );
	AssertEqual( pm.find( &t7 ), pm.end());

	AssertNotEqual( cm.find( &t4 ), cm.end());
	AssertEqual( cm.find( &t4 )->first, &t4 );
	AssertNotEqual( cm.find( &t4 )->second, &t4 );
	AssertEqual( *cm.find( &t4 )->second, t4 );
	AssertEqual( cm.find( &t7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertNotEqual( pm.at( &t2 ), &t2 );
	AssertTrue( dp_eql<test*>()( pm.at( &t2 ), &t2 ));
	AssertEqual( *pm.at( &t2 ), t2 );
	AssertNotEqual( cm.at( &t3 ), &t3 );
	AssertTrue( dp_eql<test*>()( cm.at( &t3 ), &t3 ));
	AssertEqual( *cm.at( &t3 ), t3 );
	try {
		AssertEqual( pm.at( &t7 ), &t7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertNotEqual( pm[ &t5 ] = pm.at( &t8 ), &t8 );
	AssertTrue( dp_eql<test*>()( pm.at( &t5 ), &t8 ));
	AssertEqual( *pm[ &t5 ], t8 );
	AssertNotEqual( pm[ &t7 ] = dpl( &t7 ), &t7 );
	AssertTrue( dp_eql<test*>()( pm.at( &t7 ), &t7 ));
	AssertEqual( *pm[ &t7 ], t7 );

	pm[ &t5 ] = dpl( &t5 );
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 },
				    { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { &t7, &t7 }} ));

	drr_map<const test*,test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	drp_map<test*,test*>::iterator		b, e;
	drp_map<test*,test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( &t4 );
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ &t4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( &t4 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( &t8 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( &t4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( &t8 );
	f = cm.find( &t4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( &t4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ &t4, &t4 }, { &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// (.<-.&t4]
	b = pm.find( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// (&t4.->.)
	c = cm.upper_bound( &t4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( &t1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ &t1, &t1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( &t8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test16()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, deep pointer(pointer) key - deep pointer(pointer) value" );

	dpp_map<test*,test*>	pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t2, &t2 },
				  { &t3, &t3 }, { &t3, &t3 }, { &t3, &t3 }, { &t4, &t4 }, { &t5, &t5 }, { &t4, &t4 },
				  { &t4, &t4 }, { &t1, &t1 }, { &t2, &t2 }};
	dpp_map<test*,test*> const& cm = pm;

	AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }} ));
	print( cm );

	AssertNotEqual( pm.find( &t4 ), pm.end());
	AssertNotEqual( pm.find( &t4 )->first, &t4 );
	AssertTrue( dp_eql<const test*>()( pm.find( &t4 )->first, &t4 ));
	AssertNotEqual( pm.find( &t4 )->second, &t4 );
	AssertEqual( *pm.find( &t4 )->second, t4 );
	AssertEqual( pm.find( &t7 ), pm.end());

	AssertNotEqual( cm.find( &t4 ), cm.end());
	AssertNotEqual( cm.find( &t4 )->first, &t4 );
	AssertTrue( dp_eql<const test*>()( cm.find( &t4 )->first, &t4 ));
	AssertNotEqual( cm.find( &t4 )->second, &t4 );
	AssertEqual( *cm.find( &t4 )->second, t4 );
	AssertEqual( cm.find( &t7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertNotEqual( pm.at( &t2 ), &t2 );
	AssertTrue( dp_eql<test*>()( pm.at( &t2 ), &t2 ));
	AssertEqual( *pm.at( &t2 ), t2 );
	AssertNotEqual( cm.at( &t3 ), &t3 );
	AssertTrue( dp_eql<test*>()( cm.at( &t3 ), &t3 ));
	AssertEqual( *cm.at( &t3 ), t3 );
	try {
		AssertEqual( pm.at( &t7 ), &t7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertNotEqual( pm[ dpl( &t5 ) ] = pm.at( &t8 ), &t8 );
	AssertTrue( dp_eql<test*>()( pm.at( &t5 ), &t8 ));
	AssertEqual( *pm[ dpl( &t5 ) ], t8 );
	AssertNotEqual( pm[ dpl( &t7 ) ] = dpl( &t7 ), &t7 );
	AssertTrue( dp_eql<test*>()( pm.at( &t7 ), &t7 ));
	AssertEqual( *pm[ dpl( &t7 ) ], t7 );

	pm[ dpl( &t5 ) ] = dpl( &t5 );
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { &t1, &t1 }, { &t2, &t2 }, { &t5, &t5 },
				    { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { &t7, &t7 }} ));

	drr_map<const test*,test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	dpp_map<test*,test*>::iterator		b, e;
	dpp_map<test*,test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( &t4 );
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ &t4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( &t4 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( &t4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( &t8 );
	e = pm.lower_bound( &t4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( &t4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( &t8 );
	f = cm.find( &t4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( &t4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ &t4, &t4 }, { &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// (.<-.&t4]
	b = pm.find( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// (&t4.->.)
	c = cm.upper_bound( &t4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ &t5, &t5 }, { &t7, &t7 }, { &t8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( &t4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( &t1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ &t1, &t1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( &t8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test17()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - reference pointer(c-string) value" );

	drr_map<const char[],const char[]>	pm = {{ s1, s1 }, { s2, s2 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s2, s2 },
				  { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 }, { s5, s5 }, { s4, s4 },
				  { s4, s4 }, { s1, s1 }, { s2, s2 }};
	drr_map<const char[],const char[]> const& cm = pm;

	AssertTrue( check_map( pm, {{ s1, s1 }, { s2, s2 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertEqual( pm.find( s4 )->second, s4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertEqual( cm.find( s4 )->second, s4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertEqual( pm.at( s2 ), s2 );
	AssertEqual( cm.at( s3 ), s3 );
	try {
		AssertEqual( pm.at( s7 ), s7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertEqual( pm[ s5 ] = pm.at( s8 ), s8 );
	AssertEqual( pm[ s7 ] = s7, s7 );

	pm[ s5 ] = s5;
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { s1, s1 }, { s2, s2 }, { s5, s5 },
				    { s8, s8 }, { s4, s4 }, { s3, s3 }, { s7, s7 }} ));

	drr_map<const char[],const char[]>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	drr_map<const char[],const char[]>::iterator		b, e;
	drr_map<const char[],const char[]>::const_iterator	c, f;

	// [s4.->.s4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ s4, s4 }} ));

	// (s4.<-.s4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.s4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }} ));

	// [s4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ s5, s5 }, { s7, s7 }, { s8, s8 }} ));

	// [.->.s4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { s1, s1 }, { s2, s2 }, { s3, s3 }} ));

	// (s4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ s5, s5 }, { s7, s7 }, { s8, s8 }} ));

	// [s4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ s4, s4 }, { s5, s5 }, { s7, s7 }, { s8, s8 }} ));

	// (.<-.s4]
	b = pm.find( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }} ));

	// (s4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ s5, s5 }, { s7, s7 }, { s8, s8 }} ));

	// (.<-.s4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }} ));

	// equal range
	auto r = pm.equal_range( s1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ s1, s1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test18()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - deep pointer(c-string) value" );

	drp_map<const char[],const char[]>	pm = {{ s1, s1 }, { s2, s2 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s2, s2 },
				  { s3, s3 }, { s3, s3 }, { s3, s3 }, { s4, s4 }, { s5, s5 }, { s4, s4 },
				  { s4, s4 }, { s1, s1 }, { s2, s2 }};
	drp_map<const char[],const char[]> const& cm = pm;

	AssertTrue( check_map( pm, {{ s1, s1 }, { s2, s2 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertNotEqual( pm.find( s4 )->second, s4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertNotEqual( cm.find( s4 )->second, s4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertNotEqual( pm.at( s2 ), s2 );
	AssertTrue( dp_eql<const char[]>()( pm.at( s2 ), s2 ));
	AssertNotEqual( cm.at( s3 ), s3 );
	AssertTrue( dp_eql<const char[]>()( cm.at( s3 ), s3 ));
	try {
		AssertEqual( pm.at( s7 ), s7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertNotEqual( pm[ s5 ] = pm.at( s8 ), s8 );
	AssertTrue( dp_eql<const char[]>()( pm.at( s5 ), s8 ));
	AssertNotEqual( pm[ s7 ] = strdup( s7 ), s7 );
	AssertTrue( dp_eql<const char[]>()( pm.at( s7 ), s7 ));

	pm[ s5 ] = strdup( s5 );
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { s1, s1 }, { s2, s2 }, { s5, s5 },
				    { s8, s8 }, { s4, s4 }, { s3, s3 }, { s7, s7 }} ));

	drr_map<const char[],const char[]>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	drp_map<const char[],const char[]>::iterator		b, e;
	drp_map<const char[],const char[]>::const_iterator	c, f;

	// [s4.->.s4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ s4, s4 }} ));

	// (s4.<-.s4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.s4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }} ));

	// [s4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ s5, s5 }, { s7, s7 }, { s8, s8 }} ));

	// [.->.s4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { s1, s1 }, { s2, s2 }, { s3, s3 }} ));

	// (s4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ s5, s5 }, { s7, s7 }, { s8, s8 }} ));

	// [s4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ s4, s4 }, { s5, s5 }, { s7, s7 }, { s8, s8 }} ));

	// (.<-.s4]
	b = pm.find( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }} ));

	// (s4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ s5, s5 }, { s7, s7 }, { s8, s8 }} ));

	// (.<-.s4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s4, s4 }} ));

	// equal range
	auto r = pm.equal_range( s1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ s1, s1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test19()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - reference pointer(v-array) value" );

	drr_map<const char[],test[]>	pm = {{ s1, v1 }, { s2, v2 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s2, v2 },
				  { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 }, { s5, v5 }, { s4, v4 },
				  { s4, v4 }, { s1, v1 }, { s2, v2 }};
	drr_map<const char[],test[]> const& cm = pm;

	AssertTrue( check_map( pm, {{ s1, v1 }, { s2, v2 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertEqual( pm.find( s4 )->second, v4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertEqual( cm.find( s4 )->second, v4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertEqual( pm.at( s2 ), v2 );
	AssertEqual( cm.at( s3 ), v3 );
	try {
		AssertEqual( pm.at( s7 ), v7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertEqual( pm[ s5 ] = pm.at( s8 ), v8 );
	AssertEqual( pm[ s7 ] = v7, v7 );

	pm[ s5 ] = v5;
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { s1, v1 }, { s2, v2 }, { s5, v5 },
				    { s8, v8 }, { s4, v4 }, { s3, v3 }, { s7, v7 }} ));

	drr_map<const char[],test[]>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	drr_map<const char[],test[]>::iterator		b, e;
	drr_map<const char[],test[]>::const_iterator	c, f;

	// [v4.->.v4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ s4, v4 }} ));

	// (v4.<-.v4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.v4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }} ));

	// [v4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ s5, v5 }, { s7, v7 }, { s8, v8 }} ));

	// [.->.v4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { s1, v1 }, { s2, v2 }, { s3, v3 }} ));

	// (v4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ s5, v5 }, { s7, v7 }, { s8, v8 }} ));

	// [v4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ s4, v4 }, { s5, v5 }, { s7, v7 }, { s8, v8 }} ));

	// (.<-.v4]
	b = pm.find( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }} ));

	// (v4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ s5, v5 }, { s7, v7 }, { s8, v8 }} ));

	// (.<-.v4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }} ));

	// equal range
	auto r = pm.equal_range( s1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ s1, v1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test1A()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - deep pointer(v-array) value" );

	drp_map<const char[],test[]>	pm = {{ s1, v1 }, { s2, v2 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s2, v2 },
				  { s3, v3 }, { s3, v3 }, { s3, v3 }, { s4, v4 }, { s5, v5 }, { s4, v4 },
				  { s4, v4 }, { s1, v1 }, { s2, v2 }};
	drp_map<const char[],test[]> const& cm = pm;

	AssertTrue( check_map( pm, {{ s1, v1 }, { s2, v2 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertNotEqual( pm.find( s4 )->second, v4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertNotEqual( cm.find( s4 )->second, v4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertNotEqual( pm.at( s2 ), v2 );
	AssertTrue( dp_eql<test[]>()( pm.at( s2 ), v2 ));
	AssertNotEqual( cm.at( s3 ), v3 );
	AssertTrue( dp_eql<test[]>()( cm.at( s3 ), v3 ));
	try {
		AssertEqual( pm.at( s7 ), v7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertNotEqual( pm[ s5 ] = pm.at( s8 ), v8 );
	AssertTrue( dp_eql<test[]>()( pm.at( s5 ), v8 ));
	AssertNotEqual( pm[ s7 ] = dpl( v7 ), v7 );
	AssertTrue( dp_eql<test[]>()( pm.at( s7 ), v7 ));

	pm[ s5 ] = dpl( v5 );
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { s1, v1 }, { s2, v2 }, { s5, v5 },
				    { s8, v8 }, { s4, v4 }, { s3, v3 }, { s7, v7 }} ));

	drr_map<const char[],test[]>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	drp_map<const char[],test[]>::iterator		b, e;
	drp_map<const char[],test[]>::const_iterator	c, f;

	// [v4.->.v4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ s4, v4 }} ));

	// (v4.<-.v4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.v4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }} ));

	// [v4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ s5, v5 }, { s7, v7 }, { s8, v8 }} ));

	// [.->.v4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { s1, v1 }, { s2, v2 }, { s3, v3 }} ));

	// (v4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ s5, v5 }, { s7, v7 }, { s8, v8 }} ));

	// [v4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ s4, v4 }, { s5, v5 }, { s7, v7 }, { s8, v8 }} ));

	// (.<-.v4]
	b = pm.find( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }} ));

	// (v4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ s5, v5 }, { s7, v7 }, { s8, v8 }} ));

	// (.<-.v4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s4, v4 }} ));

	// equal range
	auto r = pm.equal_range( s1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ s1, v1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test1B()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - reference pointer(f-array) value" );

	drr_map<const char[],test[3]>	pm = {{ s1, w1 }, { s2, w2 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s2, w2 },
				  { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 }, { s5, w5 }, { s4, w4 },
				  { s4, w4 }, { s1, w1 }, { s2, w2 }};
	drr_map<const char[],test[3]> const& cm = pm;

	AssertTrue( check_map( pm, {{ s1, w1 }, { s2, w2 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertEqual( pm.find( s4 )->second, w4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertEqual( cm.find( s4 )->second, w4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertEqual( pm.at( s2 ), w2 );
	AssertEqual( cm.at( s3 ), w3 );
	try {
		AssertEqual( pm.at( s7 ), w7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertEqual( pm[ s5 ] = pm.at( s8 ), w8 );
	AssertEqual( pm[ s7 ] = w7, w7 );

	pm[ s5 ] = w5;
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { s1, w1 }, { s2, w2 }, { s5, w5 },
				    { s8, w8 }, { s4, w4 }, { s3, w3 }, { s7, w7 }} ));

	drr_map<const char[],test[3]>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	drr_map<const char[],test[3]>::iterator		b, e;
	drr_map<const char[],test[3]>::const_iterator	c, f;

	// [w4.->.w4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ s4, w4 }} ));

	// (w4.<-.w4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.w4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }} ));

	// [w4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ s5, w5 }, { s7, w7 }, { s8, w8 }} ));

	// [.->.w4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { s1, w1 }, { s2, w2 }, { s3, w3 }} ));

	// (w4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ s5, w5 }, { s7, w7 }, { s8, w8 }} ));

	// [w4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ s4, w4 }, { s5, w5 }, { s7, w7 }, { s8, w8 }} ));

	// (.<-.w4]
	b = pm.find( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }} ));

	// (w4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ s5, w5 }, { s7, w7 }, { s8, w8 }} ));

	// (.<-.w4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }} ));

	// equal range
	auto r = pm.equal_range( s1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ s1, w1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test1C()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - deep pointer(f-array) value" );

	drp_map<const char[],test[3]>	pm = {{ s1, w1 }, { s2, w2 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s2, w2 },
				  { s3, w3 }, { s3, w3 }, { s3, w3 }, { s4, w4 }, { s5, w5 }, { s4, w4 },
				  { s4, w4 }, { s1, w1 }, { s2, w2 }};
	drp_map<const char[],test[3]> const& cm = pm;

	AssertTrue( check_map( pm, {{ s1, w1 }, { s2, w2 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertNotEqual( pm.find( s4 )->second, w4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertNotEqual( cm.find( s4 )->second, w4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertNotEqual( pm.at( s2 ), w2 );
	AssertTrue( dp_eql<test[3]>()( pm.at( s2 ), w2 ));
	AssertNotEqual( cm.at( s3 ), w3 );
	AssertTrue( dp_eql<test[3]>()( cm.at( s3 ), w3 ));
	try {
		AssertEqual( pm.at( s7 ), w7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertNotEqual( pm[ s5 ] = pm.at( s8 ), w8 );
	AssertTrue( dp_eql<test[3]>()( pm.at( s5 ), w8 ));
	AssertNotEqual( pm[ s7 ] = dpl( w7 ), w7 );
	AssertTrue( dp_eql<test[3]>()( pm.at( s7 ), w7 ));

	pm[ s5 ] = dpl( w5 );
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { s1, w1 }, { s2, w2 }, { s5, w5 },
				    { s8, w8 }, { s4, w4 }, { s3, w3 }, { s7, w7 }} ));

	drr_map<const char[],test[3]>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	drp_map<const char[],test[3]>::iterator		b, e;
	drp_map<const char[],test[3]>::const_iterator	c, f;

	// [w4.->.w4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ s4, w4 }} ));

	// (w4.<-.w4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.w4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }} ));

	// [w4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ s5, w5 }, { s7, w7 }, { s8, w8 }} ));

	// [.->.w4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { s1, w1 }, { s2, w2 }, { s3, w3 }} ));

	// (w4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ s5, w5 }, { s7, w7 }, { s8, w8 }} ));

	// [w4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ s4, w4 }, { s5, w5 }, { s7, w7 }, { s8, w8 }} ));

	// (.<-.w4]
	b = pm.find( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }} ));

	// (w4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ s5, w5 }, { s7, w7 }, { s8, w8 }} ));

	// (.<-.w4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s4, w4 }} ));

	// equal range
	auto r = pm.equal_range( s1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ s1, w1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test1D()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - data(int value) value" );

	drn_map<const char[],int>	pm = {{ s1, 1 }, { s2, 2 }, { s5, 5 }, { s8, 8 }, { s4, 4 }, { s2, 2 },
				  { s3, 3 }, { s3, 3 }, { s3, 3 }, { s4, 4 }, { s5, 5 }, { s4, 4 },
				  { s4, 4 }, { s1, 1 }, { s2, 2 }};
	drn_map<const char[],int> const& cm = pm;

	AssertTrue( check_map( pm, {{ s1, 1 }, { s2, 2 }, { s5, 5 }, { s8, 8 }, { s4, 4 }, { s3, 3 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertEqual( pm.find( s4 )->second, 4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertEqual( cm.find( s4 )->second, 4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, 0 );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, 0 );

	AssertEqual( pm.at( s2 ), 2 );
	AssertEqual( cm.at( s3 ), 3 );
	try {
		AssertEqual( pm.at( s7 ), 7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertEqual( pm[ s5 ] = pm.at( s8 ), 8 );
	AssertEqual( pm[ s7 ] = 7, 7 );

	pm[ s5 ] = 5;
	AssertTrue( check_map( pm, {{ nullptr, 0 }, { s1, 1 }, { s2, 2 }, { s5, 5 },
				    { s8, 8 }, { s4, 4 }, { s3, 3 }, { s7, 7 }} ));

	drn_map<const char[],int>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	drn_map<const char[],int>::iterator		b, e;
	drn_map<const char[],int>::const_iterator	c, f;

	// [4.->.4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ s4, 4 }} ));

	// (4.<-.4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, 0 }, { s1, 1 }, { s2, 2 }, { s3, 3 }, { s4, 4 }} ));

	// [4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ s5, 5 }, { s7, 7 }, { s8, 8 }} ));

	// [.->.4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, 0 }, { s1, 1 }, { s2, 2 }, { s3, 3 }} ));

	// (4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ s5, 5 }, { s7, 7 }, { s8, 8 }} ));

	// [4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ s4, 4 }, { s5, 5 }, { s7, 7 }, { s8, 8 }} ));

	// (.<-.4]
	b = pm.find( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s4, 4 }} ));

	// (4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ s5, 5 }, { s7, 7 }, { s8, 8 }} ));

	// (.<-.4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s4, 4 }} ));

	// equal range
	auto r = pm.equal_range( s1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ s1, 1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test1E()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, reference pointer(c-string) key - deep pointer(pointer) value" );

	drp_map<const char[],test*>	pm = {{ s1, &t1 }, { s2, &t2 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s2, &t2 },
				  { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }, { s4, &t4 },
				  { s4, &t4 }, { s1, &t1 }, { s2, &t2 }};
	drp_map<const char[],test*> const& cm = pm;

	AssertTrue( check_map( pm, {{ s1, &t1 }, { s2, &t2 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertEqual( pm.find( s4 )->first, s4 );
	AssertNotEqual( pm.find( s4 )->second, &t4 );
	AssertEqual( *pm.find( s4 )->second, t4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertEqual( cm.find( s4 )->first, s4 );
	AssertNotEqual( cm.find( s4 )->second, &t4 );
	AssertEqual( *cm.find( s4 )->second, t4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertNotEqual( pm.at( s2 ), &t2 );
	AssertTrue( dp_eql<test*>()( pm.at( s2 ), &t2 ));
	AssertEqual( *pm.at( s2 ), t2 );
	AssertNotEqual( cm.at( s3 ), &t3 );
	AssertTrue( dp_eql<test*>()( cm.at( s3 ), &t3 ));
	AssertEqual( *cm.at( s3 ), t3 );
	try {
		AssertEqual( pm.at( s7 ), &t7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertNotEqual( pm[ s5 ] = pm.at( s8 ), &t8 );
	AssertTrue( dp_eql<test*>()( pm.at( s5 ), &t8 ));
	AssertEqual( *pm[ s5 ], t8 );
	AssertNotEqual( pm[ s7 ] = dpl( &t7 ), &t7 );
	AssertTrue( dp_eql<test*>()( pm.at( s7 ), &t7 ));
	AssertEqual( *pm[ s7 ], t7 );

	pm[ s5 ] = dpl( &t5 );
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { s1, &t1 }, { s2, &t2 }, { s5, &t5 },
				    { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { s7, &t7 }} ));

	drr_map<const char[],test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	drp_map<const char[],test*>::iterator		b, e;
	drp_map<const char[],test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ s4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ s5, &t5 }, { s7, &t7 }, { s8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { s1, &t1 }, { s2, &t2 }, { s3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ s5, &t5 }, { s7, &t7 }, { s8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ s4, &t4 }, { s5, &t5 }, { s7, &t7 }, { s8, &t8 }} ));

	// (.<-.&t4]
	b = pm.find( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }} ));

	// (&t4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ s5, &t5 }, { s7, &t7 }, { s8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( s1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ s1, &t1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test1F()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, deep pointer(c-string) key - deep pointer(pointer) value" );

	dpp_map<const char[],test*>	pm = {{ s1, &t1 }, { s2, &t2 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s2, &t2 },
				  { s3, &t3 }, { s3, &t3 }, { s3, &t3 }, { s4, &t4 }, { s5, &t5 }, { s4, &t4 },
				  { s4, &t4 }, { s1, &t1 }, { s2, &t2 }};
	dpp_map<const char[],test*> const& cm = pm;

	AssertTrue( check_map( pm, {{ s1, &t1 }, { s2, &t2 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }} ));
	print( cm );

	AssertNotEqual( pm.find( s4 ), pm.end());
	AssertNotEqual( pm.find( s4 )->first, s4 );
	AssertTrue( dp_eql<const char[]>()( pm.find( s4 )->first, s4 ));
	AssertNotEqual( pm.find( s4 )->second, &t4 );
	AssertEqual( *pm.find( s4 )->second, t4 );
	AssertEqual( pm.find( s7 ), pm.end());

	AssertNotEqual( cm.find( s4 ), cm.end());
	AssertNotEqual( cm.find( s4 )->first, s4 );
	AssertTrue( dp_eql<const char[]>()( cm.find( s4 )->first, s4 ));
	AssertNotEqual( cm.find( s4 )->second, &t4 );
	AssertEqual( *cm.find( s4 )->second, t4 );
	AssertEqual( cm.find( s7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertNotEqual( pm.at( s2 ), &t2 );
	AssertTrue( dp_eql<test*>()( pm.at( s2 ), &t2 ));
	AssertEqual( *pm.at( s2 ), t2 );
	AssertNotEqual( cm.at( s3 ), &t3 );
	AssertTrue( dp_eql<test*>()( cm.at( s3 ), &t3 ));
	AssertEqual( *cm.at( s3 ), t3 );
	try {
		AssertEqual( pm.at( s7 ), &t7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertNotEqual( pm[ strdup( s5 ) ] = pm.at( s8 ), &t8 );
	AssertTrue( dp_eql<test*>()( pm.at( s5 ), &t8 ));
	AssertEqual( *pm[ strdup( s5 ) ], t8 );
	AssertNotEqual( pm[ strdup( s7 ) ] = dpl( &t7 ), &t7 );
	AssertTrue( dp_eql<test*>()( pm.at( s7 ), &t7 ));
	AssertEqual( *pm[ strdup( s7 ) ], t7 );

	pm[ strdup( s5 ) ] = dpl( &t5 );
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { s1, &t1 }, { s2, &t2 }, { s5, &t5 },
				    { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { s7, &t7 }} ));

	drr_map<const char[],test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	dpp_map<const char[],test*>::iterator		b, e;
	dpp_map<const char[],test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( s4 );
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ s4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( s4 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( s4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( s8 );
	e = pm.lower_bound( s4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ s5, &t5 }, { s7, &t7 }, { s8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( s4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { s1, &t1 }, { s2, &t2 }, { s3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( s8 );
	f = cm.find( s4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ s5, &t5 }, { s7, &t7 }, { s8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( s4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ s4, &t4 }, { s5, &t5 }, { s7, &t7 }, { s8, &t8 }} ));

	// (.<-.&t4]
	b = pm.find( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }} ));

	// (&t4.->.)
	c = cm.upper_bound( s4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ s5, &t5 }, { s7, &t7 }, { s8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( s4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( s1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ s1, &t1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( s8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test20()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, reference pointer(v-array) key - deep pointer(pointer) value" );

	drp_map<test[],test*>	pm = {{ v1, &t1 }, { v2, &t2 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v2, &t2 },
				  { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }, { v4, &t4 },
				  { v4, &t4 }, { v1, &t1 }, { v2, &t2 }};
	drp_map<test[],test*> const& cm = pm;

	AssertTrue( check_map( pm, {{ v1, &t1 }, { v2, &t2 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }} ));
	print( cm );

	AssertNotEqual( pm.find( v4 ), pm.end());
	AssertEqual( pm.find( v4 )->first, v4 );
	AssertNotEqual( pm.find( v4 )->second, &t4 );
	AssertEqual( *pm.find( v4 )->second, t4 );
	AssertEqual( pm.find( v7 ), pm.end());

	AssertNotEqual( cm.find( v4 ), cm.end());
	AssertEqual( cm.find( v4 )->first, v4 );
	AssertNotEqual( cm.find( v4 )->second, &t4 );
	AssertEqual( *cm.find( v4 )->second, t4 );
	AssertEqual( cm.find( v7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertNotEqual( pm.at( v2 ), &t2 );
	AssertTrue( dp_eql<test*>()( pm.at( v2 ), &t2 ));
	AssertEqual( *pm.at( v2 ), t2 );
	AssertNotEqual( cm.at( v3 ), &t3 );
	AssertTrue( dp_eql<test*>()( cm.at( v3 ), &t3 ));
	AssertEqual( *cm.at( v3 ), t3 );
	try {
		AssertEqual( pm.at( v7 ), &t7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertNotEqual( pm[ v5 ] = pm.at( v8 ), &t8 );
	AssertTrue( dp_eql<test*>()( pm.at( v5 ), &t8 ));
	AssertEqual( *pm[ v5 ], t8 );
	AssertNotEqual( pm[ v7 ] = dpl( &t7 ), &t7 );
	AssertTrue( dp_eql<test*>()( pm.at( v7 ), &t7 ));
	AssertEqual( *pm[ v7 ], t7 );

	pm[ v5 ] = dpl( &t5 );
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { v1, &t1 }, { v2, &t2 }, { v5, &t5 },
				    { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { v7, &t7 }} ));

	drr_map<const test[],test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	drp_map<test[],test*>::iterator		b, e;
	drp_map<test[],test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( v4 );
	e = pm.upper_bound( v4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ v4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( v4 );
	e = pm.lower_bound( v4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( v4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( v8 );
	e = pm.lower_bound( v4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ v5, &t5 }, { v7, &t7 }, { v8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( v4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { v1, &t1 }, { v2, &t2 }, { v3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( v8 );
	f = cm.find( v4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ v5, &t5 }, { v7, &t7 }, { v8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( v4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ v4, &t4 }, { v5, &t5 }, { v7, &t7 }, { v8, &t8 }} ));

	// (.<-.&t4]
	b = pm.find( v4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }} ));

	// (&t4.->.)
	c = cm.upper_bound( v4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ v5, &t5 }, { v7, &t7 }, { v8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( v4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( v1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ v1, &t1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( v8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test21()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, deep pointer(v-array) key - deep pointer(pointer) value" );

	dpp_map<test[],test*>	pm = {{ v1, &t1 }, { v2, &t2 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v2, &t2 },
				  { v3, &t3 }, { v3, &t3 }, { v3, &t3 }, { v4, &t4 }, { v5, &t5 }, { v4, &t4 },
				  { v4, &t4 }, { v1, &t1 }, { v2, &t2 }};
	dpp_map<test[],test*> const& cm = pm;

	AssertTrue( check_map( pm, {{ v1, &t1 }, { v2, &t2 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }} ));
	print( cm );

	AssertNotEqual( pm.find( v4 ), pm.end());
	AssertNotEqual( pm.find( v4 )->first, v4 );
	AssertTrue( dp_eql<const test[]>()( pm.find( v4 )->first, v4 ));
	AssertNotEqual( pm.find( v4 )->second, &t4 );
	AssertEqual( *pm.find( v4 )->second, t4 );
	AssertEqual( pm.find( v7 ), pm.end());

	AssertNotEqual( cm.find( v4 ), cm.end());
	AssertNotEqual( cm.find( v4 )->first, v4 );
	AssertTrue( dp_eql<const test[]>()( cm.find( v4 )->first, v4 ));
	AssertNotEqual( cm.find( v4 )->second, &t4 );
	AssertEqual( *cm.find( v4 )->second, t4 );
	AssertEqual( cm.find( v7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertNotEqual( pm.at( v2 ), &t2 );
	AssertTrue( dp_eql<test*>()( pm.at( v2 ), &t2 ));
	AssertEqual( *pm.at( v2 ), t2 );
	AssertNotEqual( cm.at( v3 ), &t3 );
	AssertTrue( dp_eql<test*>()( cm.at( v3 ), &t3 ));
	AssertEqual( *cm.at( v3 ), t3 );
	try {
		AssertEqual( pm.at( v7 ), &t7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertNotEqual( pm[ dpl( v5 ) ] = pm.at( v8 ), &t8 );
	AssertTrue( dp_eql<test*>()( pm.at( v5 ), &t8 ));
	AssertEqual( *pm[ dpl( v5 ) ], t8 );
	AssertNotEqual( pm[ dpl( v7 ) ] = dpl( &t7 ), &t7 );
	AssertTrue( dp_eql<test*>()( pm.at( v7 ), &t7 ));
	AssertEqual( *pm[ dpl( v7 ) ], t7 );

	pm[ dpl( v5 ) ] = dpl( &t5 );
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { v1, &t1 }, { v2, &t2 }, { v5, &t5 },
				    { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { v7, &t7 }} ));

	drr_map<const test[],test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	dpp_map<test[],test*>::iterator		b, e;
	dpp_map<test[],test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( v4 );
	e = pm.upper_bound( v4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ v4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( v4 );
	e = pm.lower_bound( v4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( v4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( v8 );
	e = pm.lower_bound( v4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ v5, &t5 }, { v7, &t7 }, { v8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( v4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { v1, &t1 }, { v2, &t2 }, { v3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( v8 );
	f = cm.find( v4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ v5, &t5 }, { v7, &t7 }, { v8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( v4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ v4, &t4 }, { v5, &t5 }, { v7, &t7 }, { v8, &t8 }} ));

	// (.<-.&t4]
	b = pm.find( v4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }} ));

	// (&t4.->.)
	c = cm.upper_bound( v4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ v5, &t5 }, { v7, &t7 }, { v8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( v4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( v1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ v1, &t1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( v8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test22()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, reference pointer(f-array) key - deep pointer(pointer) value" );

	drp_map<test[3],test*>	pm = {{ w1, &t1 }, { w2, &t2 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w2, &t2 },
				  { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }, { w4, &t4 },
				  { w4, &t4 }, { w1, &t1 }, { w2, &t2 }};
	drp_map<test[3],test*> const& cm = pm;

	AssertTrue( check_map( pm, {{ w1, &t1 }, { w2, &t2 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }} ));
	print( cm );

	AssertNotEqual( pm.find( w4 ), pm.end());
	AssertEqual( pm.find( w4 )->first, w4 );
	AssertNotEqual( pm.find( w4 )->second, &t4 );
	AssertEqual( *pm.find( w4 )->second, t4 );
	AssertEqual( pm.find( w7 ), pm.end());

	AssertNotEqual( cm.find( w4 ), cm.end());
	AssertEqual( cm.find( w4 )->first, w4 );
	AssertNotEqual( cm.find( w4 )->second, &t4 );
	AssertEqual( *cm.find( w4 )->second, t4 );
	AssertEqual( cm.find( w7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertNotEqual( pm.at( w2 ), &t2 );
	AssertTrue( dp_eql<test*>()( pm.at( w2 ), &t2 ));
	AssertEqual( *pm.at( w2 ), t2 );
	AssertNotEqual( cm.at( w3 ), &t3 );
	AssertTrue( dp_eql<test*>()( cm.at( w3 ), &t3 ));
	AssertEqual( *cm.at( w3 ), t3 );
	try {
		AssertEqual( pm.at( w7 ), &t7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertNotEqual( pm[ w5 ] = pm.at( w8 ), &t8 );
	AssertTrue( dp_eql<test*>()( pm.at( w5 ), &t8 ));
	AssertEqual( *pm[ w5 ], t8 );
	AssertNotEqual( pm[ w7 ] = dpl( &t7 ), &t7 );
	AssertTrue( dp_eql<test*>()( pm.at( w7 ), &t7 ));
	AssertEqual( *pm[ w7 ], t7 );

	pm[ w5 ] = dpl( &t5 );
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { w1, &t1 }, { w2, &t2 }, { w5, &t5 },
				    { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { w7, &t7 }} ));

	drr_map<const test[3],test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	drp_map<test[3],test*>::iterator		b, e;
	drp_map<test[3],test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( w4 );
	e = pm.upper_bound( w4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ w4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( w4 );
	e = pm.lower_bound( w4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( w4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( w8 );
	e = pm.lower_bound( w4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ w5, &t5 }, { w7, &t7 }, { w8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( w4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { w1, &t1 }, { w2, &t2 }, { w3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( w8 );
	f = cm.find( w4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ w5, &t5 }, { w7, &t7 }, { w8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( w4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ w4, &t4 }, { w5, &t5 }, { w7, &t7 }, { w8, &t8 }} ));

	// (.<-.&t4]
	b = pm.find( w4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }} ));

	// (&t4.->.)
	c = cm.upper_bound( w4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ w5, &t5 }, { w7, &t7 }, { w8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( w4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( w1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ w1, &t1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( w8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test23()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, deep pointer(f-array) key - deep pointer(pointer) value" );

	dpp_map<test[3],test*>	pm = {{ w1, &t1 }, { w2, &t2 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w2, &t2 },
				  { w3, &t3 }, { w3, &t3 }, { w3, &t3 }, { w4, &t4 }, { w5, &t5 }, { w4, &t4 },
				  { w4, &t4 }, { w1, &t1 }, { w2, &t2 }};
	dpp_map<test[3],test*> const& cm = pm;

	AssertTrue( check_map( pm, {{ w1, &t1 }, { w2, &t2 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }} ));
	print( cm );

	AssertNotEqual( pm.find( w4 ), pm.end());
	AssertNotEqual( pm.find( w4 )->first, w4 );
	AssertTrue( dp_eql<const test[3]>()( pm.find( w4 )->first, w4 ));
	AssertNotEqual( pm.find( w4 )->second, &t4 );
	AssertEqual( *pm.find( w4 )->second, t4 );
	AssertEqual( pm.find( w7 ), pm.end());

	AssertNotEqual( cm.find( w4 ), cm.end());
	AssertNotEqual( cm.find( w4 )->first, w4 );
	AssertTrue( dp_eql<const test[3]>()( cm.find( w4 )->first, w4 ));
	AssertNotEqual( cm.find( w4 )->second, &t4 );
	AssertEqual( *cm.find( w4 )->second, t4 );
	AssertEqual( cm.find( w7 ), cm.end());

	// null key
	AssertEqual( pm.find( nullptr ), pm.end());
	AssertEqual( cm.find( nullptr ), cm.end());
	pm.emplace( nullptr, nullptr );
	AssertNotEqual( pm.find( nullptr ), pm.end());
	AssertEqual( pm.find( nullptr )->first, nullptr );
	AssertEqual( pm.find( nullptr )->second, nullptr );

	AssertNotEqual( pm.at( w2 ), &t2 );
	AssertTrue( dp_eql<test*>()( pm.at( w2 ), &t2 ));
	AssertEqual( *pm.at( w2 ), t2 );
	AssertNotEqual( cm.at( w3 ), &t3 );
	AssertTrue( dp_eql<test*>()( cm.at( w3 ), &t3 ));
	AssertEqual( *cm.at( w3 ), t3 );
	try {
		AssertEqual( pm.at( w7 ), &t7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertNotEqual( pm[ dpl( w5 ) ] = pm.at( w8 ), &t8 );
	AssertTrue( dp_eql<test*>()( pm.at( w5 ), &t8 ));
	AssertEqual( *pm[ dpl( w5 ) ], t8 );
	AssertNotEqual( pm[ dpl( w7 ) ] = dpl( &t7 ), &t7 );
	AssertTrue( dp_eql<test*>()( pm.at( w7 ), &t7 ));
	AssertEqual( *pm[ dpl( w7 ) ], t7 );

	pm[ dpl( w5 ) ] = dpl( &t5 );
	AssertTrue( check_map( pm, {{ nullptr, nullptr }, { w1, &t1 }, { w2, &t2 }, { w5, &t5 },
				    { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { w7, &t7 }} ));

	drr_map<const test[3],test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	dpp_map<test[3],test*>::iterator		b, e;
	dpp_map<test[3],test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( w4 );
	e = pm.upper_bound( w4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ w4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( w4 );
	e = pm.lower_bound( w4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( w4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ nullptr, nullptr }, { w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( w8 );
	e = pm.lower_bound( w4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ w5, &t5 }, { w7, &t7 }, { w8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( w4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ nullptr, nullptr }, { w1, &t1 }, { w2, &t2 }, { w3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( w8 );
	f = cm.find( w4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ w5, &t5 }, { w7, &t7 }, { w8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( w4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ w4, &t4 }, { w5, &t5 }, { w7, &t7 }, { w8, &t8 }} ));

	// (.<-.&t4]
	b = pm.find( w4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }} ));

	// (&t4.->.)
	c = cm.upper_bound( w4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ w5, &t5 }, { w7, &t7 }, { w8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( w4 );
	e = pm.find( nullptr );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( w1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ w1, &t1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( nullptr ), pm.find( nullptr ));
	AssertEqual( pm.upper_bound( w8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test24()
{
	this->set_subtitle( "at/operator[]/find/lower_bound/upper_bound/equal_range, data(int value) key - deep pointer(pointer) value" );

	dnp_map<int,test*>	pm = {{ 1, &t1 }, { 2, &t2 }, { 5, &t5 }, { 8, &t8 }, { 4, &t4 }, { 2, &t2 },
				  { 3, &t3 }, { 3, &t3 }, { 3, &t3 }, { 4, &t4 }, { 5, &t5 }, { 4, &t4 },
				  { 4, &t4 }, { 1, &t1 }, { 2, &t2 }};
	dnp_map<int,test*> const& cm = pm;

	AssertTrue( check_map( pm, {{ 1, &t1 }, { 2, &t2 }, { 5, &t5 }, { 8, &t8 }, { 4, &t4 }, { 3, &t3 }} ));
	print( cm );

	AssertNotEqual( pm.find( 4 ), pm.end());
	AssertEqual( pm.find( 4 )->first, 4 );
	AssertNotEqual( pm.find( 4 )->second, &t4 );
	AssertEqual( *pm.find( 4 )->second, t4 );
	AssertEqual( pm.find( 7 ), pm.end());

	AssertNotEqual( cm.find( 4 ), cm.end());
	AssertEqual( cm.find( 4 )->first, 4 );
	AssertNotEqual( cm.find( 4 )->second, &t4 );
	AssertEqual( *cm.find( 4 )->second, t4 );
	AssertEqual( cm.find( 7 ), cm.end());

	// null key
	AssertEqual( pm.find( 0 ), pm.end());
	AssertEqual( cm.find( 0 ), cm.end());
	pm.emplace( 0, nullptr );
	AssertNotEqual( pm.find( 0 ), pm.end());
	AssertEqual( pm.find( 0 )->first, 0 );
	AssertEqual( pm.find( 0 )->second, nullptr );

	AssertNotEqual( pm.at( 2 ), &t2 );
	AssertTrue( dp_eql<test*>()( pm.at( 2 ), &t2 ));
	AssertEqual( *pm.at( 2 ), t2 );
	AssertNotEqual( cm.at( 3 ), &t3 );
	AssertTrue( dp_eql<test*>()( cm.at( 3 ), &t3 ));
	AssertEqual( *cm.at( 3 ), t3 );
	try {
		AssertEqual( pm.at( 7 ), &t7 );
	} 
	catch (const std::out_of_range& oor) {
		fprintf( stderr, "--- exception out_of_range\n" );
	}

	AssertNotEqual( pm[ 5 ] = pm.at( 8 ), &t8 );
	AssertTrue( dp_eql<test*>()( pm.at( 5 ), &t8 ));
	AssertEqual( *pm[ 5 ], t8 );
	AssertNotEqual( pm[ 7 ] = dpl( &t7 ), &t7 );
	AssertTrue( dp_eql<test*>()( pm.at( 7 ), &t7 ));
	AssertEqual( *pm[ 7 ], t7 );

	pm[ 5 ] = dpl( &t5 );
	AssertTrue( check_map( pm, {{ 0, nullptr }, { 1, &t1 }, { 2, &t2 }, { 5, &t5 },
				    { 8, &t8 }, { 4, &t4 }, { 3, &t3 }, { 7, &t7 }} ));

	dnr_map<int,test*>	l1, r1, l2, r2, l3, r3, l4, r4, l5, r5, er;
	dnp_map<int,test*>::iterator		b, e;
	dnp_map<int,test*>::const_iterator	c, f;

	// [&t4.->.&t4)
	b = pm.find( 4 );
	e = pm.upper_bound( 4 );
	for ( auto i = b; i != e; ++i ) l1.insert( *i );
	AssertTrue( check_map( l1, {{ 4, &t4 }} ));

	// (&t4.<-.&t4]
	b = pm.find( 4 );
	e = pm.lower_bound( 4 );
	for ( auto i = b; i != e; --i ) r1.insert( *i );
	AssertTrue( check_map( r1, { } ));

	// [.->.&t4]
	b = pm.begin();
	e = pm.upper_bound( 4 );
	for ( auto i = b; i != e; ++i ) l2.insert( *i );
	AssertTrue( check_map( l2, {{ 0, nullptr }, { 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 4, &t4 }} ));

	// [&t4.<-.]
	b = pm.find( 8 );
	e = pm.lower_bound( 4 );
	for ( auto i = b; i != e; --i ) r2.insert( *i );
	AssertTrue( check_map( r2, {{ 5, &t5 }, { 7, &t7 }, { 8, &t8 }} ));

	// [.->.&t4)
	b = pm.begin();
	e = pm.find( 4 );
	for ( auto i = b; i != e; ++i ) l3.insert( *i );
	AssertTrue( check_map( l3, {{ 0, nullptr }, { 1, &t1 }, { 2, &t2 }, { 3, &t3 }} ));

	// (&t4.<-.]
	c = cm.find( 8 );
	f = cm.find( 4 );
	for ( auto i = c; i != f; --i ) r3.insert( *i );
	AssertTrue( check_map( r3, {{ 5, &t5 }, { 7, &t7 }, { 8, &t8 }} ));

	// [&t4.->.)
	b = pm.find( 4 );
	e = pm.end();
	for ( auto i = b; i != e; ++i ) l4.insert( *i );
	AssertTrue( check_map( l4, {{ 4, &t4 }, { 5, &t5 }, { 7, &t7 }, { 8, &t8 }} ));

	// (.<-.&t4]
	b = pm.find( 4 );
	e = pm.find( 0 );
	for ( auto i = b; i != e; --i ) r4.insert( *i );
	AssertTrue( check_map( r4, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 4, &t4 }} ));

	// (&t4.->.)
	c = cm.upper_bound( 4 );
	f = cm.end();
	for ( auto i = c; i != f; ++i ) l5.insert( *i );
	AssertTrue( check_map( l5, {{ 5, &t5 }, { 7, &t7 }, { 8, &t8 }} ));

	// (.<-.&t4)
	b = pm.lower_bound( 4 );
	e = pm.find( 0 );
	for ( auto i = b; i != e; --i ) r5.insert( *i );
	AssertTrue( check_map( r5, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 4, &t4 }} ));

	// equal range
	auto r = pm.equal_range( 1 );
	for ( auto i = r.first; i != r.second; ++i ) er.insert( *i );
	AssertTrue( check_map( er, {{ 1, &t1 }} ));

	// boundary
	AssertEqual( pm.lower_bound( 0 ), pm.find( 0 ));
	AssertEqual( pm.upper_bound( 8 ), pm.end());
}

// -----------------------------------------------------------------------------
void dp_maptest::test25()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(pointer) key - reference pointer(pointer) value" );

	typedef typename drr_map<test*,test*>::iterator		iterator;
	typedef typename drr_map<test*,test*>::const_iterator	const_iterator;

	drr_map<const test*,test*>	m1 = {{ &t1, &t1 }, { &t2, &t2 }};
	drr_map<const test*,test*>	m2;
	drr_map<const test*,test*>	m3 = {{ &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};

	// emplace
	{
		drr_map<test*,test*>		pm;
		drr_map<test*,test*>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const test*>()( i->first, &t1 ) ||
				     dp_eql<const test*>()( i->first, &t2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// insert
	{
		drr_map<test*,test*>		pm;
		drr_map<test*,test*>		pi;
		drr_map<test*,test*>		il;
		drr_map<test*,test*>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ &t1, &t1 }, { &t2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const test*>()( p.first, &t1 ) ||
				     dp_eql<const test*>()( p.first, &t2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ &t2, &t2 }, { &t3, &t3 }, { &t3, &t4 }, { &t3, &t5 }, { &t5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( il, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( it, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// erase
	{
		drr_map<test*,test*>     p {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr } };
		drr_map<test*,test*>     p1( p );

		AssertEqual( p1.erase( &t4 ), 1 );
		AssertTrue( check_map( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( &t7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( &t1 ));
		AssertEqual( p1.erase( &t8 ), 1 );
		AssertTrue( check_map( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t3, &t3 }} ));

		drr_map<test*,test*>     q1( p );
		drr_map<test*,test*>     q2( p );
		drr_map<test*,test*>     q3( p );
		drr_map<test*,test*>     q4( p );

		q1.erase( q1.find( &t4 ), q1.upper_bound( &t4 ));
		AssertTrue( check_map( q1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( &t4 ));
		AssertTrue( check_map( q2, {{ &t5, &t5 }, { &t8, &t8 }} ));
		q3.erase( q3.find( &t4 ), q3.end());
		AssertTrue( check_map( q3, {{ &t1, &t1 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( &t4 ), q4.find( &t4 ));
		AssertTrue( check_map( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test26()
{
	this->set_subtitle( "emplace/insert/erase, deep pointer(pointer) key - reference pointer(pointer) value" );

	typedef typename dpr_map<test*,test*>::iterator		iterator;
	typedef typename dpr_map<test*,test*>::const_iterator	const_iterator;

	drr_map<const test*,test*>	m1 = {{ &t1, &t1 }, { &t2, &t2 }};
	drr_map<const test*,test*>	m2;
	drr_map<const test*,test*>	m3 = {{ &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};

	// emplace
	{
		dpr_map<test*,test*>		pm;
		dpr_map<test*,test*>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const test*>()( i->first, &t1 ) ||
				     dp_eql<const test*>()( i->first, &t2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// insert
	{
		dpr_map<test*,test*>		pm;
		dpr_map<test*,test*>		pi;
		dpr_map<test*,test*>		il;
		dpr_map<test*,test*>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ &t1, &t1 }, { &t2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const test*>()( p.first, &t1 ) ||
				     dp_eql<const test*>()( p.first, &t2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ &t2, &t2 }, { &t3, &t3 }, { &t3, &t4 }, { &t3, &t5 }, { &t5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( il, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( it, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// erase
	{
		dpr_map<test*,test*>     p {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr } };
		dpr_map<test*,test*>     p1( p );

		AssertEqual( p1.erase( &t4 ), 1 );
		AssertTrue( check_map( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( &t7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( &t1 ));
		AssertEqual( p1.erase( &t8 ), 1 );
		AssertTrue( check_map( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t3, &t3 }} ));

		dpr_map<test*,test*>     q1( p );
		dpr_map<test*,test*>     q2( p );
		dpr_map<test*,test*>     q3( p );
		dpr_map<test*,test*>     q4( p );

		q1.erase( q1.find( &t4 ), q1.upper_bound( &t4 ));
		AssertTrue( check_map( q1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( &t4 ));
		AssertTrue( check_map( q2, {{ &t5, &t5 }, { &t8, &t8 }} ));
		q3.erase( q3.find( &t4 ), q3.end());
		AssertTrue( check_map( q3, {{ &t1, &t1 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( &t4 ), q4.find( &t4 ));
		AssertTrue( check_map( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test27()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(pointer) key - deep pointer(pointer) value" );

	typedef typename drp_map<test*,test*>::iterator		iterator;
	typedef typename drp_map<test*,test*>::const_iterator	const_iterator;

	drr_map<const test*,test*>	m1 = {{ &t1, &t1 }, { &t2, &t2 }};
	drr_map<const test*,test*>	m2;
	drr_map<const test*,test*>	m3 = {{ &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};

	// emplace
	{
		drp_map<test*,test*>		pm;
		drp_map<test*,test*>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const test*>()( i->first, &t1 ) ||
				     dp_eql<const test*>()( i->first, &t2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// insert
	{
		drp_map<test*,test*>		pm;
		drp_map<test*,test*>		pi;
		drp_map<test*,test*>		il;
		drp_map<test*,test*>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ &t1, &t1 }, { &t2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const test*>()( p.first, &t1 ) ||
				     dp_eql<const test*>()( p.first, &t2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ &t2, &t2 }, { &t3, &t3 }, { &t3, &t4 }, { &t3, &t5 }, { &t5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( il, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( it, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// erase
	{
		drp_map<test*,test*>     p {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr } };
		drp_map<test*,test*>     p1( p );

		AssertEqual( p1.erase( &t4 ), 1 );
		AssertTrue( check_map( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( &t7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( &t1 ));
		AssertEqual( p1.erase( &t8 ), 1 );
		AssertTrue( check_map( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t3, &t3 }} ));

		drp_map<test*,test*>     q1( p );
		drp_map<test*,test*>     q2( p );
		drp_map<test*,test*>     q3( p );
		drp_map<test*,test*>     q4( p );

		q1.erase( q1.find( &t4 ), q1.upper_bound( &t4 ));
		AssertTrue( check_map( q1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( &t4 ));
		AssertTrue( check_map( q2, {{ &t5, &t5 }, { &t8, &t8 }} ));
		q3.erase( q3.find( &t4 ), q3.end());
		AssertTrue( check_map( q3, {{ &t1, &t1 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( &t4 ), q4.find( &t4 ));
		AssertTrue( check_map( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test28()
{
	this->set_subtitle( "emplace/insert/erase, deep pointer(pointer) key - deep pointer(pointer) value" );

	typedef typename dpp_map<test*,test*>::iterator		iterator;
	typedef typename dpp_map<test*,test*>::const_iterator	const_iterator;

	drr_map<const test*,test*>	m1 = {{ &t1, &t1 }, { &t2, &t2 }};
	drr_map<const test*,test*>	m2;
	drr_map<const test*,test*>	m3 = {{ &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};

	// emplace
	{
		dpp_map<test*,test*>		pm;
		dpp_map<test*,test*>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const test*>()( i->first, &t1 ) ||
				     dp_eql<const test*>()( i->first, &t2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// insert
	{
		dpp_map<test*,test*>		pm;
		dpp_map<test*,test*>		pi;
		dpp_map<test*,test*>		il;
		dpp_map<test*,test*>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ &t1, &t1 }, { &t2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( il, {{ &t1, &t1 }, { &t2, &t2 }} ));
		AssertTrue( check_map( it, {{ &t1, &t1 }, { &t2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const test*>()( p.first, &t1 ) ||
				     dp_eql<const test*>()( p.first, &t2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ &t2, &t2 }, { &t3, &t3 }, { &t3, &t4 }, { &t3, &t5 }, { &t5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( pi, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( il, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
		AssertTrue( check_map( it, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	}

	// erase
	{
		dpp_map<test*,test*>     p {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr } };
		dpp_map<test*,test*>     p1( p );

		AssertEqual( p1.erase( &t4 ), 1 );
		AssertTrue( check_map( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( &t7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( &t1 ));
		AssertEqual( p1.erase( &t8 ), 1 );
		AssertTrue( check_map( p1, {{ &t1, &t1 }, { &t5, &t5 }, { &t3, &t3 }} ));

		dpp_map<test*,test*>     q1( p );
		dpp_map<test*,test*>     q2( p );
		dpp_map<test*,test*>     q3( p );
		dpp_map<test*,test*>     q4( p );

		q1.erase( q1.find( &t4 ), q1.upper_bound( &t4 ));
		AssertTrue( check_map( q1, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( &t4 ));
		AssertTrue( check_map( q2, {{ &t5, &t5 }, { &t8, &t8 }} ));
		q3.erase( q3.find( &t4 ), q3.end());
		AssertTrue( check_map( q3, {{ &t1, &t1 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( &t4 ), q4.find( &t4 ));
		AssertTrue( check_map( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ &t1, &t1 }, { &t5, &t5 }, { &t8, &t8 }, { &t4, &t4 }, { &t3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test29()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - reference pointer(c-string) value" );

	typedef typename drr_map<const char[],const char[]>::iterator		iterator;
	typedef typename drr_map<const char[],const char[]>::const_iterator	const_iterator;

	drr_map<const char[],const char[]>	m1 = {{ s1, s1 }, { s2, s2 }};
	drr_map<const char[],const char[]>	m2;
	drr_map<const char[],const char[]>	m3 = {{ s2, s2 }, { s3, s3 }, { s5, s5 }};

	// emplace
	{
		drr_map<const char[],const char[]>		pm;
		drr_map<const char[],const char[]>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_map( pi, {{ s1, s1 }, { s2, s2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const char[]>()( i->first, s1 ) ||
				     dp_eql<const char[]>()( i->first, s2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
		AssertTrue( check_map( pi, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
	}

	// insert
	{
		drr_map<const char[],const char[]>		pm;
		drr_map<const char[],const char[]>		pi;
		drr_map<const char[],const char[]>		il;
		drr_map<const char[],const char[]>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, s1 }, { s2, s2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_map( pi, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_map( il, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_map( it, {{ s1, s1 }, { s2, s2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_map( pi, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_map( il, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_map( it, {{ s1, s1 }, { s2, s2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const char[]>()( p.first, s1 ) ||
				     dp_eql<const char[]>()( p.first, s2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ s2, s2 }, { s3, s3 }, { s3, s4 }, { s3, s5 }, { s5, s5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
		AssertTrue( check_map( pi, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
		AssertTrue( check_map( il, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
		AssertTrue( check_map( it, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
	}

	// erase
	{
		drr_map<const char[],const char[]>     p {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr } };
		drr_map<const char[],const char[]>     p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_map( p1, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s3, s3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_map( p1, {{ s1, s1 }, { s5, s5 }, { s3, s3 }} ));

		drr_map<const char[],const char[]>     q1( p );
		drr_map<const char[],const char[]>     q2( p );
		drr_map<const char[],const char[]>     q3( p );
		drr_map<const char[],const char[]>     q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_map( q1, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s3, s3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_map( q2, {{ s5, s5 }, { s8, s8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_map( q3, {{ s1, s1 }, { s3, s3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_map( q4, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test2A()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - deep pointer(c-string) value" );

	typedef typename drp_map<const char[],const char[]>::iterator		iterator;
	typedef typename drp_map<const char[],const char[]>::const_iterator	const_iterator;

	drr_map<const char[],const char[]>	m1 = {{ s1, s1 }, { s2, s2 }};
	drr_map<const char[],const char[]>	m2;
	drr_map<const char[],const char[]>	m3 = {{ s2, s2 }, { s3, s3 }, { s5, s5 }};

	// emplace
	{
		drp_map<const char[],const char[]>		pm;
		drp_map<const char[],const char[]>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_map( pi, {{ s1, s1 }, { s2, s2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const char[]>()( i->first, s1 ) ||
				     dp_eql<const char[]>()( i->first, s2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
		AssertTrue( check_map( pi, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
	}

	// insert
	{
		drp_map<const char[],const char[]>		pm;
		drp_map<const char[],const char[]>		pi;
		drp_map<const char[],const char[]>		il;
		drp_map<const char[],const char[]>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, s1 }, { s2, s2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_map( pi, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_map( il, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_map( it, {{ s1, s1 }, { s2, s2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_map( pi, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_map( il, {{ s1, s1 }, { s2, s2 }} ));
		AssertTrue( check_map( it, {{ s1, s1 }, { s2, s2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const char[]>()( p.first, s1 ) ||
				     dp_eql<const char[]>()( p.first, s2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ s2, s2 }, { s3, s3 }, { s3, s4 }, { s3, s5 }, { s5, s5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
		AssertTrue( check_map( pi, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
		AssertTrue( check_map( il, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
		AssertTrue( check_map( it, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
	}

	// erase
	{
		drp_map<const char[],const char[]>     p {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr } };
		drp_map<const char[],const char[]>     p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_map( p1, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s3, s3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_map( p1, {{ s1, s1 }, { s5, s5 }, { s3, s3 }} ));

		drp_map<const char[],const char[]>     q1( p );
		drp_map<const char[],const char[]>     q2( p );
		drp_map<const char[],const char[]>     q3( p );
		drp_map<const char[],const char[]>     q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_map( q1, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s3, s3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_map( q2, {{ s5, s5 }, { s8, s8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_map( q3, {{ s1, s1 }, { s3, s3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_map( q4, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ s1, s1 }, { s5, s5 }, { s8, s8 }, { s4, s4 }, { s3, s3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test2B()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - reference pointer(v-array) value" );

	typedef typename drr_map<const char[],test[]>::iterator		iterator;
	typedef typename drr_map<const char[],test[]>::const_iterator	const_iterator;

	drr_map<const char[],test[]>	m1 = {{ s1, v1 }, { s2, v2 }};
	drr_map<const char[],test[]>	m2;
	drr_map<const char[],test[]>	m3 = {{ s2, v2 }, { s3, v3 }, { s5, v5 }};

	// emplace
	{
		drr_map<const char[],test[]>		pm;
		drr_map<const char[],test[]>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_map( pi, {{ s1, v1 }, { s2, v2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const char[]>()( i->first, s1 ) ||
				     dp_eql<const char[]>()( i->first, s2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
		AssertTrue( check_map( pi, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
	}

	// insert
	{
		drr_map<const char[],test[]>		pm;
		drr_map<const char[],test[]>		pi;
		drr_map<const char[],test[]>		il;
		drr_map<const char[],test[]>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, v1 }, { s2, v2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_map( pi, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_map( il, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_map( it, {{ s1, v1 }, { s2, v2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_map( pi, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_map( il, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_map( it, {{ s1, v1 }, { s2, v2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const char[]>()( p.first, s1 ) ||
				     dp_eql<const char[]>()( p.first, s2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ s2, v2 }, { s3, v3 }, { s3, v4 }, { s3, v5 }, { s5, v5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
		AssertTrue( check_map( pi, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
		AssertTrue( check_map( il, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
		AssertTrue( check_map( it, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
	}

	// erase
	{
		drr_map<const char[],test[]>     p {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr } };
		drr_map<const char[],test[]>     p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_map( p1, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s3, v3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_map( p1, {{ s1, v1 }, { s5, v5 }, { s3, v3 }} ));

		drr_map<const char[],test[]>     q1( p );
		drr_map<const char[],test[]>     q2( p );
		drr_map<const char[],test[]>     q3( p );
		drr_map<const char[],test[]>     q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_map( q1, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s3, v3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_map( q2, {{ s5, v5 }, { s8, v8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_map( q3, {{ s1, v1 }, { s3, v3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_map( q4, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test2C()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - deep pointer(v-array) value" );

	typedef typename drp_map<const char[],test[]>::iterator		iterator;
	typedef typename drp_map<const char[],test[]>::const_iterator	const_iterator;

	drr_map<const char[],test[]>	m1 = {{ s1, v1 }, { s2, v2 }};
	drr_map<const char[],test[]>	m2;
	drr_map<const char[],test[]>	m3 = {{ s2, v2 }, { s3, v3 }, { s5, v5 }};

	// emplace
	{
		drp_map<const char[],test[]>		pm;
		drp_map<const char[],test[]>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_map( pi, {{ s1, v1 }, { s2, v2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const char[]>()( i->first, s1 ) ||
				     dp_eql<const char[]>()( i->first, s2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
		AssertTrue( check_map( pi, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
	}

	// insert
	{
		drp_map<const char[],test[]>		pm;
		drp_map<const char[],test[]>		pi;
		drp_map<const char[],test[]>		il;
		drp_map<const char[],test[]>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, v1 }, { s2, v2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_map( pi, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_map( il, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_map( it, {{ s1, v1 }, { s2, v2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_map( pi, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_map( il, {{ s1, v1 }, { s2, v2 }} ));
		AssertTrue( check_map( it, {{ s1, v1 }, { s2, v2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const char[]>()( p.first, s1 ) ||
				     dp_eql<const char[]>()( p.first, s2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ s2, v2 }, { s3, v3 }, { s3, v4 }, { s3, v5 }, { s5, v5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
		AssertTrue( check_map( pi, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
		AssertTrue( check_map( il, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
		AssertTrue( check_map( it, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
	}

	// erase
	{
		drp_map<const char[],test[]>     p {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr } };
		drp_map<const char[],test[]>     p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_map( p1, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s3, v3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_map( p1, {{ s1, v1 }, { s5, v5 }, { s3, v3 }} ));

		drp_map<const char[],test[]>     q1( p );
		drp_map<const char[],test[]>     q2( p );
		drp_map<const char[],test[]>     q3( p );
		drp_map<const char[],test[]>     q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_map( q1, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s3, v3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_map( q2, {{ s5, v5 }, { s8, v8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_map( q3, {{ s1, v1 }, { s3, v3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_map( q4, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ s1, v1 }, { s5, v5 }, { s8, v8 }, { s4, v4 }, { s3, v3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test2D()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - reference pointer(f-array) value" );

	typedef typename drr_map<const char[],test[3]>::iterator		iterator;
	typedef typename drr_map<const char[],test[3]>::const_iterator	const_iterator;

	drr_map<const char[],test[3]>	m1 = {{ s1, w1 }, { s2, w2 }};
	drr_map<const char[],test[3]>	m2;
	drr_map<const char[],test[3]>	m3 = {{ s2, w2 }, { s3, w3 }, { s5, w5 }};

	// emplace
	{
		drr_map<const char[],test[3]>		pm;
		drr_map<const char[],test[3]>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_map( pi, {{ s1, w1 }, { s2, w2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const char[]>()( i->first, s1 ) ||
				     dp_eql<const char[]>()( i->first, s2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
		AssertTrue( check_map( pi, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
	}

	// insert
	{
		drr_map<const char[],test[3]>		pm;
		drr_map<const char[],test[3]>		pi;
		drr_map<const char[],test[3]>		il;
		drr_map<const char[],test[3]>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, w1 }, { s2, w2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_map( pi, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_map( il, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_map( it, {{ s1, w1 }, { s2, w2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_map( pi, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_map( il, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_map( it, {{ s1, w1 }, { s2, w2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const char[]>()( p.first, s1 ) ||
				     dp_eql<const char[]>()( p.first, s2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ s2, w2 }, { s3, w3 }, { s3, w4 }, { s3, w5 }, { s5, w5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
		AssertTrue( check_map( pi, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
		AssertTrue( check_map( il, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
		AssertTrue( check_map( it, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
	}

	// erase
	{
		drr_map<const char[],test[3]>     p {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr } };
		drr_map<const char[],test[3]>     p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_map( p1, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s3, w3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_map( p1, {{ s1, w1 }, { s5, w5 }, { s3, w3 }} ));

		drr_map<const char[],test[3]>     q1( p );
		drr_map<const char[],test[3]>     q2( p );
		drr_map<const char[],test[3]>     q3( p );
		drr_map<const char[],test[3]>     q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_map( q1, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s3, w3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_map( q2, {{ s5, w5 }, { s8, w8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_map( q3, {{ s1, w1 }, { s3, w3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_map( q4, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test2E()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - deep pointer(f-array) value" );

	typedef typename drp_map<const char[],test[3]>::iterator		iterator;
	typedef typename drp_map<const char[],test[3]>::const_iterator	const_iterator;

	drr_map<const char[],test[3]>	m1 = {{ s1, w1 }, { s2, w2 }};
	drr_map<const char[],test[3]>	m2;
	drr_map<const char[],test[3]>	m3 = {{ s2, w2 }, { s3, w3 }, { s5, w5 }};

	// emplace
	{
		drp_map<const char[],test[3]>		pm;
		drp_map<const char[],test[3]>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_map( pi, {{ s1, w1 }, { s2, w2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const char[]>()( i->first, s1 ) ||
				     dp_eql<const char[]>()( i->first, s2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
		AssertTrue( check_map( pi, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
	}

	// insert
	{
		drp_map<const char[],test[3]>		pm;
		drp_map<const char[],test[3]>		pi;
		drp_map<const char[],test[3]>		il;
		drp_map<const char[],test[3]>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, w1 }, { s2, w2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_map( pi, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_map( il, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_map( it, {{ s1, w1 }, { s2, w2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_map( pi, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_map( il, {{ s1, w1 }, { s2, w2 }} ));
		AssertTrue( check_map( it, {{ s1, w1 }, { s2, w2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const char[]>()( p.first, s1 ) ||
				     dp_eql<const char[]>()( p.first, s2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ s2, w2 }, { s3, w3 }, { s3, w4 }, { s3, w5 }, { s5, w5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
		AssertTrue( check_map( pi, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
		AssertTrue( check_map( il, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
		AssertTrue( check_map( it, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
	}

	// erase
	{
		drp_map<const char[],test[3]>     p {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr } };
		drp_map<const char[],test[3]>     p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_map( p1, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s3, w3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_map( p1, {{ s1, w1 }, { s5, w5 }, { s3, w3 }} ));

		drp_map<const char[],test[3]>     q1( p );
		drp_map<const char[],test[3]>     q2( p );
		drp_map<const char[],test[3]>     q3( p );
		drp_map<const char[],test[3]>     q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_map( q1, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s3, w3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_map( q2, {{ s5, w5 }, { s8, w8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_map( q3, {{ s1, w1 }, { s3, w3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_map( q4, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ s1, w1 }, { s5, w5 }, { s8, w8 }, { s4, w4 }, { s3, w3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test2F()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - data(int value) value" );

	typedef typename drn_map<const char[],int>::iterator		iterator;
	typedef typename drn_map<const char[],int>::const_iterator	const_iterator;

	drn_map<const char[],int>	m1 = {{ s1, 1 }, { s2, 2 }};
	drn_map<const char[],int>	m2;
	drn_map<const char[],int>	m3 = {{ s2, 2 }, { s3, 3 }, { s5, 5 }};

	// emplace
	{
		drn_map<const char[],int>		pm;
		drn_map<const char[],int>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ s1, 1 }, { s2, 2 }} ));
		AssertTrue( check_map( pi, {{ s1, 1 }, { s2, 2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const char[]>()( i->first, s1 ) ||
				     dp_eql<const char[]>()( i->first, s2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }} ));
		AssertTrue( check_map( pi, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }} ));
	}

	// insert
	{
		drn_map<const char[],int>		pm;
		drn_map<const char[],int>		pi;
		drn_map<const char[],int>		il;
		drn_map<const char[],int>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, 1 }, { s2, 2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ s1, 1 }, { s2, 2 }} ));
		AssertTrue( check_map( pi, {{ s1, 1 }, { s2, 2 }} ));
		AssertTrue( check_map( il, {{ s1, 1 }, { s2, 2 }} ));
		AssertTrue( check_map( it, {{ s1, 1 }, { s2, 2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ s1, 1 }, { s2, 2 }} ));
		AssertTrue( check_map( pi, {{ s1, 1 }, { s2, 2 }} ));
		AssertTrue( check_map( il, {{ s1, 1 }, { s2, 2 }} ));
		AssertTrue( check_map( it, {{ s1, 1 }, { s2, 2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const char[]>()( p.first, s1 ) ||
				     dp_eql<const char[]>()( p.first, s2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ s2, 2 }, { s3, 3 }, { s3, 4 }, { s3, 5 }, { s5, 5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }} ));
		AssertTrue( check_map( pi, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }} ));
		AssertTrue( check_map( il, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }} ));
		AssertTrue( check_map( it, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }} ));
	}

	// erase
	{
		drn_map<const char[],int>     p {{ s1, 1 }, { s5, 5 }, { s8, 8 }, { s4, 4 }, { s3, 3 }, { nullptr, 0 } };
		drn_map<const char[],int>     p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_map( p1, {{ s1, 1 }, { s5, 5 }, { s8, 8 }, { s3, 3 }, { nullptr, 0 }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_map( p1, {{ s1, 1 }, { s5, 5 }, { s3, 3 }} ));

		drn_map<const char[],int>     q1( p );
		drn_map<const char[],int>     q2( p );
		drn_map<const char[],int>     q3( p );
		drn_map<const char[],int>     q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_map( q1, {{ s1, 1 }, { s5, 5 }, { s8, 8 }, { s3, 3 }, { nullptr, 0 }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_map( q2, {{ s5, 5 }, { s8, 8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_map( q3, {{ s1, 1 }, { s3, 3 }, { nullptr, 0 }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_map( q4, {{ s1, 1 }, { s5, 5 }, { s8, 8 }, { s4, 4 }, { s3, 3 }, { nullptr, 0 }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ s1, 1 }, { s5, 5 }, { s8, 8 }, { s4, 4 }, { s3, 3 }, { nullptr, 0 }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ s1, 1 }, { s5, 5 }, { s8, 8 }, { s4, 4 }, { s3, 3 }, { nullptr, 0 }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test30()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(c-string) key - deep pointer(pointer) value" );

	typedef typename drp_map<const char[],test*>::iterator		iterator;
	typedef typename drp_map<const char[],test*>::const_iterator	const_iterator;

	drr_map<const char[],test*>	m1 = {{ s1, &t1 }, { s2, &t2 }};
	drr_map<const char[],test*>	m2;
	drr_map<const char[],test*>	m3 = {{ s2, &t2 }, { s3, &t3 }, { s5, &t5 }};

	// emplace
	{
		drp_map<const char[],test*>		pm;
		drp_map<const char[],test*>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_map( pi, {{ s1, &t1 }, { s2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const char[]>()( i->first, s1 ) ||
				     dp_eql<const char[]>()( i->first, s2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
		AssertTrue( check_map( pi, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
	}

	// insert
	{
		drp_map<const char[],test*>		pm;
		drp_map<const char[],test*>		pi;
		drp_map<const char[],test*>		il;
		drp_map<const char[],test*>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, &t1 }, { s2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_map( pi, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_map( il, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_map( it, {{ s1, &t1 }, { s2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_map( pi, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_map( il, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_map( it, {{ s1, &t1 }, { s2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const char[]>()( p.first, s1 ) ||
				     dp_eql<const char[]>()( p.first, s2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ s2, &t2 }, { s3, &t3 }, { s3, &t4 }, { s3, &t5 }, { s5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
		AssertTrue( check_map( pi, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
		AssertTrue( check_map( il, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
		AssertTrue( check_map( it, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
	}

	// erase
	{
		drp_map<const char[],test*>     p {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr } };
		drp_map<const char[],test*>     p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_map( p1, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_map( p1, {{ s1, &t1 }, { s5, &t5 }, { s3, &t3 }} ));

		drp_map<const char[],test*>     q1( p );
		drp_map<const char[],test*>     q2( p );
		drp_map<const char[],test*>     q3( p );
		drp_map<const char[],test*>     q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_map( q1, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_map( q2, {{ s5, &t5 }, { s8, &t8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_map( q3, {{ s1, &t1 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_map( q4, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test31()
{
	this->set_subtitle( "emplace/insert/erase, deep pointer(c-string) key - deep pointer(pointer) value" );

	typedef typename dpp_map<const char[],test*>::iterator		iterator;
	typedef typename dpp_map<const char[],test*>::const_iterator	const_iterator;

	drr_map<const char[],test*>	m1 = {{ s1, &t1 }, { s2, &t2 }};
	drr_map<const char[],test*>	m2;
	drr_map<const char[],test*>	m3 = {{ s2, &t2 }, { s3, &t3 }, { s5, &t5 }};

	// emplace
	{
		dpp_map<const char[],test*>		pm;
		dpp_map<const char[],test*>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_map( pi, {{ s1, &t1 }, { s2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const char[]>()( i->first, s1 ) ||
				     dp_eql<const char[]>()( i->first, s2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
		AssertTrue( check_map( pi, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
	}

	// insert
	{
		dpp_map<const char[],test*>		pm;
		dpp_map<const char[],test*>		pi;
		dpp_map<const char[],test*>		il;
		dpp_map<const char[],test*>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ s1, &t1 }, { s2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_map( pi, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_map( il, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_map( it, {{ s1, &t1 }, { s2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_map( pi, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_map( il, {{ s1, &t1 }, { s2, &t2 }} ));
		AssertTrue( check_map( it, {{ s1, &t1 }, { s2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const char[]>()( p.first, s1 ) ||
				     dp_eql<const char[]>()( p.first, s2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ s2, &t2 }, { s3, &t3 }, { s3, &t4 }, { s3, &t5 }, { s5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
		AssertTrue( check_map( pi, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
		AssertTrue( check_map( il, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
		AssertTrue( check_map( it, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
	}

	// erase
	{
		dpp_map<const char[],test*>     p {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr } };
		dpp_map<const char[],test*>     p1( p );

		AssertEqual( p1.erase( s4 ), 1 );
		AssertTrue( check_map( p1, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( s7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( s1 ));
		AssertEqual( p1.erase( s8 ), 1 );
		AssertTrue( check_map( p1, {{ s1, &t1 }, { s5, &t5 }, { s3, &t3 }} ));

		dpp_map<const char[],test*>     q1( p );
		dpp_map<const char[],test*>     q2( p );
		dpp_map<const char[],test*>     q3( p );
		dpp_map<const char[],test*>     q4( p );

		q1.erase( q1.find( s4 ), q1.upper_bound( s4 ));
		AssertTrue( check_map( q1, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( s4 ));
		AssertTrue( check_map( q2, {{ s5, &t5 }, { s8, &t8 }} ));
		q3.erase( q3.find( s4 ), q3.end());
		AssertTrue( check_map( q3, {{ s1, &t1 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( s4 ), q4.find( s4 ));
		AssertTrue( check_map( q4, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ s1, &t1 }, { s5, &t5 }, { s8, &t8 }, { s4, &t4 }, { s3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test32()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(v-array) key - deep pointer(pointer) value" );

	typedef typename drp_map<test[],test*>::iterator		iterator;
	typedef typename drp_map<test[],test*>::const_iterator	const_iterator;

	drr_map<const test[],test*>	m1 = {{ v1, &t1 }, { v2, &t2 }};
	drr_map<const test[],test*>	m2;
	drr_map<const test[],test*>	m3 = {{ v2, &t2 }, { v3, &t3 }, { v5, &t5 }};

	// emplace
	{
		drp_map<test[],test*>		pm;
		drp_map<test[],test*>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_map( pi, {{ v1, &t1 }, { v2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const test[]>()( i->first, v1 ) ||
				     dp_eql<const test[]>()( i->first, v2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
		AssertTrue( check_map( pi, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
	}

	// insert
	{
		drp_map<test[],test*>		pm;
		drp_map<test[],test*>		pi;
		drp_map<test[],test*>		il;
		drp_map<test[],test*>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ v1, &t1 }, { v2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_map( pi, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_map( il, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_map( it, {{ v1, &t1 }, { v2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_map( pi, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_map( il, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_map( it, {{ v1, &t1 }, { v2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const test[]>()( p.first, v1 ) ||
				     dp_eql<const test[]>()( p.first, v2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ v2, &t2 }, { v3, &t3 }, { v3, &t4 }, { v3, &t5 }, { v5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
		AssertTrue( check_map( pi, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
		AssertTrue( check_map( il, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
		AssertTrue( check_map( it, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
	}

	// erase
	{
		drp_map<test[],test*>     p {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr } };
		drp_map<test[],test*>     p1( p );

		AssertEqual( p1.erase( v4 ), 1 );
		AssertTrue( check_map( p1, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( v7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( v1 ));
		AssertEqual( p1.erase( v8 ), 1 );
		AssertTrue( check_map( p1, {{ v1, &t1 }, { v5, &t5 }, { v3, &t3 }} ));

		drp_map<test[],test*>     q1( p );
		drp_map<test[],test*>     q2( p );
		drp_map<test[],test*>     q3( p );
		drp_map<test[],test*>     q4( p );

		q1.erase( q1.find( v4 ), q1.upper_bound( v4 ));
		AssertTrue( check_map( q1, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( v4 ));
		AssertTrue( check_map( q2, {{ v5, &t5 }, { v8, &t8 }} ));
		q3.erase( q3.find( v4 ), q3.end());
		AssertTrue( check_map( q3, {{ v1, &t1 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( v4 ), q4.find( v4 ));
		AssertTrue( check_map( q4, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test33()
{
	this->set_subtitle( "emplace/insert/erase, deep pointer(v-array) key - deep pointer(pointer) value" );

	typedef typename dpp_map<test[],test*>::iterator		iterator;
	typedef typename dpp_map<test[],test*>::const_iterator	const_iterator;

	drr_map<const test[],test*>	m1 = {{ v1, &t1 }, { v2, &t2 }};
	drr_map<const test[],test*>	m2;
	drr_map<const test[],test*>	m3 = {{ v2, &t2 }, { v3, &t3 }, { v5, &t5 }};

	// emplace
	{
		dpp_map<test[],test*>		pm;
		dpp_map<test[],test*>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_map( pi, {{ v1, &t1 }, { v2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const test[]>()( i->first, v1 ) ||
				     dp_eql<const test[]>()( i->first, v2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
		AssertTrue( check_map( pi, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
	}

	// insert
	{
		dpp_map<test[],test*>		pm;
		dpp_map<test[],test*>		pi;
		dpp_map<test[],test*>		il;
		dpp_map<test[],test*>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ v1, &t1 }, { v2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_map( pi, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_map( il, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_map( it, {{ v1, &t1 }, { v2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_map( pi, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_map( il, {{ v1, &t1 }, { v2, &t2 }} ));
		AssertTrue( check_map( it, {{ v1, &t1 }, { v2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const test[]>()( p.first, v1 ) ||
				     dp_eql<const test[]>()( p.first, v2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ v2, &t2 }, { v3, &t3 }, { v3, &t4 }, { v3, &t5 }, { v5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
		AssertTrue( check_map( pi, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
		AssertTrue( check_map( il, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
		AssertTrue( check_map( it, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
	}

	// erase
	{
		dpp_map<test[],test*>     p {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr } };
		dpp_map<test[],test*>     p1( p );

		AssertEqual( p1.erase( v4 ), 1 );
		AssertTrue( check_map( p1, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( v7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( v1 ));
		AssertEqual( p1.erase( v8 ), 1 );
		AssertTrue( check_map( p1, {{ v1, &t1 }, { v5, &t5 }, { v3, &t3 }} ));

		dpp_map<test[],test*>     q1( p );
		dpp_map<test[],test*>     q2( p );
		dpp_map<test[],test*>     q3( p );
		dpp_map<test[],test*>     q4( p );

		q1.erase( q1.find( v4 ), q1.upper_bound( v4 ));
		AssertTrue( check_map( q1, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( v4 ));
		AssertTrue( check_map( q2, {{ v5, &t5 }, { v8, &t8 }} ));
		q3.erase( q3.find( v4 ), q3.end());
		AssertTrue( check_map( q3, {{ v1, &t1 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( v4 ), q4.find( v4 ));
		AssertTrue( check_map( q4, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ v1, &t1 }, { v5, &t5 }, { v8, &t8 }, { v4, &t4 }, { v3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test34()
{
	this->set_subtitle( "emplace/insert/erase, reference pointer(f-array) key - deep pointer(pointer) value" );

	typedef typename drp_map<test[3],test*>::iterator		iterator;
	typedef typename drp_map<test[3],test*>::const_iterator	const_iterator;

	drr_map<const test[3],test*>	m1 = {{ w1, &t1 }, { w2, &t2 }};
	drr_map<const test[3],test*>	m2;
	drr_map<const test[3],test*>	m3 = {{ w2, &t2 }, { w3, &t3 }, { w5, &t5 }};

	// emplace
	{
		drp_map<test[3],test*>		pm;
		drp_map<test[3],test*>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_map( pi, {{ w1, &t1 }, { w2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const test[3]>()( i->first, w1 ) ||
				     dp_eql<const test[3]>()( i->first, w2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
		AssertTrue( check_map( pi, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
	}

	// insert
	{
		drp_map<test[3],test*>		pm;
		drp_map<test[3],test*>		pi;
		drp_map<test[3],test*>		il;
		drp_map<test[3],test*>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ w1, &t1 }, { w2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_map( pi, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_map( il, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_map( it, {{ w1, &t1 }, { w2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_map( pi, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_map( il, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_map( it, {{ w1, &t1 }, { w2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const test[3]>()( p.first, w1 ) ||
				     dp_eql<const test[3]>()( p.first, w2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ w2, &t2 }, { w3, &t3 }, { w3, &t4 }, { w3, &t5 }, { w5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
		AssertTrue( check_map( pi, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
		AssertTrue( check_map( il, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
		AssertTrue( check_map( it, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
	}

	// erase
	{
		drp_map<test[3],test*>     p {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr } };
		drp_map<test[3],test*>     p1( p );

		AssertEqual( p1.erase( w4 ), 1 );
		AssertTrue( check_map( p1, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( w7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( w1 ));
		AssertEqual( p1.erase( w8 ), 1 );
		AssertTrue( check_map( p1, {{ w1, &t1 }, { w5, &t5 }, { w3, &t3 }} ));

		drp_map<test[3],test*>     q1( p );
		drp_map<test[3],test*>     q2( p );
		drp_map<test[3],test*>     q3( p );
		drp_map<test[3],test*>     q4( p );

		q1.erase( q1.find( w4 ), q1.upper_bound( w4 ));
		AssertTrue( check_map( q1, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( w4 ));
		AssertTrue( check_map( q2, {{ w5, &t5 }, { w8, &t8 }} ));
		q3.erase( q3.find( w4 ), q3.end());
		AssertTrue( check_map( q3, {{ w1, &t1 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( w4 ), q4.find( w4 ));
		AssertTrue( check_map( q4, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test35()
{
	this->set_subtitle( "emplace/insert/erase, deep pointer(f-array) key - deep pointer(pointer) value" );

	typedef typename dpp_map<test[3],test*>::iterator		iterator;
	typedef typename dpp_map<test[3],test*>::const_iterator	const_iterator;

	drr_map<const test[3],test*>	m1 = {{ w1, &t1 }, { w2, &t2 }};
	drr_map<const test[3],test*>	m2;
	drr_map<const test[3],test*>	m3 = {{ w2, &t2 }, { w3, &t3 }, { w5, &t5 }};

	// emplace
	{
		dpp_map<test[3],test*>		pm;
		dpp_map<test[3],test*>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_map( pi, {{ w1, &t1 }, { w2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<const test[3]>()( i->first, w1 ) ||
				     dp_eql<const test[3]>()( i->first, w2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
		AssertTrue( check_map( pi, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
	}

	// insert
	{
		dpp_map<test[3],test*>		pm;
		dpp_map<test[3],test*>		pi;
		dpp_map<test[3],test*>		il;
		dpp_map<test[3],test*>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ w1, &t1 }, { w2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_map( pi, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_map( il, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_map( it, {{ w1, &t1 }, { w2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_map( pi, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_map( il, {{ w1, &t1 }, { w2, &t2 }} ));
		AssertTrue( check_map( it, {{ w1, &t1 }, { w2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<const test[3]>()( p.first, w1 ) ||
				     dp_eql<const test[3]>()( p.first, w2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ w2, &t2 }, { w3, &t3 }, { w3, &t4 }, { w3, &t5 }, { w5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
		AssertTrue( check_map( pi, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
		AssertTrue( check_map( il, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
		AssertTrue( check_map( it, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
	}

	// erase
	{
		dpp_map<test[3],test*>     p {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr } };
		dpp_map<test[3],test*>     p1( p );

		AssertEqual( p1.erase( w4 ), 1 );
		AssertTrue( check_map( p1, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w3, &t3 }, { nullptr, nullptr }} ));
		AssertZero( p1.erase( w7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( w1 ));
		AssertEqual( p1.erase( w8 ), 1 );
		AssertTrue( check_map( p1, {{ w1, &t1 }, { w5, &t5 }, { w3, &t3 }} ));

		dpp_map<test[3],test*>     q1( p );
		dpp_map<test[3],test*>     q2( p );
		dpp_map<test[3],test*>     q3( p );
		dpp_map<test[3],test*>     q4( p );

		q1.erase( q1.find( w4 ), q1.upper_bound( w4 ));
		AssertTrue( check_map( q1, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( w4 ));
		AssertTrue( check_map( q2, {{ w5, &t5 }, { w8, &t8 }} ));
		q3.erase( q3.find( w4 ), q3.end());
		AssertTrue( check_map( q3, {{ w1, &t1 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.find( w4 ), q4.find( w4 ));
		AssertTrue( check_map( q4, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ w1, &t1 }, { w5, &t5 }, { w8, &t8 }, { w4, &t4 }, { w3, &t3 }, { nullptr, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test36()
{
	this->set_subtitle( "emplace/insert/erase, data(int value) key - deep pointer(pointer) value" );

	typedef typename dnp_map<int,test*>::iterator		iterator;
	typedef typename dnp_map<int,test*>::const_iterator	const_iterator;

	dnr_map<int,test*>	m1 = {{ 1, &t1 }, { 2, &t2 }};
	dnr_map<int,test*>	m2;
	dnr_map<int,test*>	m3 = {{ 2, &t2 }, { 3, &t3 }, { 5, &t5 }};

	// emplace
	{
		dnp_map<int,test*>		pm;
		dnp_map<int,test*>		pi;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	// deep compaire
			AssertTrue( r.second );
		}	
		for ( auto i = m1.begin(); i != m1.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );		// deep compaire
		}	

		AssertTrue( check_map( pm, {{ 1, &t1 }, { 2, &t2 }} ));
		AssertTrue( check_map( pi, {{ 1, &t1 }, { 2, &t2 }} ));

		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			r = pm.emplace( i->first, i->second );

			AssertEqual( i->first, r.first->first );	
			AssertTrue(( dp_eql<int>()( i->first, 1 ) ||
				     dp_eql<int>()( i->first, 2 )) ? !r.second : r.second );
		}	
		for ( auto i = m3.begin(); i != m3.end(); ++i )
		{
			j = pi.emplace_hint( j, i->first, i->second );

			AssertEqual( i->first, j->first );
		}	

		AssertTrue( check_map( pm, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }} ));
		AssertTrue( check_map( pi, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }} ));
	}

	// insert
	{
		dnp_map<int,test*>		pm;
		dnp_map<int,test*>		pi;
		dnp_map<int,test*>		il;
		dnp_map<int,test*>		it;
		std::pair<iterator,bool>	r; 
		const_iterator			j = pi.begin();

		for ( auto&& p : m1 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue( r.second );
		}	
		for ( auto&& p : m1 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}
		il.insert( {{ 1, &t1 }, { 2, &t2 }} );
		it.insert( m1.begin(), m1.end());

		AssertTrue( check_map( pm, {{ 1, &t1 }, { 2, &t2 }} ));
		AssertTrue( check_map( pi, {{ 1, &t1 }, { 2, &t2 }} ));
		AssertTrue( check_map( il, {{ 1, &t1 }, { 2, &t2 }} ));
		AssertTrue( check_map( it, {{ 1, &t1 }, { 2, &t2 }} ));

		for ( auto&& p : m2 ) pm.insert( std::forward<decltype( p )>( p ));
		for ( auto&& p : m2 ) j = pi.insert( j, std::forward<decltype( p )>( p ));
		il.insert( { } );
		it.insert( m2.begin(), m2.end());

		AssertTrue( check_map( pm, {{ 1, &t1 }, { 2, &t2 }} ));
		AssertTrue( check_map( pi, {{ 1, &t1 }, { 2, &t2 }} ));
		AssertTrue( check_map( il, {{ 1, &t1 }, { 2, &t2 }} ));
		AssertTrue( check_map( it, {{ 1, &t1 }, { 2, &t2 }} ));

		for ( auto&& p : m3 ) {
			r = pm.insert( std::forward<decltype( p )>( p ));
			AssertEqual( p.first, r.first->first );
			AssertTrue(( dp_eql<int>()( p.first, 1 ) ||
				     dp_eql<int>()( p.first, 2 )) ? !r.second : r.second );
		}	
		for ( auto&& p : m3 ) {
			j = pi.insert( j, std::forward<decltype( p )>( p ));
			AssertEqual( p.first, j->first );
		}

		il.insert( {{ 2, &t2 }, { 3, &t3 }, { 3, &t4 }, { 3, &t5 }, { 5, &t5 }} );
		it.insert( m3.begin(), m3.end());

		AssertTrue( check_map( pm, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }} ));
		AssertTrue( check_map( pi, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }} ));
		AssertTrue( check_map( il, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }} ));
		AssertTrue( check_map( it, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }} ));
	}

	// erase
	{
		dnp_map<int,test*>     p {{ 1, &t1 }, { 5, &t5 }, { 8, &t8 }, { 4, &t4 }, { 3, &t3 }, { 0, nullptr } };
		dnp_map<int,test*>     p1( p );

		AssertEqual( p1.erase( 4 ), 1 );
		AssertTrue( check_map( p1, {{ 1, &t1 }, { 5, &t5 }, { 8, &t8 }, { 3, &t3 }, { 0, nullptr }} ));
		AssertZero( p1.erase( 7 ));
		AssertEqual( p1.erase( p1.begin()), p1.find( 1 ));
		AssertEqual( p1.erase( 8 ), 1 );
		AssertTrue( check_map( p1, {{ 1, &t1 }, { 5, &t5 }, { 3, &t3 }} ));

		dnp_map<int,test*>     q1( p );
		dnp_map<int,test*>     q2( p );
		dnp_map<int,test*>     q3( p );
		dnp_map<int,test*>     q4( p );

		q1.erase( q1.find( 4 ), q1.upper_bound( 4 ));
		AssertTrue( check_map( q1, {{ 1, &t1 }, { 5, &t5 }, { 8, &t8 }, { 3, &t3 }, { 0, nullptr }} ));
		q1.erase( q1.begin(), q1.end());
		AssertTrue( check_map( q1, { } ));
		q2.erase( q2.begin(), q2.upper_bound( 4 ));
		AssertTrue( check_map( q2, {{ 5, &t5 }, { 8, &t8 }} ));
		q3.erase( q3.find( 4 ), q3.end());
		AssertTrue( check_map( q3, {{ 1, &t1 }, { 3, &t3 }, { 0, nullptr }} ));
		q4.erase( q4.find( 4 ), q4.find( 4 ));
		AssertTrue( check_map( q4, {{ 1, &t1 }, { 5, &t5 }, { 8, &t8 }, { 4, &t4 }, { 3, &t3 }, { 0, nullptr }} ));
		q4.erase( q4.begin(), q4.begin());
		AssertTrue( check_map( q4, {{ 1, &t1 }, { 5, &t5 }, { 8, &t8 }, { 4, &t4 }, { 3, &t3 }, { 0, nullptr }} ));
		q4.erase( q4.end(), q4.end());
		AssertTrue( check_map( q4, {{ 1, &t1 }, { 5, &t5 }, { 8, &t8 }, { 4, &t4 }, { 3, &t3 }, { 0, nullptr }} ));
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test37()
{
	this->set_subtitle( "iterator, reference pointer(pointer) key - reference pointer(pointer) value" );

	drr_map<test*,test*>	     pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	{
		drr_map<test*,test*>::iterator   i;
		drr_map<test*,test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = drr_map<test*,test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( &t3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		drr_map<test*,test*>::reverse_iterator   i;
		drr_map<test*,test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = drr_map<test*,test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<drr_map<test*,test*>::const_reverse_iterator>( pm.find( &t2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test38()
{
	this->set_subtitle( "iterator, deep pointer(pointer) key - reference pointer(pointer) value" );

	dpr_map<test*,test*>	     pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	{
		dpr_map<test*,test*>::iterator   i;
		dpr_map<test*,test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = dpr_map<test*,test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( &t3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		dpr_map<test*,test*>::reverse_iterator   i;
		dpr_map<test*,test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = dpr_map<test*,test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<dpr_map<test*,test*>::const_reverse_iterator>( pm.find( &t2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test39()
{
	this->set_subtitle( "iterator, reference pointer(pointer) key - deep pointer(pointer) value" );

	drp_map<test*,test*>	     pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	{
		drp_map<test*,test*>::iterator   i;
		drp_map<test*,test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = drp_map<test*,test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( &t3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		drp_map<test*,test*>::reverse_iterator   i;
		drp_map<test*,test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = drp_map<test*,test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<drp_map<test*,test*>::const_reverse_iterator>( pm.find( &t2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test3A()
{
	this->set_subtitle( "iterator, deep pointer(pointer) key - deep pointer(pointer) value" );

	dpp_map<test*,test*>	     pm = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	{
		dpp_map<test*,test*>::iterator   i;
		dpp_map<test*,test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = dpp_map<test*,test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( &t3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		dpp_map<test*,test*>::reverse_iterator   i;
		dpp_map<test*,test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = dpp_map<test*,test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<dpp_map<test*,test*>::const_reverse_iterator>( pm.find( &t2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test3B()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - reference pointer(c-string) value" );

	drr_map<const char[],const char[]>	     pm = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	{
		drr_map<const char[],const char[]>::iterator   i;
		drr_map<const char[],const char[]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = drr_map<const char[],const char[]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertEqual( i->second, s3 );
				AssertZero( strcmp( i->second, s3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		drr_map<const char[],const char[]>::reverse_iterator   i;
		drr_map<const char[],const char[]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = drr_map<const char[],const char[]>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertEqual( i->second, s1 );
				AssertZero( strcmp( i->second, s1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<drr_map<const char[],const char[]>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test3C()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - deep pointer(c-string) value" );

	drp_map<const char[],const char[]>	     pm = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	{
		drp_map<const char[],const char[]>::iterator   i;
		drp_map<const char[],const char[]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = drp_map<const char[],const char[]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, s3 );
				AssertZero( strcmp( i->second, s3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		drp_map<const char[],const char[]>::reverse_iterator   i;
		drp_map<const char[],const char[]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = drp_map<const char[],const char[]>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, s1 );
				AssertZero( strcmp( i->second, s1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<drp_map<const char[],const char[]>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test3D()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - reference pointer(v-array) value" );

	drr_map<const char[],test[]>	     pm = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	{
		drr_map<const char[],test[]>::iterator   i;
		drr_map<const char[],test[]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = drr_map<const char[],test[]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertEqual( i->second, v3 );
				AssertTrue( dp_eql<test[]>()( i->second, v3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		drr_map<const char[],test[]>::reverse_iterator   i;
		drr_map<const char[],test[]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = drr_map<const char[],test[]>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertEqual( i->second, v1 );
				AssertTrue( dp_eql<test[]>()( i->second, v1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<drr_map<const char[],test[]>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test3E()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - deep pointer(v-array) value" );

	drp_map<const char[],test[]>	     pm = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	{
		drp_map<const char[],test[]>::iterator   i;
		drp_map<const char[],test[]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = drp_map<const char[],test[]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, v3 );
				AssertTrue( dp_eql<test[]>()( i->second, v3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		drp_map<const char[],test[]>::reverse_iterator   i;
		drp_map<const char[],test[]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = drp_map<const char[],test[]>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, v1 );
				AssertTrue( dp_eql<test[]>()( i->second, v1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<drp_map<const char[],test[]>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test3F()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - reference pointer(f-array) value" );

	drr_map<const char[],test[3]>	     pm = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	{
		drr_map<const char[],test[3]>::iterator   i;
		drr_map<const char[],test[3]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = drr_map<const char[],test[3]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertEqual( i->second, w3 );
				AssertTrue( dp_eql<test[3]>()( i->second, w3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		drr_map<const char[],test[3]>::reverse_iterator   i;
		drr_map<const char[],test[3]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = drr_map<const char[],test[3]>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertEqual( i->second, w1 );
				AssertTrue( dp_eql<test[3]>()( i->second, w1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<drr_map<const char[],test[3]>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test40()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - deep pointer(f-array) value" );

	drp_map<const char[],test[3]>	     pm = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	{
		drp_map<const char[],test[3]>::iterator   i;
		drp_map<const char[],test[3]>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = drp_map<const char[],test[3]>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, w3 );
				AssertTrue( dp_eql<test[3]>()( i->second, w3 ));
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		drp_map<const char[],test[3]>::reverse_iterator   i;
		drp_map<const char[],test[3]>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = drp_map<const char[],test[3]>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, w1 );
				AssertTrue( dp_eql<test[3]>()( i->second, w1 ));
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<drp_map<const char[],test[3]>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test41()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - data(int value) value" );

	drn_map<const char[],int>	     pm = {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }};
	{
		drn_map<const char[],int>::iterator   i;
		drn_map<const char[],int>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = drn_map<const char[],int>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());


				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		drn_map<const char[],int>::reverse_iterator   i;
		drn_map<const char[],int>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = drn_map<const char[],int>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());


				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<drn_map<const char[],int>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test42()
{
	this->set_subtitle( "iterator, reference pointer(c-string) key - deep pointer(pointer) value" );

	drp_map<const char[],test*>	     pm = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	{
		drp_map<const char[],test*>::iterator   i;
		drp_map<const char[],test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = drp_map<const char[],test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		drp_map<const char[],test*>::reverse_iterator   i;
		drp_map<const char[],test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = drp_map<const char[],test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<drp_map<const char[],test*>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test43()
{
	this->set_subtitle( "iterator, deep pointer(c-string) key - deep pointer(pointer) value" );

	dpp_map<const char[],test*>	     pm = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	{
		dpp_map<const char[],test*>::iterator   i;
		dpp_map<const char[],test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = dpp_map<const char[],test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( s3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		dpp_map<const char[],test*>::reverse_iterator   i;
		dpp_map<const char[],test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = dpp_map<const char[],test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<dpp_map<const char[],test*>::const_reverse_iterator>( pm.find( s2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test44()
{
	this->set_subtitle( "iterator, reference pointer(v-array) key - deep pointer(pointer) value" );

	drp_map<test[],test*>	     pm = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	{
		drp_map<test[],test*>::iterator   i;
		drp_map<test[],test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = drp_map<test[],test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( v3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		drp_map<test[],test*>::reverse_iterator   i;
		drp_map<test[],test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = drp_map<test[],test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<drp_map<test[],test*>::const_reverse_iterator>( pm.find( v2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test45()
{
	this->set_subtitle( "iterator, deep pointer(v-array) key - deep pointer(pointer) value" );

	dpp_map<test[],test*>	     pm = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	{
		dpp_map<test[],test*>::iterator   i;
		dpp_map<test[],test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = dpp_map<test[],test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( v3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		dpp_map<test[],test*>::reverse_iterator   i;
		dpp_map<test[],test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = dpp_map<test[],test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<dpp_map<test[],test*>::const_reverse_iterator>( pm.find( v2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test46()
{
	this->set_subtitle( "iterator, reference pointer(f-array) key - deep pointer(pointer) value" );

	drp_map<test[3],test*>	     pm = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	{
		drp_map<test[3],test*>::iterator   i;
		drp_map<test[3],test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = drp_map<test[3],test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( w3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		drp_map<test[3],test*>::reverse_iterator   i;
		drp_map<test[3],test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = drp_map<test[3],test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<drp_map<test[3],test*>::const_reverse_iterator>( pm.find( w2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test47()
{
	this->set_subtitle( "iterator, deep pointer(f-array) key - deep pointer(pointer) value" );

	dpp_map<test[3],test*>	     pm = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	{
		dpp_map<test[3],test*>::iterator   i;
		dpp_map<test[3],test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = dpp_map<test[3],test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( w3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		dpp_map<test[3],test*>::reverse_iterator   i;
		dpp_map<test[3],test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = dpp_map<test[3],test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<dpp_map<test[3],test*>::const_reverse_iterator>( pm.find( w2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test48()
{
	this->set_subtitle( "iterator, data(int value) key - deep pointer(pointer) value" );

	dnp_map<int,test*>	     pm = {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }};
	{
		dnp_map<int,test*>::iterator   i;
		dnp_map<int,test*>::const_iterator     j, k;
		unsigned			c;

		for ( i = pm.begin(), c = 0; i != pm.end(); ++i, ++c ) {
			if ( c == 1 ) k = dnp_map<int,test*>::iterator( i );
			if ( c == 2 ) {
				AssertNotEqual( i, pm.end());
				AssertNotEqual( i->second, &t3 );
				AssertEqual( *i->second, t3 );
				j = i;
			}
		}
		AssertEqual( i, pm.end());
		AssertEqual( c, 4 );
		AssertEqual( pm.find( 3 ), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
	{
		dnp_map<int,test*>::reverse_iterator   i;
		dnp_map<int,test*>::const_reverse_iterator     j, k;
		unsigned				c;

		for ( i = pm.rbegin(), c = 0; i != pm.rend(); ++i, ++c ) {
			if ( c == 2 ) k = dnp_map<int,test*>::reverse_iterator( i );
			if ( c == 3 ) {
				AssertNotEqual( i, pm.rend());
				AssertNotEqual( i->second, &t1 );
				AssertEqual( *i->second, t1 );
				j = i;
			}
		}
		AssertEqual( i, pm.rend());
		AssertEqual( c, 4 );
		AssertEqual( static_cast<dnp_map<int,test*>::const_reverse_iterator>( pm.find( 2 )), j );
		AssertTrue( k != j );
		AssertTrue( ++k == j );
	}
}

// -----------------------------------------------------------------------------
void dp_maptest::test49()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(pointer) key - reference pointer(pointer) value" );

	drr_map<test*,test*>	r1;
	drr_map<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	drr_map<test*,test*>	r3 = {{ &t4, &t4 }, { &t5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	AssertTrue( check_map( r2, {{ &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( &t1 ), 1 );
	AssertEqual( r1.count( &t3 ), 1 );
	AssertEqual( r1.count( &t4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test4A()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), deep pointer(pointer) key - reference pointer(pointer) value" );

	dpr_map<test*,test*>	r1;
	dpr_map<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	dpr_map<test*,test*>	r3 = {{ &t4, &t4 }, { &t5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	AssertTrue( check_map( r2, {{ &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( &t1 ), 1 );
	AssertEqual( r1.count( &t3 ), 1 );
	AssertEqual( r1.count( &t4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test4B()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(pointer) key - deep pointer(pointer) value" );

	drp_map<test*,test*>	r1;
	drp_map<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	drp_map<test*,test*>	r3 = {{ &t4, &t4 }, { &t5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	AssertTrue( check_map( r2, {{ &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( &t1 ), 1 );
	AssertEqual( r1.count( &t3 ), 1 );
	AssertEqual( r1.count( &t4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test4C()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), deep pointer(pointer) key - deep pointer(pointer) value" );

	dpp_map<test*,test*>	r1;
	dpp_map<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	dpp_map<test*,test*>	r3 = {{ &t4, &t4 }, { &t5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }} ));
	AssertTrue( check_map( r2, {{ &t4, &t4 }, { &t5, &t5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( &t1 ), 1 );
	AssertEqual( r1.count( &t3 ), 1 );
	AssertEqual( r1.count( &t4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test4D()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - reference pointer(c-string) value" );

	drr_map<const char[],const char[]>	r1;
	drr_map<const char[],const char[]>	r2 = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	drr_map<const char[],const char[]>	r3 = {{ s4, s4 }, { s5, s5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
	AssertTrue( check_map( r2, {{ s4, s4 }, { s5, s5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test4E()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - deep pointer(c-string) value" );

	drp_map<const char[],const char[]>	r1;
	drp_map<const char[],const char[]>	r2 = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	drp_map<const char[],const char[]>	r3 = {{ s4, s4 }, { s5, s5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }} ));
	AssertTrue( check_map( r2, {{ s4, s4 }, { s5, s5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test4F()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - reference pointer(v-array) value" );

	drr_map<const char[],test[]>	r1;
	drr_map<const char[],test[]>	r2 = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	drr_map<const char[],test[]>	r3 = {{ s4, v4 }, { s5, v5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
	AssertTrue( check_map( r2, {{ s4, v4 }, { s5, v5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test50()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - deep pointer(v-array) value" );

	drp_map<const char[],test[]>	r1;
	drp_map<const char[],test[]>	r2 = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	drp_map<const char[],test[]>	r3 = {{ s4, v4 }, { s5, v5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }} ));
	AssertTrue( check_map( r2, {{ s4, v4 }, { s5, v5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test51()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - reference pointer(f-array) value" );

	drr_map<const char[],test[3]>	r1;
	drr_map<const char[],test[3]>	r2 = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	drr_map<const char[],test[3]>	r3 = {{ s4, w4 }, { s5, w5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
	AssertTrue( check_map( r2, {{ s4, w4 }, { s5, w5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test52()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - deep pointer(f-array) value" );

	drp_map<const char[],test[3]>	r1;
	drp_map<const char[],test[3]>	r2 = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	drp_map<const char[],test[3]>	r3 = {{ s4, w4 }, { s5, w5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }} ));
	AssertTrue( check_map( r2, {{ s4, w4 }, { s5, w5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test53()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - data(int value) value" );

	drn_map<const char[],int>	r1;
	drn_map<const char[],int>	r2 = {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }};
	drn_map<const char[],int>	r3 = {{ s4, 4 }, { s5, 5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }} ));
	AssertTrue( check_map( r2, {{ s4, 4 }, { s5, 5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test54()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(c-string) key - deep pointer(pointer) value" );

	drp_map<const char[],test*>	r1;
	drp_map<const char[],test*>	r2 = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	drp_map<const char[],test*>	r3 = {{ s4, &t4 }, { s5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
	AssertTrue( check_map( r2, {{ s4, &t4 }, { s5, &t5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test55()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), deep pointer(c-string) key - deep pointer(pointer) value" );

	dpp_map<const char[],test*>	r1;
	dpp_map<const char[],test*>	r2 = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	dpp_map<const char[],test*>	r3 = {{ s4, &t4 }, { s5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }} ));
	AssertTrue( check_map( r2, {{ s4, &t4 }, { s5, &t5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( s1 ), 1 );
	AssertEqual( r1.count( s3 ), 1 );
	AssertEqual( r1.count( s4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test56()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(v-array) key - deep pointer(pointer) value" );

	drp_map<test[],test*>	r1;
	drp_map<test[],test*>	r2 = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	drp_map<test[],test*>	r3 = {{ v4, &t4 }, { v5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
	AssertTrue( check_map( r2, {{ v4, &t4 }, { v5, &t5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( v1 ), 1 );
	AssertEqual( r1.count( v3 ), 1 );
	AssertEqual( r1.count( v4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test57()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), deep pointer(v-array) key - deep pointer(pointer) value" );

	dpp_map<test[],test*>	r1;
	dpp_map<test[],test*>	r2 = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	dpp_map<test[],test*>	r3 = {{ v4, &t4 }, { v5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }} ));
	AssertTrue( check_map( r2, {{ v4, &t4 }, { v5, &t5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( v1 ), 1 );
	AssertEqual( r1.count( v3 ), 1 );
	AssertEqual( r1.count( v4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test58()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), reference pointer(f-array) key - deep pointer(pointer) value" );

	drp_map<test[3],test*>	r1;
	drp_map<test[3],test*>	r2 = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	drp_map<test[3],test*>	r3 = {{ w4, &t4 }, { w5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
	AssertTrue( check_map( r2, {{ w4, &t4 }, { w5, &t5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( w1 ), 1 );
	AssertEqual( r1.count( w3 ), 1 );
	AssertEqual( r1.count( w4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test59()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), deep pointer(f-array) key - deep pointer(pointer) value" );

	dpp_map<test[3],test*>	r1;
	dpp_map<test[3],test*>	r2 = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	dpp_map<test[3],test*>	r3 = {{ w4, &t4 }, { w5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }} ));
	AssertTrue( check_map( r2, {{ w4, &t4 }, { w5, &t5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( w1 ), 1 );
	AssertEqual( r1.count( w3 ), 1 );
	AssertEqual( r1.count( w4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test5A()
{
	this->set_subtitle( "miscellaneous (swap/count/size/empty/clear), data(int value) key - deep pointer(pointer) value" );

	dnp_map<int,test*>	r1;
	dnp_map<int,test*>	r2 = {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }};
	dnp_map<int,test*>	r3 = {{ 4, &t4 }, { 5, &t5 }};

	// swap
	r1.swap( r2 );
	r2.swap( r3 );
	AssertTrue( check_map( r1, {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }} ));
	AssertTrue( check_map( r2, {{ 4, &t4 }, { 5, &t5 }} ));
	AssertTrue( check_map( r3, { } ));

	// size, count
	AssertEqual( r1.size(), 4 );
	AssertEqual( r3.size(), 0 );
	AssertEqual( r1.count( 1 ), 1 );
	AssertEqual( r1.count( 3 ), 1 );
	AssertEqual( r1.count( 4 ), 0 );

	// empty, clear
	AssertFalse( r1.empty());
	r1.clear();
	AssertTrue( r1.empty());
	AssertTrue( check_map( r1, { } ));
}

// -----------------------------------------------------------------------------
void dp_maptest::test5B()
{
	this->set_subtitle( "relational operators, reference pointer(pointer) key - reference pointer(pointer) value" );

	drr_map<test*,test*>	r1 = {{ &t1, &t1 }, { &t2, &t2 }};
	drr_map<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	drr_map<test*,test*>	r3 = {{ &t1, &t1 }, { &t3, &t3 }, { &t2, &t2 }};
	drr_map<test*,test*>	r4 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	drr_map<test*,test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test5C()
{
	this->set_subtitle( "relational operators, deep pointer(pointer) key - reference pointer(pointer) value" );

	dpr_map<test*,test*>	r1 = {{ &t1, &t1 }, { &t2, &t2 }};
	dpr_map<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	dpr_map<test*,test*>	r3 = {{ &t1, &t1 }, { &t3, &t3 }, { &t2, &t2 }};
	dpr_map<test*,test*>	r4 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	dpr_map<test*,test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test5D()
{
	this->set_subtitle( "relational operators, reference pointer(pointer) key - deep pointer(pointer) value" );

	drp_map<test*,test*>	r1 = {{ &t1, &t1 }, { &t2, &t2 }};
	drp_map<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	drp_map<test*,test*>	r3 = {{ &t1, &t1 }, { &t3, &t3 }, { &t2, &t2 }};
	drp_map<test*,test*>	r4 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	drp_map<test*,test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test5E()
{
	this->set_subtitle( "relational operators, deep pointer(pointer) key - deep pointer(pointer) value" );

	dpp_map<test*,test*>	r1 = {{ &t1, &t1 }, { &t2, &t2 }};
	dpp_map<test*,test*>	r2 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	dpp_map<test*,test*>	r3 = {{ &t1, &t1 }, { &t3, &t3 }, { &t2, &t2 }};
	dpp_map<test*,test*>	r4 = {{ &t1, &t1 }, { &t2, &t2 }, { &t3, &t3 }, { &t5, &t5 }};
	dpp_map<test*,test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test5F()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - reference pointer(c-string) value" );

	drr_map<const char[],const char[]>	r1 = {{ s1, s1 }, { s2, s2 }};
	drr_map<const char[],const char[]>	r2 = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	drr_map<const char[],const char[]>	r3 = {{ s1, s1 }, { s3, s3 }, { s2, s2 }};
	drr_map<const char[],const char[]>	r4 = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	drr_map<const char[],const char[]>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test60()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - deep pointer(c-string) value" );

	drp_map<const char[],const char[]>	r1 = {{ s1, s1 }, { s2, s2 }};
	drp_map<const char[],const char[]>	r2 = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	drp_map<const char[],const char[]>	r3 = {{ s1, s1 }, { s3, s3 }, { s2, s2 }};
	drp_map<const char[],const char[]>	r4 = {{ s1, s1 }, { s2, s2 }, { s3, s3 }, { s5, s5 }};
	drp_map<const char[],const char[]>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test61()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - reference pointer(v-array) value" );

	drr_map<const char[],test[]>	r1 = {{ s1, v1 }, { s2, v2 }};
	drr_map<const char[],test[]>	r2 = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	drr_map<const char[],test[]>	r3 = {{ s1, v1 }, { s3, v3 }, { s2, v2 }};
	drr_map<const char[],test[]>	r4 = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	drr_map<const char[],test[]>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test62()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - deep pointer(v-array) value" );

	drp_map<const char[],test[]>	r1 = {{ s1, v1 }, { s2, v2 }};
	drp_map<const char[],test[]>	r2 = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	drp_map<const char[],test[]>	r3 = {{ s1, v1 }, { s3, v3 }, { s2, v2 }};
	drp_map<const char[],test[]>	r4 = {{ s1, v1 }, { s2, v2 }, { s3, v3 }, { s5, v5 }};
	drp_map<const char[],test[]>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test63()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - reference pointer(f-array) value" );

	drr_map<const char[],test[3]>	r1 = {{ s1, w1 }, { s2, w2 }};
	drr_map<const char[],test[3]>	r2 = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	drr_map<const char[],test[3]>	r3 = {{ s1, w1 }, { s3, w3 }, { s2, w2 }};
	drr_map<const char[],test[3]>	r4 = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	drr_map<const char[],test[3]>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test64()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - deep pointer(f-array) value" );

	drp_map<const char[],test[3]>	r1 = {{ s1, w1 }, { s2, w2 }};
	drp_map<const char[],test[3]>	r2 = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	drp_map<const char[],test[3]>	r3 = {{ s1, w1 }, { s3, w3 }, { s2, w2 }};
	drp_map<const char[],test[3]>	r4 = {{ s1, w1 }, { s2, w2 }, { s3, w3 }, { s5, w5 }};
	drp_map<const char[],test[3]>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test65()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - data(int value) value" );

	drn_map<const char[],int>	r1 = {{ s1, 1 }, { s2, 2 }};
	drn_map<const char[],int>	r2 = {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }};
	drn_map<const char[],int>	r3 = {{ s1, 1 }, { s3, 3 }, { s2, 2 }};
	drn_map<const char[],int>	r4 = {{ s1, 1 }, { s2, 2 }, { s3, 3 }, { s5, 5 }};
	drn_map<const char[],int>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test66()
{
	this->set_subtitle( "relational operators, reference pointer(c-string) key - deep pointer(pointer) value" );

	drp_map<const char[],test*>	r1 = {{ s1, &t1 }, { s2, &t2 }};
	drp_map<const char[],test*>	r2 = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	drp_map<const char[],test*>	r3 = {{ s1, &t1 }, { s3, &t3 }, { s2, &t2 }};
	drp_map<const char[],test*>	r4 = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	drp_map<const char[],test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test67()
{
	this->set_subtitle( "relational operators, deep pointer(c-string) key - deep pointer(pointer) value" );

	dpp_map<const char[],test*>	r1 = {{ s1, &t1 }, { s2, &t2 }};
	dpp_map<const char[],test*>	r2 = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	dpp_map<const char[],test*>	r3 = {{ s1, &t1 }, { s3, &t3 }, { s2, &t2 }};
	dpp_map<const char[],test*>	r4 = {{ s1, &t1 }, { s2, &t2 }, { s3, &t3 }, { s5, &t5 }};
	dpp_map<const char[],test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test68()
{
	this->set_subtitle( "relational operators, reference pointer(v-array) key - deep pointer(pointer) value" );

	drp_map<test[],test*>	r1 = {{ v1, &t1 }, { v2, &t2 }};
	drp_map<test[],test*>	r2 = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	drp_map<test[],test*>	r3 = {{ v1, &t1 }, { v3, &t3 }, { v2, &t2 }};
	drp_map<test[],test*>	r4 = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	drp_map<test[],test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test69()
{
	this->set_subtitle( "relational operators, deep pointer(v-array) key - deep pointer(pointer) value" );

	dpp_map<test[],test*>	r1 = {{ v1, &t1 }, { v2, &t2 }};
	dpp_map<test[],test*>	r2 = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	dpp_map<test[],test*>	r3 = {{ v1, &t1 }, { v3, &t3 }, { v2, &t2 }};
	dpp_map<test[],test*>	r4 = {{ v1, &t1 }, { v2, &t2 }, { v3, &t3 }, { v5, &t5 }};
	dpp_map<test[],test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test6A()
{
	this->set_subtitle( "relational operators, reference pointer(f-array) key - deep pointer(pointer) value" );

	drp_map<test[3],test*>	r1 = {{ w1, &t1 }, { w2, &t2 }};
	drp_map<test[3],test*>	r2 = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	drp_map<test[3],test*>	r3 = {{ w1, &t1 }, { w3, &t3 }, { w2, &t2 }};
	drp_map<test[3],test*>	r4 = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	drp_map<test[3],test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test6B()
{
	this->set_subtitle( "relational operators, deep pointer(f-array) key - deep pointer(pointer) value" );

	dpp_map<test[3],test*>	r1 = {{ w1, &t1 }, { w2, &t2 }};
	dpp_map<test[3],test*>	r2 = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	dpp_map<test[3],test*>	r3 = {{ w1, &t1 }, { w3, &t3 }, { w2, &t2 }};
	dpp_map<test[3],test*>	r4 = {{ w1, &t1 }, { w2, &t2 }, { w3, &t3 }, { w5, &t5 }};
	dpp_map<test[3],test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// -----------------------------------------------------------------------------
void dp_maptest::test6C()
{
	this->set_subtitle( "relational operators, data(int value) key - deep pointer(pointer) value" );

	dnp_map<int,test*>	r1 = {{ 1, &t1 }, { 2, &t2 }};
	dnp_map<int,test*>	r2 = {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }};
	dnp_map<int,test*>	r3 = {{ 1, &t1 }, { 3, &t3 }, { 2, &t2 }};
	dnp_map<int,test*>	r4 = {{ 1, &t1 }, { 2, &t2 }, { 3, &t3 }, { 5, &t5 }};
	dnp_map<int,test*>	r5;

	AssertTrue( r1 < r2 );
	AssertTrue( r2 > r3 );
	AssertTrue( r2 == r4 );
	AssertFalse( r5 >= r1 );
	AssertFalse( r2 > r4 );
	AssertTrue( r1 != r4 );
	AssertTrue( r1 <= r4 );
}

// Main
// -----------------------------------------------------------------------------
int main( int argc, char** argv )
{
	dp_maptest( argc, argv ).run();
	return 0;
}

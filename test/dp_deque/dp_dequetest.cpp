//
// dp_dequetest.cpp test
//
//		generated by gendptest, 2018/12/21
//

#include <dptl/dp_deque.hpp>
#include <dptl/utest.hpp>
#include <dptl/udata.hpp>
#include <cstring>

using namespace dptl;

// Unit Test Classes
// -----------------------------------------------------------------------------
class dp_dequetest : public unittest, public basic_testdata
{
	int		m_cnt;

    public:
	// --- constructor/assignment/destructor ---
	void test01();
	void test02();
	void test03();
	void test04();
	void test05();
	void test06();
	void test07();
	void test08();
	void test09();

	// --- stack/queue operations ---
	void test0A();
	void test0B();
	void test0C();
	void test0D();
	void test0E();
	void test0F();
	void test10();
	void test11();
	void test12();

	// --- list operations (modifier) ---
	void test13();
	void test14();
	void test15();
	void test16();
	void test17();
	void test18();
	void test19();
	void test1A();
	void test1B();

	// --- list operations (accessor) ---
	void test1C();
	void test1D();
	void test1E();
	void test1F();
	void test20();
	void test21();
	void test22();
	void test23();
	void test24();

	// --- iterator ---
	void test25();
	void test26();
	void test27();
	void test28();
	void test29();
	void test2A();
	void test2B();
	void test2C();
	void test2D();

	// --- list operations (miscellaneous) ---
	void test2E();
	void test2F();
	void test30();
	void test31();
	void test32();
	void test33();
	void test34();
	void test35();
	void test36();

	// --- relational operators ---
	void test37();
	void test38();
	void test39();
	void test3A();
	void test3B();
	void test3C();
	void test3D();
	void test3E();
	void test3F();

	// --- list duplication ---
	void test40();
	void test41();
	void test42();
	void test43();
	void test44();
	void test45();
	void test46();
	void test47();
	void test48();

	// --- heterogenious list ---
	void test49();

	// --- temporal ---
	void test4A();

	dp_dequetest( int argc, char** argv ) : unittest( argc, argv )
	{
		m_cnt = test::getCntr();
		fprintf( stderr, "*** test::getCntr() : %d\n", m_cnt );
	}

	~dp_dequetest()
	{
		this->set_subtitle( "test class allocation" );
		AssertEqual( m_cnt, test::getCntr() );
		fprintf( stderr, "\n" );
	}
};

// Testdata Check Utilities
// -----------------------------------------------------------------------------
template <typename T>
inline bool check_deque( dp_deque<T> const& ls, std::initializer_list<typename value_p<T>::t> const& ts )
{
	dr_deque<T>	l;

	for ( auto&& a : ts ) l.push_back( a );

	return ls == reinterpret_cast<dp_deque<T> const&>( l );
}

template <typename T>
inline bool check_deque( dr_deque<T> const& ls, std::initializer_list<typename value_p<T>::t> const& ts )
{
	dr_deque<T>	l;

	for ( auto&& a : ts ) l.push_back( a );

	return ls == l;
}

template <typename T>
inline bool check_deque( std::deque<T> const& ls, std::initializer_list<typename value_p<T>::t> const& ts )
{
	std::deque<T>	l;

	for ( auto&& a : ts ) l.push_back( a );

	return ls == l;
}

// -----------------------------------------------------------------------------
void dp_dequetest::test01()
{
	this->set_subtitle( "constructor/assignment/destructor - reference pointer(pointer) value" );

	// default constructor
	dr_deque<test*>		lr;
	AssertTrue( check_deque( lr, { } ));

	// copy constructor
	dr_deque<test*>		p0( lr );
	const dr_deque<test*>	c0( lr );
	lr.push_back( &t1 );
	dr_deque<test*>		p1( lr );
	const dr_deque<test*>	c1( lr );
	lr.push_back( &t2 );
	lr.push_back( &t3 );
	lr.push_back( &t4 );
	lr.push_back( &t5 );
	dr_deque<test*>		p5( lr );
	const dr_deque<test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_deque( p1, { &t1 } ));
	AssertTrue( check_deque( p5, { &t1, &t2, &t3, &t4, &t5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_deque( c1, { &t1 } ));
	AssertTrue( check_deque( c5, { &t1, &t2, &t3, &t4, &t5 } ));

	fprintf( stderr, "--- move constructor ---\n" );
	{
		dr_deque<test*>	lx = lr;
		dr_deque<test*>	ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { &t1, &t2, &t3, &t4, &t5 } ));
	}
	fprintf( stderr, "--- copy assignment operator ---\n" );
	{
		dr_deque<test*>	lx;

		lx = p1;
		AssertTrue( check_deque( lx, { &t1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
	}
	fprintf( stderr, "--- move assignment operator ---\n" );
	{
		dr_deque<test*>	lx;

		lr = p1;
		lx = dr_deque<test*>( { &t5, &t3, &t2 } );				// move assignment by r-value
		AssertTrue( check_deque( lx, { &t5, &t3, &t2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_deque( lx, { &t1 } ));
		AssertTrue( check_deque( lr, {} ));			// not mandatory

		//lx = std::move( lx );
		//AssertTrue( check_deque( lx, { &t1 } ));		// Opps! problem of std::deque impl.
	}
	fprintf( stderr, "--- iterator constructor ---\n" );
	{
		dr_deque<test*>	lx = p5;

		dr_deque<test*>	x3( lx.begin(), lx.begin() += 3 );
		AssertTrue( check_deque( x3, { &t1, &t2, &t3 } ));
		dr_deque<test*>	x0( lx.begin() += 2, lx.begin() += 2 );
		AssertTrue( x0.empty());
		dr_deque<test*>	x1( lx.begin() += 4, lx.end());
		AssertTrue( check_deque( x1, { &t5 } ));
	}
	fprintf( stderr, "--- fill constructor ---\n" );
	{
		dr_deque<test*>	x0( 3 );
		AssertTrue( check_deque( x0, { nullptr, nullptr, nullptr } ));
		dr_deque<test*>	x1( 2, nullptr );
		AssertTrue( check_deque( x1, { nullptr, nullptr } ));
		dr_deque<test*>	x2( 4, &t3 );
		AssertTrue( check_deque( x2, { &t3, &t3, &t3, &t3 } ));
	}
	fprintf( stderr, "--- initializer constructor/assignment operator ---\n" );
	{
		dr_deque<test*>	lx = p5;
		dr_deque<test*>	x0 { };
		dr_deque<test*>	x1 { &t1 };
		dr_deque<test*>	x5 { &t1, &t2, &t3, &t4, &t5 };

		AssertTrue( x0.empty());
		AssertTrue( check_deque( x1, { &t1 } ));
		AssertTrue( check_deque( x5, { &t1, &t2, &t3, &t4, &t5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { &t1 };
		AssertTrue( check_deque( lx, { &t1 } ));
		lx = { &t1, &t2, &t3, &t4, &t5 };
		AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test02()
{
	this->set_subtitle( "constructor/assignment/destructor - deep pointer(pointer) value" );

	// default constructor
	dp_deque<test*>		lr;
	AssertTrue( check_deque( lr, { } ));

	// copy constructor
	dp_deque<test*>		p0( lr );
	const dp_deque<test*>	c0( lr );
	lr.push_back( dpl( &t1 ) );
	dp_deque<test*>		p1( lr );
	const dp_deque<test*>	c1( lr );
	lr.push_back( dpl( &t2 ) );
	lr.push_back( dpl( &t3 ) );
	lr.push_back( dpl( &t4 ) );
	lr.push_back( dpl( &t5 ) );
	dp_deque<test*>		p5( lr );
	const dp_deque<test*>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_deque( p1, { &t1 } ));
	AssertTrue( check_deque( p5, { &t1, &t2, &t3, &t4, &t5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_deque( c1, { &t1 } ));
	AssertTrue( check_deque( c5, { &t1, &t2, &t3, &t4, &t5 } ));

	fprintf( stderr, "--- move constructor ---\n" );
	{
		dp_deque<test*>	lx = lr;
		dp_deque<test*>	ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { &t1, &t2, &t3, &t4, &t5 } ));
	}
	fprintf( stderr, "--- copy assignment operator ---\n" );
	{
		dp_deque<test*>	lx;

		lx = p1;
		AssertTrue( check_deque( lx, { &t1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
	}
	fprintf( stderr, "--- move assignment operator ---\n" );
	{
		dp_deque<test*>	lx;

		lr = p1;
		lx = dp_deque<test*>( { &t5, &t3, &t2 } );				// move assignment by r-value
		AssertTrue( check_deque( lx, { &t5, &t3, &t2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_deque( lx, { &t1 } ));
		AssertTrue( check_deque( lr, {} ));			// not mandatory

		//lx = std::move( lx );
		//AssertTrue( check_deque( lx, { &t1 } ));		// Opps! problem of std::deque impl.
	}
	fprintf( stderr, "--- iterator constructor ---\n" );
	{
		dp_deque<test*>	lx = p5;

		dp_deque<test*>	x3( lx.begin(), lx.begin() += 3 );
		AssertTrue( check_deque( x3, { &t1, &t2, &t3 } ));
		dp_deque<test*>	x0( lx.begin() += 2, lx.begin() += 2 );
		AssertTrue( x0.empty());
		dp_deque<test*>	x1( lx.begin() += 4, lx.end());
		AssertTrue( check_deque( x1, { &t5 } ));
	}
	fprintf( stderr, "--- fill constructor ---\n" );
	{
		dp_deque<test*>	x0( 3 );
		AssertTrue( check_deque( x0, { nullptr, nullptr, nullptr } ));
		dp_deque<test*>	x1( 2, nullptr );
		AssertTrue( check_deque( x1, { nullptr, nullptr } ));
		dp_deque<test*>	x2( 4, &t3 );
		AssertTrue( check_deque( x2, { &t3, &t3, &t3, &t3 } ));
	}
	fprintf( stderr, "--- initializer constructor/assignment operator ---\n" );
	{
		dp_deque<test*>	lx = p5;
		dp_deque<test*>	x0 { };
		dp_deque<test*>	x1 { &t1 };
		dp_deque<test*>	x5 { &t1, &t2, &t3, &t4, &t5 };

		AssertTrue( x0.empty());
		AssertTrue( check_deque( x1, { &t1 } ));
		AssertTrue( check_deque( x5, { &t1, &t2, &t3, &t4, &t5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { &t1 };
		AssertTrue( check_deque( lx, { &t1 } ));
		lx = { &t1, &t2, &t3, &t4, &t5 };
		AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test03()
{
	this->set_subtitle( "constructor/assignment/destructor - reference pointer(c-string) value" );

	// default constructor
	dr_deque<const char[]>		lr;
	AssertTrue( check_deque( lr, { } ));

	// copy constructor
	dr_deque<const char[]>		p0( lr );
	const dr_deque<const char[]>	c0( lr );
	lr.push_back( s1 );
	dr_deque<const char[]>		p1( lr );
	const dr_deque<const char[]>	c1( lr );
	lr.push_back( s2 );
	lr.push_back( s3 );
	lr.push_back( s4 );
	lr.push_back( s5 );
	dr_deque<const char[]>		p5( lr );
	const dr_deque<const char[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_deque( p1, { s1 } ));
	AssertTrue( check_deque( p5, { s1, s2, s3, s4, s5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_deque( c1, { s1 } ));
	AssertTrue( check_deque( c5, { s1, s2, s3, s4, s5 } ));

	fprintf( stderr, "--- move constructor ---\n" );
	{
		dr_deque<const char[]>	lx = lr;
		dr_deque<const char[]>	ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { s1, s2, s3, s4, s5 } ));
	}
	fprintf( stderr, "--- copy assignment operator ---\n" );
	{
		dr_deque<const char[]>	lx;

		lx = p1;
		AssertTrue( check_deque( lx, { s1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
	}
	fprintf( stderr, "--- move assignment operator ---\n" );
	{
		dr_deque<const char[]>	lx;

		lr = p1;
		lx = dr_deque<const char[]>( { s5, s3, s2 } );				// move assignment by r-value
		AssertTrue( check_deque( lx, { s5, s3, s2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_deque( lx, { s1 } ));
		AssertTrue( check_deque( lr, {} ));			// not mandatory

		//lx = std::move( lx );
		//AssertTrue( check_deque( lx, { s1 } ));		// Opps! problem of std::deque impl.
	}
	fprintf( stderr, "--- iterator constructor ---\n" );
	{
		dr_deque<const char[]>	lx = p5;

		dr_deque<const char[]>	x3( lx.begin(), lx.begin() += 3 );
		AssertTrue( check_deque( x3, { s1, s2, s3 } ));
		dr_deque<const char[]>	x0( lx.begin() += 2, lx.begin() += 2 );
		AssertTrue( x0.empty());
		dr_deque<const char[]>	x1( lx.begin() += 4, lx.end());
		AssertTrue( check_deque( x1, { s5 } ));
	}
	fprintf( stderr, "--- fill constructor ---\n" );
	{
		dr_deque<const char[]>	x0( 3 );
		AssertTrue( check_deque( x0, { nullptr, nullptr, nullptr } ));
		dr_deque<const char[]>	x1( 2, nullptr );
		AssertTrue( check_deque( x1, { nullptr, nullptr } ));
		dr_deque<const char[]>	x2( 4, s3 );
		AssertTrue( check_deque( x2, { s3, s3, s3, s3 } ));
	}
	fprintf( stderr, "--- initializer constructor/assignment operator ---\n" );
	{
		dr_deque<const char[]>	lx = p5;
		dr_deque<const char[]>	x0 { };
		dr_deque<const char[]>	x1 { s1 };
		dr_deque<const char[]>	x5 { s1, s2, s3, s4, s5 };

		AssertTrue( x0.empty());
		AssertTrue( check_deque( x1, { s1 } ));
		AssertTrue( check_deque( x5, { s1, s2, s3, s4, s5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { s1 };
		AssertTrue( check_deque( lx, { s1 } ));
		lx = { s1, s2, s3, s4, s5 };
		AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test04()
{
	this->set_subtitle( "constructor/assignment/destructor - deep pointer(c-string) value" );

	// default constructor
	dp_deque<const char[]>		lr;
	AssertTrue( check_deque( lr, { } ));

	// copy constructor
	dp_deque<const char[]>		p0( lr );
	const dp_deque<const char[]>	c0( lr );
	lr.push_back( strdup( s1 ) );
	dp_deque<const char[]>		p1( lr );
	const dp_deque<const char[]>	c1( lr );
	lr.push_back( strdup( s2 ) );
	lr.push_back( strdup( s3 ) );
	lr.push_back( strdup( s4 ) );
	lr.push_back( strdup( s5 ) );
	dp_deque<const char[]>		p5( lr );
	const dp_deque<const char[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_deque( p1, { s1 } ));
	AssertTrue( check_deque( p5, { s1, s2, s3, s4, s5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_deque( c1, { s1 } ));
	AssertTrue( check_deque( c5, { s1, s2, s3, s4, s5 } ));

	fprintf( stderr, "--- move constructor ---\n" );
	{
		dp_deque<const char[]>	lx = lr;
		dp_deque<const char[]>	ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { s1, s2, s3, s4, s5 } ));
	}
	fprintf( stderr, "--- copy assignment operator ---\n" );
	{
		dp_deque<const char[]>	lx;

		lx = p1;
		AssertTrue( check_deque( lx, { s1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
	}
	fprintf( stderr, "--- move assignment operator ---\n" );
	{
		dp_deque<const char[]>	lx;

		lr = p1;
		lx = dp_deque<const char[]>( { s5, s3, s2 } );				// move assignment by r-value
		AssertTrue( check_deque( lx, { s5, s3, s2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_deque( lx, { s1 } ));
		AssertTrue( check_deque( lr, {} ));			// not mandatory

		//lx = std::move( lx );
		//AssertTrue( check_deque( lx, { s1 } ));		// Opps! problem of std::deque impl.
	}
	fprintf( stderr, "--- iterator constructor ---\n" );
	{
		dp_deque<const char[]>	lx = p5;

		dp_deque<const char[]>	x3( lx.begin(), lx.begin() += 3 );
		AssertTrue( check_deque( x3, { s1, s2, s3 } ));
		dp_deque<const char[]>	x0( lx.begin() += 2, lx.begin() += 2 );
		AssertTrue( x0.empty());
		dp_deque<const char[]>	x1( lx.begin() += 4, lx.end());
		AssertTrue( check_deque( x1, { s5 } ));
	}
	fprintf( stderr, "--- fill constructor ---\n" );
	{
		dp_deque<const char[]>	x0( 3 );
		AssertTrue( check_deque( x0, { nullptr, nullptr, nullptr } ));
		dp_deque<const char[]>	x1( 2, nullptr );
		AssertTrue( check_deque( x1, { nullptr, nullptr } ));
		dp_deque<const char[]>	x2( 4, s3 );
		AssertTrue( check_deque( x2, { s3, s3, s3, s3 } ));
	}
	fprintf( stderr, "--- initializer constructor/assignment operator ---\n" );
	{
		dp_deque<const char[]>	lx = p5;
		dp_deque<const char[]>	x0 { };
		dp_deque<const char[]>	x1 { s1 };
		dp_deque<const char[]>	x5 { s1, s2, s3, s4, s5 };

		AssertTrue( x0.empty());
		AssertTrue( check_deque( x1, { s1 } ));
		AssertTrue( check_deque( x5, { s1, s2, s3, s4, s5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { s1 };
		AssertTrue( check_deque( lx, { s1 } ));
		lx = { s1, s2, s3, s4, s5 };
		AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test05()
{
	this->set_subtitle( "constructor/assignment/destructor - reference pointer(v-array) value" );

	// default constructor
	dr_deque<test[]>		lr;
	AssertTrue( check_deque( lr, { } ));

	// copy constructor
	dr_deque<test[]>		p0( lr );
	const dr_deque<test[]>	c0( lr );
	lr.push_back( v1 );
	dr_deque<test[]>		p1( lr );
	const dr_deque<test[]>	c1( lr );
	lr.push_back( v2 );
	lr.push_back( v3 );
	lr.push_back( v4 );
	lr.push_back( v5 );
	dr_deque<test[]>		p5( lr );
	const dr_deque<test[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_deque( p1, { v1 } ));
	AssertTrue( check_deque( p5, { v1, v2, v3, v4, v5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_deque( c1, { v1 } ));
	AssertTrue( check_deque( c5, { v1, v2, v3, v4, v5 } ));

	fprintf( stderr, "--- move constructor ---\n" );
	{
		dr_deque<test[]>	lx = lr;
		dr_deque<test[]>	ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { v1, v2, v3, v4, v5 } ));
	}
	fprintf( stderr, "--- copy assignment operator ---\n" );
	{
		dr_deque<test[]>	lx;

		lx = p1;
		AssertTrue( check_deque( lx, { v1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
	}
	fprintf( stderr, "--- move assignment operator ---\n" );
	{
		dr_deque<test[]>	lx;

		lr = p1;
		lx = dr_deque<test[]>( { v5, v3, v2 } );				// move assignment by r-value
		AssertTrue( check_deque( lx, { v5, v3, v2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_deque( lx, { v1 } ));
		AssertTrue( check_deque( lr, {} ));			// not mandatory

		//lx = std::move( lx );
		//AssertTrue( check_deque( lx, { v1 } ));		// Opps! problem of std::deque impl.
	}
	fprintf( stderr, "--- iterator constructor ---\n" );
	{
		dr_deque<test[]>	lx = p5;

		dr_deque<test[]>	x3( lx.begin(), lx.begin() += 3 );
		AssertTrue( check_deque( x3, { v1, v2, v3 } ));
		dr_deque<test[]>	x0( lx.begin() += 2, lx.begin() += 2 );
		AssertTrue( x0.empty());
		dr_deque<test[]>	x1( lx.begin() += 4, lx.end());
		AssertTrue( check_deque( x1, { v5 } ));
	}
	fprintf( stderr, "--- fill constructor ---\n" );
	{
		dr_deque<test[]>	x0( 3 );
		AssertTrue( check_deque( x0, { nullptr, nullptr, nullptr } ));
		dr_deque<test[]>	x1( 2, nullptr );
		AssertTrue( check_deque( x1, { nullptr, nullptr } ));
		dr_deque<test[]>	x2( 4, v3 );
		AssertTrue( check_deque( x2, { v3, v3, v3, v3 } ));
	}
	fprintf( stderr, "--- initializer constructor/assignment operator ---\n" );
	{
		dr_deque<test[]>	lx = p5;
		dr_deque<test[]>	x0 { };
		dr_deque<test[]>	x1 { v1 };
		dr_deque<test[]>	x5 { v1, v2, v3, v4, v5 };

		AssertTrue( x0.empty());
		AssertTrue( check_deque( x1, { v1 } ));
		AssertTrue( check_deque( x5, { v1, v2, v3, v4, v5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { v1 };
		AssertTrue( check_deque( lx, { v1 } ));
		lx = { v1, v2, v3, v4, v5 };
		AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test06()
{
	this->set_subtitle( "constructor/assignment/destructor - deep pointer(v-array) value" );

	// default constructor
	dp_deque<test[]>		lr;
	AssertTrue( check_deque( lr, { } ));

	// copy constructor
	dp_deque<test[]>		p0( lr );
	const dp_deque<test[]>	c0( lr );
	lr.push_back( dpl( v1 ) );
	dp_deque<test[]>		p1( lr );
	const dp_deque<test[]>	c1( lr );
	lr.push_back( dpl( v2 ) );
	lr.push_back( dpl( v3 ) );
	lr.push_back( dpl( v4 ) );
	lr.push_back( dpl( v5 ) );
	dp_deque<test[]>		p5( lr );
	const dp_deque<test[]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_deque( p1, { v1 } ));
	AssertTrue( check_deque( p5, { v1, v2, v3, v4, v5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_deque( c1, { v1 } ));
	AssertTrue( check_deque( c5, { v1, v2, v3, v4, v5 } ));

	fprintf( stderr, "--- move constructor ---\n" );
	{
		dp_deque<test[]>	lx = lr;
		dp_deque<test[]>	ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { v1, v2, v3, v4, v5 } ));
	}
	fprintf( stderr, "--- copy assignment operator ---\n" );
	{
		dp_deque<test[]>	lx;

		lx = p1;
		AssertTrue( check_deque( lx, { v1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
	}
	fprintf( stderr, "--- move assignment operator ---\n" );
	{
		dp_deque<test[]>	lx;

		lr = p1;
		lx = dp_deque<test[]>( { v5, v3, v2 } );				// move assignment by r-value
		AssertTrue( check_deque( lx, { v5, v3, v2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_deque( lx, { v1 } ));
		AssertTrue( check_deque( lr, {} ));			// not mandatory

		//lx = std::move( lx );
		//AssertTrue( check_deque( lx, { v1 } ));		// Opps! problem of std::deque impl.
	}
	fprintf( stderr, "--- iterator constructor ---\n" );
	{
		dp_deque<test[]>	lx = p5;

		dp_deque<test[]>	x3( lx.begin(), lx.begin() += 3 );
		AssertTrue( check_deque( x3, { v1, v2, v3 } ));
		dp_deque<test[]>	x0( lx.begin() += 2, lx.begin() += 2 );
		AssertTrue( x0.empty());
		dp_deque<test[]>	x1( lx.begin() += 4, lx.end());
		AssertTrue( check_deque( x1, { v5 } ));
	}
	fprintf( stderr, "--- fill constructor ---\n" );
	{
		dp_deque<test[]>	x0( 3 );
		AssertTrue( check_deque( x0, { nullptr, nullptr, nullptr } ));
		dp_deque<test[]>	x1( 2, nullptr );
		AssertTrue( check_deque( x1, { nullptr, nullptr } ));
		dp_deque<test[]>	x2( 4, v3 );
		AssertTrue( check_deque( x2, { v3, v3, v3, v3 } ));
	}
	fprintf( stderr, "--- initializer constructor/assignment operator ---\n" );
	{
		dp_deque<test[]>	lx = p5;
		dp_deque<test[]>	x0 { };
		dp_deque<test[]>	x1 { v1 };
		dp_deque<test[]>	x5 { v1, v2, v3, v4, v5 };

		AssertTrue( x0.empty());
		AssertTrue( check_deque( x1, { v1 } ));
		AssertTrue( check_deque( x5, { v1, v2, v3, v4, v5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { v1 };
		AssertTrue( check_deque( lx, { v1 } ));
		lx = { v1, v2, v3, v4, v5 };
		AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test07()
{
	this->set_subtitle( "constructor/assignment/destructor - reference pointer(f-array) value" );

	// default constructor
	dr_deque<test[3]>		lr;
	AssertTrue( check_deque( lr, { } ));

	// copy constructor
	dr_deque<test[3]>		p0( lr );
	const dr_deque<test[3]>	c0( lr );
	lr.push_back( w1 );
	dr_deque<test[3]>		p1( lr );
	const dr_deque<test[3]>	c1( lr );
	lr.push_back( w2 );
	lr.push_back( w3 );
	lr.push_back( w4 );
	lr.push_back( w5 );
	dr_deque<test[3]>		p5( lr );
	const dr_deque<test[3]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_deque( p1, { w1 } ));
	AssertTrue( check_deque( p5, { w1, w2, w3, w4, w5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_deque( c1, { w1 } ));
	AssertTrue( check_deque( c5, { w1, w2, w3, w4, w5 } ));

	fprintf( stderr, "--- move constructor ---\n" );
	{
		dr_deque<test[3]>	lx = lr;
		dr_deque<test[3]>	ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { w1, w2, w3, w4, w5 } ));
	}
	fprintf( stderr, "--- copy assignment operator ---\n" );
	{
		dr_deque<test[3]>	lx;

		lx = p1;
		AssertTrue( check_deque( lx, { w1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
	}
	fprintf( stderr, "--- move assignment operator ---\n" );
	{
		dr_deque<test[3]>	lx;

		lr = p1;
		lx = dr_deque<test[3]>( { w5, w3, w2 } );				// move assignment by r-value
		AssertTrue( check_deque( lx, { w5, w3, w2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_deque( lx, { w1 } ));
		AssertTrue( check_deque( lr, {} ));			// not mandatory

		//lx = std::move( lx );
		//AssertTrue( check_deque( lx, { w1 } ));		// Opps! problem of std::deque impl.
	}
	fprintf( stderr, "--- iterator constructor ---\n" );
	{
		dr_deque<test[3]>	lx = p5;

		dr_deque<test[3]>	x3( lx.begin(), lx.begin() += 3 );
		AssertTrue( check_deque( x3, { w1, w2, w3 } ));
		dr_deque<test[3]>	x0( lx.begin() += 2, lx.begin() += 2 );
		AssertTrue( x0.empty());
		dr_deque<test[3]>	x1( lx.begin() += 4, lx.end());
		AssertTrue( check_deque( x1, { w5 } ));
	}
	fprintf( stderr, "--- fill constructor ---\n" );
	{
		dr_deque<test[3]>	x0( 3 );
		AssertTrue( check_deque( x0, { nullptr, nullptr, nullptr } ));
		dr_deque<test[3]>	x1( 2, nullptr );
		AssertTrue( check_deque( x1, { nullptr, nullptr } ));
		dr_deque<test[3]>	x2( 4, w3 );
		AssertTrue( check_deque( x2, { w3, w3, w3, w3 } ));
	}
	fprintf( stderr, "--- initializer constructor/assignment operator ---\n" );
	{
		dr_deque<test[3]>	lx = p5;
		dr_deque<test[3]>	x0 { };
		dr_deque<test[3]>	x1 { w1 };
		dr_deque<test[3]>	x5 { w1, w2, w3, w4, w5 };

		AssertTrue( x0.empty());
		AssertTrue( check_deque( x1, { w1 } ));
		AssertTrue( check_deque( x5, { w1, w2, w3, w4, w5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { w1 };
		AssertTrue( check_deque( lx, { w1 } ));
		lx = { w1, w2, w3, w4, w5 };
		AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test08()
{
	this->set_subtitle( "constructor/assignment/destructor - deep pointer(f-array) value" );

	// default constructor
	dp_deque<test[3]>		lr;
	AssertTrue( check_deque( lr, { } ));

	// copy constructor
	dp_deque<test[3]>		p0( lr );
	const dp_deque<test[3]>	c0( lr );
	lr.push_back( dpl( w1 ) );
	dp_deque<test[3]>		p1( lr );
	const dp_deque<test[3]>	c1( lr );
	lr.push_back( dpl( w2 ) );
	lr.push_back( dpl( w3 ) );
	lr.push_back( dpl( w4 ) );
	lr.push_back( dpl( w5 ) );
	dp_deque<test[3]>		p5( lr );
	const dp_deque<test[3]>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_deque( p1, { w1 } ));
	AssertTrue( check_deque( p5, { w1, w2, w3, w4, w5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_deque( c1, { w1 } ));
	AssertTrue( check_deque( c5, { w1, w2, w3, w4, w5 } ));

	fprintf( stderr, "--- move constructor ---\n" );
	{
		dp_deque<test[3]>	lx = lr;
		dp_deque<test[3]>	ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { w1, w2, w3, w4, w5 } ));
	}
	fprintf( stderr, "--- copy assignment operator ---\n" );
	{
		dp_deque<test[3]>	lx;

		lx = p1;
		AssertTrue( check_deque( lx, { w1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
	}
	fprintf( stderr, "--- move assignment operator ---\n" );
	{
		dp_deque<test[3]>	lx;

		lr = p1;
		lx = dp_deque<test[3]>( { w5, w3, w2 } );				// move assignment by r-value
		AssertTrue( check_deque( lx, { w5, w3, w2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_deque( lx, { w1 } ));
		AssertTrue( check_deque( lr, {} ));			// not mandatory

		//lx = std::move( lx );
		//AssertTrue( check_deque( lx, { w1 } ));		// Opps! problem of std::deque impl.
	}
	fprintf( stderr, "--- iterator constructor ---\n" );
	{
		dp_deque<test[3]>	lx = p5;

		dp_deque<test[3]>	x3( lx.begin(), lx.begin() += 3 );
		AssertTrue( check_deque( x3, { w1, w2, w3 } ));
		dp_deque<test[3]>	x0( lx.begin() += 2, lx.begin() += 2 );
		AssertTrue( x0.empty());
		dp_deque<test[3]>	x1( lx.begin() += 4, lx.end());
		AssertTrue( check_deque( x1, { w5 } ));
	}
	fprintf( stderr, "--- fill constructor ---\n" );
	{
		dp_deque<test[3]>	x0( 3 );
		AssertTrue( check_deque( x0, { nullptr, nullptr, nullptr } ));
		dp_deque<test[3]>	x1( 2, nullptr );
		AssertTrue( check_deque( x1, { nullptr, nullptr } ));
		dp_deque<test[3]>	x2( 4, w3 );
		AssertTrue( check_deque( x2, { w3, w3, w3, w3 } ));
	}
	fprintf( stderr, "--- initializer constructor/assignment operator ---\n" );
	{
		dp_deque<test[3]>	lx = p5;
		dp_deque<test[3]>	x0 { };
		dp_deque<test[3]>	x1 { w1 };
		dp_deque<test[3]>	x5 { w1, w2, w3, w4, w5 };

		AssertTrue( x0.empty());
		AssertTrue( check_deque( x1, { w1 } ));
		AssertTrue( check_deque( x5, { w1, w2, w3, w4, w5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { w1 };
		AssertTrue( check_deque( lx, { w1 } ));
		lx = { w1, w2, w3, w4, w5 };
		AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test09()
{
	this->set_subtitle( "constructor/assignment/destructor - data(int value) value" );

	// default constructor
	std::deque<int>		lr;
	AssertTrue( check_deque( lr, { } ));

	// copy constructor
	std::deque<int>		p0( lr );
	const std::deque<int>	c0( lr );
	lr.push_back( 1 );
	std::deque<int>		p1( lr );
	const std::deque<int>	c1( lr );
	lr.push_back( 2 );
	lr.push_back( 3 );
	lr.push_back( 4 );
	lr.push_back( 5 );
	std::deque<int>		p5( lr );
	const std::deque<int>	c5( lr );

	AssertTrue( p0.empty());
	AssertTrue( check_deque( p1, { 1 } ));
	AssertTrue( check_deque( p5, { 1, 2, 3, 4, 5 } ));
	AssertTrue( c0.empty());
	AssertTrue( check_deque( c1, { 1 } ));
	AssertTrue( check_deque( c5, { 1, 2, 3, 4, 5 } ));

	fprintf( stderr, "--- move constructor ---\n" );
	{
		std::deque<int>	lx = lr;
		std::deque<int>	ly( std::move( lx ));

		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { 1, 2, 3, 4, 5 } ));
	}
	fprintf( stderr, "--- copy assignment operator ---\n" );
	{
		std::deque<int>	lx;

		lx = p1;
		AssertTrue( check_deque( lx, { 1 } ));
		lx = p0;
		AssertTrue( lx.empty());
		lx = p5;
		AssertTrue( check_deque( lx, { 1, 2, 3, 4, 5 } ));
	}
	fprintf( stderr, "--- move assignment operator ---\n" );
	{
		std::deque<int>	lx;

		lr = p1;
		lx = std::deque<int>( { 5, 3, 2 } );				// move assignment by r-value
		AssertTrue( check_deque( lx, { 5, 3, 2 } ));

		lx = std::move( lr );					// move assignment by std::move()
		AssertTrue( check_deque( lx, { 1 } ));
		AssertTrue( check_deque( lr, {} ));			// not mandatory

		//lx = std::move( lx );
		//AssertTrue( check_deque( lx, { 1 } ));		// Opps! problem of std::deque impl.
	}
	fprintf( stderr, "--- iterator constructor ---\n" );
	{
		std::deque<int>	lx = p5;

		std::deque<int>	x3( lx.begin(), lx.begin() += 3 );
		AssertTrue( check_deque( x3, { 1, 2, 3 } ));
		std::deque<int>	x0( lx.begin() += 2, lx.begin() += 2 );
		AssertTrue( x0.empty());
		std::deque<int>	x1( lx.begin() += 4, lx.end());
		AssertTrue( check_deque( x1, { 5 } ));
	}
	fprintf( stderr, "--- fill constructor ---\n" );
	{
		std::deque<int>	x0( 3 );
		AssertTrue( check_deque( x0, { 0, 0, 0 } ));
		std::deque<int>	x1( 2, 0 );
		AssertTrue( check_deque( x1, { 0, 0 } ));
		std::deque<int>	x2( 4, 3 );
		AssertTrue( check_deque( x2, { 3, 3, 3, 3 } ));
	}
	fprintf( stderr, "--- initializer constructor/assignment operator ---\n" );
	{
		std::deque<int>	lx = p5;
		std::deque<int>	x0 { };
		std::deque<int>	x1 { 1 };
		std::deque<int>	x5 { 1, 2, 3, 4, 5 };

		AssertTrue( x0.empty());
		AssertTrue( check_deque( x1, { 1 } ));
		AssertTrue( check_deque( x5, { 1, 2, 3, 4, 5 } ));

		lx = { };
		AssertTrue( lx.empty());
		lx = { 1 };
		AssertTrue( check_deque( lx, { 1 } ));
		lx = { 1, 2, 3, 4, 5 };
		AssertTrue( check_deque( lx, { 1, 2, 3, 4, 5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test0A()
{
	this->set_subtitle( "stack/queue operations - reference pointer(pointer) value" );

	fprintf( stderr, "--- copy-push ---\n" );
	{
		dr_deque<test*>	lp;

		lp.push_back( static_cast<test* const&>( &t3 ));
		lp.push_front( static_cast<test* const&>( &t2 ));
		lp.push_front( static_cast<test* const&>( &t1 ));

		AssertTrue( check_deque( lp, { &t1, &t2, &t3 } ));

		lp.push_back( static_cast<test* const&>( &t4 ));
		lp.push_front( static_cast<test* const&>( &t0 ));
		lp.pop_front();
		lp.push_back( static_cast<test* const&>( &t5 ));
		lp.push_back( static_cast<test* const&>( &t6 ));
		lp.pop_back();

		AssertTrue( check_deque( lp, { &t1, &t2, &t3, &t4, &t5 } ));
	}
	fprintf( stderr, "--- move-push ---\n" );
	{
		dr_deque<test*>	lp;

		lp.push_back( &t3 );
		lp.push_front( &t2 );
		lp.push_front( &t1 );

		AssertTrue( check_deque( lp, { &t1, &t2, &t3 } ));

		lp.push_back( &t4 );
		lp.push_front( &t0 );
		lp.pop_front();
		lp.push_back( &t5 );
		lp.push_back( &t6 );
		lp.pop_back();

		AssertTrue( check_deque( lp, { &t1, &t2, &t3, &t4, &t5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test0B()
{
	this->set_subtitle( "stack/queue operations - deep pointer(pointer) value" );

	fprintf( stderr, "--- copy-push ---\n" );
	{
		dp_deque<test*>	lp;

		lp.push_back( static_cast<test* const&>( &t3 ));
		lp.push_front( static_cast<test* const&>( &t2 ));
		lp.push_front( static_cast<test* const&>( &t1 ));

		AssertTrue( check_deque( lp, { &t1, &t2, &t3 } ));

		lp.push_back( static_cast<test* const&>( &t4 ));
		lp.push_front( static_cast<test* const&>( &t0 ));
		lp.pop_front();
		lp.push_back( static_cast<test* const&>( &t5 ));
		lp.push_back( static_cast<test* const&>( &t6 ));
		lp.pop_back();

		AssertTrue( check_deque( lp, { &t1, &t2, &t3, &t4, &t5 } ));
	}
	fprintf( stderr, "--- move-push ---\n" );
	{
		dp_deque<test*>	lp;

		lp.push_back( dpl( &t3 ) );
		lp.push_front( dpl( &t2 ) );
		lp.push_front( dpl( &t1 ) );

		AssertTrue( check_deque( lp, { &t1, &t2, &t3 } ));

		lp.push_back( dpl( &t4 ) );
		lp.push_front( dpl( &t0 ) );
		lp.pop_front();
		lp.push_back( dpl( &t5 ) );
		lp.push_back( dpl( &t6 ) );
		lp.pop_back();

		AssertTrue( check_deque( lp, { &t1, &t2, &t3, &t4, &t5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test0C()
{
	this->set_subtitle( "stack/queue operations - reference pointer(c-string) value" );

	fprintf( stderr, "--- copy-push ---\n" );
	{
		dr_deque<const char[]>	lp;

		lp.push_back( static_cast<const char* const&>( s3 ));
		lp.push_front( static_cast<const char* const&>( s2 ));
		lp.push_front( static_cast<const char* const&>( s1 ));

		AssertTrue( check_deque( lp, { s1, s2, s3 } ));

		lp.push_back( static_cast<const char* const&>( s4 ));
		lp.push_front( static_cast<const char* const&>( s0 ));
		lp.pop_front();
		lp.push_back( static_cast<const char* const&>( s5 ));
		lp.push_back( static_cast<const char* const&>( s6 ));
		lp.pop_back();

		AssertTrue( check_deque( lp, { s1, s2, s3, s4, s5 } ));
	}
	fprintf( stderr, "--- move-push ---\n" );
	{
		dr_deque<const char[]>	lp;

		lp.push_back( s3 );
		lp.push_front( s2 );
		lp.push_front( s1 );

		AssertTrue( check_deque( lp, { s1, s2, s3 } ));

		lp.push_back( s4 );
		lp.push_front( s0 );
		lp.pop_front();
		lp.push_back( s5 );
		lp.push_back( s6 );
		lp.pop_back();

		AssertTrue( check_deque( lp, { s1, s2, s3, s4, s5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test0D()
{
	this->set_subtitle( "stack/queue operations - deep pointer(c-string) value" );

	fprintf( stderr, "--- copy-push ---\n" );
	{
		dp_deque<const char[]>	lp;

		lp.push_back( static_cast<const char* const&>( s3 ));
		lp.push_front( static_cast<const char* const&>( s2 ));
		lp.push_front( static_cast<const char* const&>( s1 ));

		AssertTrue( check_deque( lp, { s1, s2, s3 } ));

		lp.push_back( static_cast<const char* const&>( s4 ));
		lp.push_front( static_cast<const char* const&>( s0 ));
		lp.pop_front();
		lp.push_back( static_cast<const char* const&>( s5 ));
		lp.push_back( static_cast<const char* const&>( s6 ));
		lp.pop_back();

		AssertTrue( check_deque( lp, { s1, s2, s3, s4, s5 } ));
	}
	fprintf( stderr, "--- move-push ---\n" );
	{
		dp_deque<const char[]>	lp;

		lp.push_back( strdup( s3 ) );
		lp.push_front( strdup( s2 ) );
		lp.push_front( strdup( s1 ) );

		AssertTrue( check_deque( lp, { s1, s2, s3 } ));

		lp.push_back( strdup( s4 ) );
		lp.push_front( strdup( s0 ) );
		lp.pop_front();
		lp.push_back( strdup( s5 ) );
		lp.push_back( strdup( s6 ) );
		lp.pop_back();

		AssertTrue( check_deque( lp, { s1, s2, s3, s4, s5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test0E()
{
	this->set_subtitle( "stack/queue operations - reference pointer(v-array) value" );

	fprintf( stderr, "--- copy-push ---\n" );
	{
		dr_deque<test[]>	lp;

		lp.push_back( static_cast<test* const&>( v3 ));
		lp.push_front( static_cast<test* const&>( v2 ));
		lp.push_front( static_cast<test* const&>( v1 ));

		AssertTrue( check_deque( lp, { v1, v2, v3 } ));

		lp.push_back( static_cast<test* const&>( v4 ));
		lp.push_front( static_cast<test* const&>( v0 ));
		lp.pop_front();
		lp.push_back( static_cast<test* const&>( v5 ));
		lp.push_back( static_cast<test* const&>( v6 ));
		lp.pop_back();

		AssertTrue( check_deque( lp, { v1, v2, v3, v4, v5 } ));
	}
	fprintf( stderr, "--- move-push ---\n" );
	{
		dr_deque<test[]>	lp;

		lp.push_back( v3 );
		lp.push_front( v2 );
		lp.push_front( v1 );

		AssertTrue( check_deque( lp, { v1, v2, v3 } ));

		lp.push_back( v4 );
		lp.push_front( v0 );
		lp.pop_front();
		lp.push_back( v5 );
		lp.push_back( v6 );
		lp.pop_back();

		AssertTrue( check_deque( lp, { v1, v2, v3, v4, v5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test0F()
{
	this->set_subtitle( "stack/queue operations - deep pointer(v-array) value" );

	fprintf( stderr, "--- copy-push ---\n" );
	{
		dp_deque<test[]>	lp;

		lp.push_back( static_cast<test* const&>( v3 ));
		lp.push_front( static_cast<test* const&>( v2 ));
		lp.push_front( static_cast<test* const&>( v1 ));

		AssertTrue( check_deque( lp, { v1, v2, v3 } ));

		lp.push_back( static_cast<test* const&>( v4 ));
		lp.push_front( static_cast<test* const&>( v0 ));
		lp.pop_front();
		lp.push_back( static_cast<test* const&>( v5 ));
		lp.push_back( static_cast<test* const&>( v6 ));
		lp.pop_back();

		AssertTrue( check_deque( lp, { v1, v2, v3, v4, v5 } ));
	}
	fprintf( stderr, "--- move-push ---\n" );
	{
		dp_deque<test[]>	lp;

		lp.push_back( dpl( v3 ) );
		lp.push_front( dpl( v2 ) );
		lp.push_front( dpl( v1 ) );

		AssertTrue( check_deque( lp, { v1, v2, v3 } ));

		lp.push_back( dpl( v4 ) );
		lp.push_front( dpl( v0 ) );
		lp.pop_front();
		lp.push_back( dpl( v5 ) );
		lp.push_back( dpl( v6 ) );
		lp.pop_back();

		AssertTrue( check_deque( lp, { v1, v2, v3, v4, v5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test10()
{
	this->set_subtitle( "stack/queue operations - reference pointer(f-array) value" );

	fprintf( stderr, "--- copy-push ---\n" );
	{
		dr_deque<test[3]>	lp;

		lp.push_back( static_cast<test* const&>( w3 ));
		lp.push_front( static_cast<test* const&>( w2 ));
		lp.push_front( static_cast<test* const&>( w1 ));

		AssertTrue( check_deque( lp, { w1, w2, w3 } ));

		lp.push_back( static_cast<test* const&>( w4 ));
		lp.push_front( static_cast<test* const&>( w0 ));
		lp.pop_front();
		lp.push_back( static_cast<test* const&>( w5 ));
		lp.push_back( static_cast<test* const&>( w6 ));
		lp.pop_back();

		AssertTrue( check_deque( lp, { w1, w2, w3, w4, w5 } ));
	}
	fprintf( stderr, "--- move-push ---\n" );
	{
		dr_deque<test[3]>	lp;

		lp.push_back( w3 );
		lp.push_front( w2 );
		lp.push_front( w1 );

		AssertTrue( check_deque( lp, { w1, w2, w3 } ));

		lp.push_back( w4 );
		lp.push_front( w0 );
		lp.pop_front();
		lp.push_back( w5 );
		lp.push_back( w6 );
		lp.pop_back();

		AssertTrue( check_deque( lp, { w1, w2, w3, w4, w5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test11()
{
	this->set_subtitle( "stack/queue operations - deep pointer(f-array) value" );

	fprintf( stderr, "--- copy-push ---\n" );
	{
		dp_deque<test[3]>	lp;

		lp.push_back( static_cast<test* const&>( w3 ));
		lp.push_front( static_cast<test* const&>( w2 ));
		lp.push_front( static_cast<test* const&>( w1 ));

		AssertTrue( check_deque( lp, { w1, w2, w3 } ));

		lp.push_back( static_cast<test* const&>( w4 ));
		lp.push_front( static_cast<test* const&>( w0 ));
		lp.pop_front();
		lp.push_back( static_cast<test* const&>( w5 ));
		lp.push_back( static_cast<test* const&>( w6 ));
		lp.pop_back();

		AssertTrue( check_deque( lp, { w1, w2, w3, w4, w5 } ));
	}
	fprintf( stderr, "--- move-push ---\n" );
	{
		dp_deque<test[3]>	lp;

		lp.push_back( dpl( w3 ) );
		lp.push_front( dpl( w2 ) );
		lp.push_front( dpl( w1 ) );

		AssertTrue( check_deque( lp, { w1, w2, w3 } ));

		lp.push_back( dpl( w4 ) );
		lp.push_front( dpl( w0 ) );
		lp.pop_front();
		lp.push_back( dpl( w5 ) );
		lp.push_back( dpl( w6 ) );
		lp.pop_back();

		AssertTrue( check_deque( lp, { w1, w2, w3, w4, w5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test12()
{
	this->set_subtitle( "stack/queue operations - data(int value) value" );

	fprintf( stderr, "--- copy-push ---\n" );
	{
		std::deque<int>	lp;

		lp.push_back( static_cast<int const&>( 3 ));
		lp.push_front( static_cast<int const&>( 2 ));
		lp.push_front( static_cast<int const&>( 1 ));

		AssertTrue( check_deque( lp, { 1, 2, 3 } ));

		lp.push_back( static_cast<int const&>( 4 ));
		lp.push_front( static_cast<int const&>( 0 ));
		lp.pop_front();
		lp.push_back( static_cast<int const&>( 5 ));
		lp.push_back( static_cast<int const&>( 3 ));
		lp.pop_back();

		AssertTrue( check_deque( lp, { 1, 2, 3, 4, 5 } ));
	}
	fprintf( stderr, "--- move-push ---\n" );
	{
		std::deque<int>	lp;

		lp.push_back( 3 );
		lp.push_front( 2 );
		lp.push_front( 1 );

		AssertTrue( check_deque( lp, { 1, 2, 3 } ));

		lp.push_back( 4 );
		lp.push_front( 0 );
		lp.pop_front();
		lp.push_back( 5 );
		lp.push_back( 3 );
		lp.pop_back();

		AssertTrue( check_deque( lp, { 1, 2, 3, 4, 5 } ));
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test13()
{
	this->set_subtitle( "list operations (modifier) - reference pointer(pointer) value" );
	{
		dr_deque<test*>	lp = { &t1, &t2, &t3, &t4, &t5 };
		dr_deque<test*>	l0;

		fprintf( stderr, "--- assign ---\n" );
		{
			dr_deque<test*>	lx;

			lx.assign( 3, nullptr );
			AssertTrue( check_deque( lx, { nullptr, nullptr, nullptr } ));
			lx.assign( 7, &t4 );
			AssertTrue( check_deque( lx, { &t4, &t4, &t4, &t4, &t4, &t4, &t4 } ));
			lx.assign(( lp.begin() += 2 ), lp.end());
			AssertTrue( check_deque( lx, { &t3, &t4, &t5 } ));
			lx.assign( { &t1, &t2, &t3, &t4, &t5 } );
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
		}
		fprintf( stderr, "--- insert ---\n" );
		{
			dr_deque<test*>		lx = { &t2, &t3, &t5 };
			dr_deque<test*>::iterator	r;

			// single element (copy)
			r = lx.insert( lx.begin(), static_cast<test* const&>( &t1 ));
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, static_cast<test* const&>( &t4 ));
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), static_cast<test* const&>( &t6 ));
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5, &t6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// single element (move)
			lx = { &t2, &t3, &t5 };
			r = lx.insert( lx.begin(), &t1 );
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, &t4 );
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), &t6 );
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5, &t6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// initializer list
			r = lx.insert( lx.begin(), { &t1, &t2, &t0 } );
			AssertTrue( check_deque( lx, { &t1, &t2, &t0, &t1, &t2, &t3, &t4, &t5, &t6 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() += 7, { &t2, &t0 } );
			AssertTrue( check_deque( lx, { &t1, &t2, &t0, &t1, &t2, &t3, &t4, &t2, &t0, &t5, &t6 } ));
			AssertTrue( r == lx.begin() + 7 );
			r = lx.insert( lx.begin() += 5, { } );
			AssertTrue( check_deque( lx, { &t1, &t2, &t0, &t1, &t2, &t3, &t4, &t2, &t0, &t5, &t6 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.end(), { &t3, &t5, &t0 } );
			AssertTrue( check_deque( lx, { &t1, &t2, &t0, &t1, &t2, &t3, &t4, &t2, &t0, &t5, &t6, &t3, &t5, &t0 } ));
			AssertTrue( r == lx.begin() + 11 );

			// range
			lx.clear();
			r = lx.insert( lx.begin(), lp.begin(), lp.end());
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin(), lp.begin(), ( lp.begin() += 2 ));
			AssertTrue( check_deque( lx, { &t1, &t2, &t1, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, ( lp.begin() += 1 ), ( lp.begin() += 4 ));
			AssertTrue( check_deque( lx, { &t1, &t2, &t1, &t2, &t3, &t4, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), ( lp.begin() += 3 ), lp.end());
			AssertTrue( check_deque( lx, { &t1, &t2, &t1, &t2, &t3, &t4, &t2, &t3, &t4, &t5, &t4, &t5 } ));
			AssertTrue( r == lx.begin() + 10 );

			// range (self insertion)
			lx.clear();
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			lx = { &t1, &t2, &t3 };
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t1, &t2, &t3 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t1, &t2, &t3, &t1, &t2, &t3, &t1, &t2, &t3 } ));
			AssertTrue( r == lx.begin() + 6 );

			// fill
			lx.clear();
			r = lx.insert( lx.begin(), 3, &t1 );
			AssertTrue( check_deque( lx, { &t1, &t1, &t1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), 2, &t2 );
			AssertTrue( check_deque( lx, { &t2, &t2, &t1, &t1, &t1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), 2, &t3 );
			AssertTrue( check_deque( lx, { &t2, &t2, &t1, &t1, &t1, &t3, &t3 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin() + 2, 0, &t4 );
			AssertTrue( check_deque( lx, { &t2, &t2, &t1, &t1, &t1, &t3, &t3 } ));
			AssertTrue( r == lx.begin() + 2 );
			r = lx.insert( lx.begin() + 4, 3, &t5 );
			AssertTrue( check_deque( lx, { &t2, &t2, &t1, &t1, &t5, &t5, &t5, &t1, &t3, &t3 } ));
			AssertTrue( r == lx.begin() + 4 );
		}

		fprintf( stderr, "--- erase ---\n" );
		{
			dr_deque<test*>		lx;
			dr_deque<test*>::iterator	r;

			lx = lp;
			r = lx.erase( lx.begin() + 1, lx.begin() + 3 );
			AssertTrue( check_deque( lx, { &t1, &t4, &t5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin() + 1 );
			AssertTrue( check_deque( lx, { &t1, &t5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin(), lx.begin() + 1 );
			AssertTrue( check_deque( lx, { &t5 } ));
			AssertTrue( r == lx.begin() );
			lx = lp;
			r = lx.erase( lx.begin() + 3, lx.begin() + 5 );
			AssertTrue( check_deque( lx, { &t1, &t2, &t3 } ));
			AssertTrue( r == lx.end() );
		}
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test14()
{
	this->set_subtitle( "list operations (modifier) - deep pointer(pointer) value" );
	{
		dp_deque<test*>	lp = { &t1, &t2, &t3, &t4, &t5 };
		dp_deque<test*>	l0;

		fprintf( stderr, "--- assign ---\n" );
		{
			dp_deque<test*>	lx;

			lx.assign( 3, nullptr );
			AssertTrue( check_deque( lx, { nullptr, nullptr, nullptr } ));
			lx.assign( 7, &t4 );
			AssertTrue( check_deque( lx, { &t4, &t4, &t4, &t4, &t4, &t4, &t4 } ));
			lx.assign(( lp.begin() += 2 ), lp.end());
			AssertTrue( check_deque( lx, { &t3, &t4, &t5 } ));
			lx.assign( { &t1, &t2, &t3, &t4, &t5 } );
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
		}
		fprintf( stderr, "--- insert ---\n" );
		{
			dp_deque<test*>		lx = { &t2, &t3, &t5 };
			dp_deque<test*>::iterator	r;

			// single element (copy)
			r = lx.insert( lx.begin(), static_cast<test* const&>( &t1 ));
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, static_cast<test* const&>( &t4 ));
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), static_cast<test* const&>( &t6 ));
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5, &t6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// single element (move)
			lx = { &t2, &t3, &t5 };
			r = lx.insert( lx.begin(), dpl( &t1 ) );
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, dpl( &t4 ) );
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), dpl( &t6 ) );
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5, &t6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// initializer list
			r = lx.insert( lx.begin(), { &t1, &t2, &t0 } );
			AssertTrue( check_deque( lx, { &t1, &t2, &t0, &t1, &t2, &t3, &t4, &t5, &t6 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() += 7, { &t2, &t0 } );
			AssertTrue( check_deque( lx, { &t1, &t2, &t0, &t1, &t2, &t3, &t4, &t2, &t0, &t5, &t6 } ));
			AssertTrue( r == lx.begin() + 7 );
			r = lx.insert( lx.begin() += 5, { } );
			AssertTrue( check_deque( lx, { &t1, &t2, &t0, &t1, &t2, &t3, &t4, &t2, &t0, &t5, &t6 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.end(), { &t3, &t5, &t0 } );
			AssertTrue( check_deque( lx, { &t1, &t2, &t0, &t1, &t2, &t3, &t4, &t2, &t0, &t5, &t6, &t3, &t5, &t0 } ));
			AssertTrue( r == lx.begin() + 11 );

			// range
			lx.clear();
			r = lx.insert( lx.begin(), lp.begin(), lp.end());
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin(), lp.begin(), ( lp.begin() += 2 ));
			AssertTrue( check_deque( lx, { &t1, &t2, &t1, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, ( lp.begin() += 1 ), ( lp.begin() += 4 ));
			AssertTrue( check_deque( lx, { &t1, &t2, &t1, &t2, &t3, &t4, &t2, &t3, &t4, &t5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), ( lp.begin() += 3 ), lp.end());
			AssertTrue( check_deque( lx, { &t1, &t2, &t1, &t2, &t3, &t4, &t2, &t3, &t4, &t5, &t4, &t5 } ));
			AssertTrue( r == lx.begin() + 10 );

			// range (self insertion)
			lx.clear();
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			lx = { &t1, &t2, &t3 };
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t1, &t2, &t3 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t1, &t2, &t3, &t1, &t2, &t3, &t1, &t2, &t3 } ));
			AssertTrue( r == lx.begin() + 6 );

			// fill
			lx.clear();
			r = lx.insert( lx.begin(), 3, &t1 );
			AssertTrue( check_deque( lx, { &t1, &t1, &t1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), 2, &t2 );
			AssertTrue( check_deque( lx, { &t2, &t2, &t1, &t1, &t1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), 2, &t3 );
			AssertTrue( check_deque( lx, { &t2, &t2, &t1, &t1, &t1, &t3, &t3 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin() + 2, 0, &t4 );
			AssertTrue( check_deque( lx, { &t2, &t2, &t1, &t1, &t1, &t3, &t3 } ));
			AssertTrue( r == lx.begin() + 2 );
			r = lx.insert( lx.begin() + 4, 3, &t5 );
			AssertTrue( check_deque( lx, { &t2, &t2, &t1, &t1, &t5, &t5, &t5, &t1, &t3, &t3 } ));
			AssertTrue( r == lx.begin() + 4 );
		}

		fprintf( stderr, "--- erase ---\n" );
		{
			dp_deque<test*>		lx;
			dp_deque<test*>::iterator	r;

			lx = lp;
			r = lx.erase( lx.begin() + 1, lx.begin() + 3 );
			AssertTrue( check_deque( lx, { &t1, &t4, &t5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin() + 1 );
			AssertTrue( check_deque( lx, { &t1, &t5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin(), lx.begin() + 1 );
			AssertTrue( check_deque( lx, { &t5 } ));
			AssertTrue( r == lx.begin() );
			lx = lp;
			r = lx.erase( lx.begin() + 3, lx.begin() + 5 );
			AssertTrue( check_deque( lx, { &t1, &t2, &t3 } ));
			AssertTrue( r == lx.end() );
		}
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test15()
{
	this->set_subtitle( "list operations (modifier) - reference pointer(c-string) value" );
	{
		dr_deque<const char[]>	lp = { s1, s2, s3, s4, s5 };
		dr_deque<const char[]>	l0;

		fprintf( stderr, "--- assign ---\n" );
		{
			dr_deque<const char[]>	lx;

			lx.assign( 3, nullptr );
			AssertTrue( check_deque( lx, { nullptr, nullptr, nullptr } ));
			lx.assign( 7, s4 );
			AssertTrue( check_deque( lx, { s4, s4, s4, s4, s4, s4, s4 } ));
			lx.assign(( lp.begin() += 2 ), lp.end());
			AssertTrue( check_deque( lx, { s3, s4, s5 } ));
			lx.assign( { s1, s2, s3, s4, s5 } );
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
		}
		fprintf( stderr, "--- insert ---\n" );
		{
			dr_deque<const char[]>		lx = { s2, s3, s5 };
			dr_deque<const char[]>::iterator	r;

			// single element (copy)
			r = lx.insert( lx.begin(), static_cast<const char* const&>( s1 ));
			AssertTrue( check_deque( lx, { s1, s2, s3, s5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, static_cast<const char* const&>( s4 ));
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), static_cast<const char* const&>( s6 ));
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5, s6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// single element (move)
			lx = { s2, s3, s5 };
			r = lx.insert( lx.begin(), s1 );
			AssertTrue( check_deque( lx, { s1, s2, s3, s5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, s4 );
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), s6 );
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5, s6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// initializer list
			r = lx.insert( lx.begin(), { s1, s2, s0 } );
			AssertTrue( check_deque( lx, { s1, s2, s0, s1, s2, s3, s4, s5, s6 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() += 7, { s2, s0 } );
			AssertTrue( check_deque( lx, { s1, s2, s0, s1, s2, s3, s4, s2, s0, s5, s6 } ));
			AssertTrue( r == lx.begin() + 7 );
			r = lx.insert( lx.begin() += 5, { } );
			AssertTrue( check_deque( lx, { s1, s2, s0, s1, s2, s3, s4, s2, s0, s5, s6 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.end(), { s3, s5, s0 } );
			AssertTrue( check_deque( lx, { s1, s2, s0, s1, s2, s3, s4, s2, s0, s5, s6, s3, s5, s0 } ));
			AssertTrue( r == lx.begin() + 11 );

			// range
			lx.clear();
			r = lx.insert( lx.begin(), lp.begin(), lp.end());
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin(), lp.begin(), ( lp.begin() += 2 ));
			AssertTrue( check_deque( lx, { s1, s2, s1, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, ( lp.begin() += 1 ), ( lp.begin() += 4 ));
			AssertTrue( check_deque( lx, { s1, s2, s1, s2, s3, s4, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), ( lp.begin() += 3 ), lp.end());
			AssertTrue( check_deque( lx, { s1, s2, s1, s2, s3, s4, s2, s3, s4, s5, s4, s5 } ));
			AssertTrue( r == lx.begin() + 10 );

			// range (self insertion)
			lx.clear();
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			lx = { s1, s2, s3 };
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { s1, s2, s3, s1, s2, s3 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { s1, s2, s3, s1, s2, s3, s1, s2, s3, s1, s2, s3 } ));
			AssertTrue( r == lx.begin() + 6 );

			// fill
			lx.clear();
			r = lx.insert( lx.begin(), 3, s1 );
			AssertTrue( check_deque( lx, { s1, s1, s1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), 2, s2 );
			AssertTrue( check_deque( lx, { s2, s2, s1, s1, s1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), 2, s3 );
			AssertTrue( check_deque( lx, { s2, s2, s1, s1, s1, s3, s3 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin() + 2, 0, s4 );
			AssertTrue( check_deque( lx, { s2, s2, s1, s1, s1, s3, s3 } ));
			AssertTrue( r == lx.begin() + 2 );
			r = lx.insert( lx.begin() + 4, 3, s5 );
			AssertTrue( check_deque( lx, { s2, s2, s1, s1, s5, s5, s5, s1, s3, s3 } ));
			AssertTrue( r == lx.begin() + 4 );
		}

		fprintf( stderr, "--- erase ---\n" );
		{
			dr_deque<const char[]>		lx;
			dr_deque<const char[]>::iterator	r;

			lx = lp;
			r = lx.erase( lx.begin() + 1, lx.begin() + 3 );
			AssertTrue( check_deque( lx, { s1, s4, s5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin() + 1 );
			AssertTrue( check_deque( lx, { s1, s5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin(), lx.begin() + 1 );
			AssertTrue( check_deque( lx, { s5 } ));
			AssertTrue( r == lx.begin() );
			lx = lp;
			r = lx.erase( lx.begin() + 3, lx.begin() + 5 );
			AssertTrue( check_deque( lx, { s1, s2, s3 } ));
			AssertTrue( r == lx.end() );
		}
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test16()
{
	this->set_subtitle( "list operations (modifier) - deep pointer(c-string) value" );
	{
		dp_deque<const char[]>	lp = { s1, s2, s3, s4, s5 };
		dp_deque<const char[]>	l0;

		fprintf( stderr, "--- assign ---\n" );
		{
			dp_deque<const char[]>	lx;

			lx.assign( 3, nullptr );
			AssertTrue( check_deque( lx, { nullptr, nullptr, nullptr } ));
			lx.assign( 7, s4 );
			AssertTrue( check_deque( lx, { s4, s4, s4, s4, s4, s4, s4 } ));
			lx.assign(( lp.begin() += 2 ), lp.end());
			AssertTrue( check_deque( lx, { s3, s4, s5 } ));
			lx.assign( { s1, s2, s3, s4, s5 } );
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
		}
		fprintf( stderr, "--- insert ---\n" );
		{
			dp_deque<const char[]>		lx = { s2, s3, s5 };
			dp_deque<const char[]>::iterator	r;

			// single element (copy)
			r = lx.insert( lx.begin(), static_cast<const char* const&>( s1 ));
			AssertTrue( check_deque( lx, { s1, s2, s3, s5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, static_cast<const char* const&>( s4 ));
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), static_cast<const char* const&>( s6 ));
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5, s6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// single element (move)
			lx = { s2, s3, s5 };
			r = lx.insert( lx.begin(), strdup( s1 ) );
			AssertTrue( check_deque( lx, { s1, s2, s3, s5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, strdup( s4 ) );
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), strdup( s6 ) );
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5, s6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// initializer list
			r = lx.insert( lx.begin(), { s1, s2, s0 } );
			AssertTrue( check_deque( lx, { s1, s2, s0, s1, s2, s3, s4, s5, s6 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() += 7, { s2, s0 } );
			AssertTrue( check_deque( lx, { s1, s2, s0, s1, s2, s3, s4, s2, s0, s5, s6 } ));
			AssertTrue( r == lx.begin() + 7 );
			r = lx.insert( lx.begin() += 5, { } );
			AssertTrue( check_deque( lx, { s1, s2, s0, s1, s2, s3, s4, s2, s0, s5, s6 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.end(), { s3, s5, s0 } );
			AssertTrue( check_deque( lx, { s1, s2, s0, s1, s2, s3, s4, s2, s0, s5, s6, s3, s5, s0 } ));
			AssertTrue( r == lx.begin() + 11 );

			// range
			lx.clear();
			r = lx.insert( lx.begin(), lp.begin(), lp.end());
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin(), lp.begin(), ( lp.begin() += 2 ));
			AssertTrue( check_deque( lx, { s1, s2, s1, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, ( lp.begin() += 1 ), ( lp.begin() += 4 ));
			AssertTrue( check_deque( lx, { s1, s2, s1, s2, s3, s4, s2, s3, s4, s5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), ( lp.begin() += 3 ), lp.end());
			AssertTrue( check_deque( lx, { s1, s2, s1, s2, s3, s4, s2, s3, s4, s5, s4, s5 } ));
			AssertTrue( r == lx.begin() + 10 );

			// range (self insertion)
			lx.clear();
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			lx = { s1, s2, s3 };
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { s1, s2, s3, s1, s2, s3 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { s1, s2, s3, s1, s2, s3, s1, s2, s3, s1, s2, s3 } ));
			AssertTrue( r == lx.begin() + 6 );

			// fill
			lx.clear();
			r = lx.insert( lx.begin(), 3, s1 );
			AssertTrue( check_deque( lx, { s1, s1, s1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), 2, s2 );
			AssertTrue( check_deque( lx, { s2, s2, s1, s1, s1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), 2, s3 );
			AssertTrue( check_deque( lx, { s2, s2, s1, s1, s1, s3, s3 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin() + 2, 0, s4 );
			AssertTrue( check_deque( lx, { s2, s2, s1, s1, s1, s3, s3 } ));
			AssertTrue( r == lx.begin() + 2 );
			r = lx.insert( lx.begin() + 4, 3, s5 );
			AssertTrue( check_deque( lx, { s2, s2, s1, s1, s5, s5, s5, s1, s3, s3 } ));
			AssertTrue( r == lx.begin() + 4 );
		}

		fprintf( stderr, "--- erase ---\n" );
		{
			dp_deque<const char[]>		lx;
			dp_deque<const char[]>::iterator	r;

			lx = lp;
			r = lx.erase( lx.begin() + 1, lx.begin() + 3 );
			AssertTrue( check_deque( lx, { s1, s4, s5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin() + 1 );
			AssertTrue( check_deque( lx, { s1, s5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin(), lx.begin() + 1 );
			AssertTrue( check_deque( lx, { s5 } ));
			AssertTrue( r == lx.begin() );
			lx = lp;
			r = lx.erase( lx.begin() + 3, lx.begin() + 5 );
			AssertTrue( check_deque( lx, { s1, s2, s3 } ));
			AssertTrue( r == lx.end() );
		}
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test17()
{
	this->set_subtitle( "list operations (modifier) - reference pointer(v-array) value" );
	{
		dr_deque<test[]>	lp = { v1, v2, v3, v4, v5 };
		dr_deque<test[]>	l0;

		fprintf( stderr, "--- assign ---\n" );
		{
			dr_deque<test[]>	lx;

			lx.assign( 3, nullptr );
			AssertTrue( check_deque( lx, { nullptr, nullptr, nullptr } ));
			lx.assign( 7, v4 );
			AssertTrue( check_deque( lx, { v4, v4, v4, v4, v4, v4, v4 } ));
			lx.assign(( lp.begin() += 2 ), lp.end());
			AssertTrue( check_deque( lx, { v3, v4, v5 } ));
			lx.assign( { v1, v2, v3, v4, v5 } );
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
		}
		fprintf( stderr, "--- insert ---\n" );
		{
			dr_deque<test[]>		lx = { v2, v3, v5 };
			dr_deque<test[]>::iterator	r;

			// single element (copy)
			r = lx.insert( lx.begin(), static_cast<test* const&>( v1 ));
			AssertTrue( check_deque( lx, { v1, v2, v3, v5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, static_cast<test* const&>( v4 ));
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), static_cast<test* const&>( v6 ));
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5, v6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// single element (move)
			lx = { v2, v3, v5 };
			r = lx.insert( lx.begin(), v1 );
			AssertTrue( check_deque( lx, { v1, v2, v3, v5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, v4 );
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), v6 );
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5, v6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// initializer list
			r = lx.insert( lx.begin(), { v1, v2, v0 } );
			AssertTrue( check_deque( lx, { v1, v2, v0, v1, v2, v3, v4, v5, v6 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() += 7, { v2, v0 } );
			AssertTrue( check_deque( lx, { v1, v2, v0, v1, v2, v3, v4, v2, v0, v5, v6 } ));
			AssertTrue( r == lx.begin() + 7 );
			r = lx.insert( lx.begin() += 5, { } );
			AssertTrue( check_deque( lx, { v1, v2, v0, v1, v2, v3, v4, v2, v0, v5, v6 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.end(), { v3, v5, v0 } );
			AssertTrue( check_deque( lx, { v1, v2, v0, v1, v2, v3, v4, v2, v0, v5, v6, v3, v5, v0 } ));
			AssertTrue( r == lx.begin() + 11 );

			// range
			lx.clear();
			r = lx.insert( lx.begin(), lp.begin(), lp.end());
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin(), lp.begin(), ( lp.begin() += 2 ));
			AssertTrue( check_deque( lx, { v1, v2, v1, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, ( lp.begin() += 1 ), ( lp.begin() += 4 ));
			AssertTrue( check_deque( lx, { v1, v2, v1, v2, v3, v4, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), ( lp.begin() += 3 ), lp.end());
			AssertTrue( check_deque( lx, { v1, v2, v1, v2, v3, v4, v2, v3, v4, v5, v4, v5 } ));
			AssertTrue( r == lx.begin() + 10 );

			// range (self insertion)
			lx.clear();
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			lx = { v1, v2, v3 };
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { v1, v2, v3, v1, v2, v3 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { v1, v2, v3, v1, v2, v3, v1, v2, v3, v1, v2, v3 } ));
			AssertTrue( r == lx.begin() + 6 );

			// fill
			lx.clear();
			r = lx.insert( lx.begin(), 3, v1 );
			AssertTrue( check_deque( lx, { v1, v1, v1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), 2, v2 );
			AssertTrue( check_deque( lx, { v2, v2, v1, v1, v1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), 2, v3 );
			AssertTrue( check_deque( lx, { v2, v2, v1, v1, v1, v3, v3 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin() + 2, 0, v4 );
			AssertTrue( check_deque( lx, { v2, v2, v1, v1, v1, v3, v3 } ));
			AssertTrue( r == lx.begin() + 2 );
			r = lx.insert( lx.begin() + 4, 3, v5 );
			AssertTrue( check_deque( lx, { v2, v2, v1, v1, v5, v5, v5, v1, v3, v3 } ));
			AssertTrue( r == lx.begin() + 4 );
		}

		fprintf( stderr, "--- erase ---\n" );
		{
			dr_deque<test[]>		lx;
			dr_deque<test[]>::iterator	r;

			lx = lp;
			r = lx.erase( lx.begin() + 1, lx.begin() + 3 );
			AssertTrue( check_deque( lx, { v1, v4, v5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin() + 1 );
			AssertTrue( check_deque( lx, { v1, v5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin(), lx.begin() + 1 );
			AssertTrue( check_deque( lx, { v5 } ));
			AssertTrue( r == lx.begin() );
			lx = lp;
			r = lx.erase( lx.begin() + 3, lx.begin() + 5 );
			AssertTrue( check_deque( lx, { v1, v2, v3 } ));
			AssertTrue( r == lx.end() );
		}
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test18()
{
	this->set_subtitle( "list operations (modifier) - deep pointer(v-array) value" );
	{
		dp_deque<test[]>	lp = { v1, v2, v3, v4, v5 };
		dp_deque<test[]>	l0;

		fprintf( stderr, "--- assign ---\n" );
		{
			dp_deque<test[]>	lx;

			lx.assign( 3, nullptr );
			AssertTrue( check_deque( lx, { nullptr, nullptr, nullptr } ));
			lx.assign( 7, v4 );
			AssertTrue( check_deque( lx, { v4, v4, v4, v4, v4, v4, v4 } ));
			lx.assign(( lp.begin() += 2 ), lp.end());
			AssertTrue( check_deque( lx, { v3, v4, v5 } ));
			lx.assign( { v1, v2, v3, v4, v5 } );
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
		}
		fprintf( stderr, "--- insert ---\n" );
		{
			dp_deque<test[]>		lx = { v2, v3, v5 };
			dp_deque<test[]>::iterator	r;

			// single element (copy)
			r = lx.insert( lx.begin(), static_cast<test* const&>( v1 ));
			AssertTrue( check_deque( lx, { v1, v2, v3, v5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, static_cast<test* const&>( v4 ));
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), static_cast<test* const&>( v6 ));
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5, v6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// single element (move)
			lx = { v2, v3, v5 };
			r = lx.insert( lx.begin(), dpl( v1 ) );
			AssertTrue( check_deque( lx, { v1, v2, v3, v5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, dpl( v4 ) );
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), dpl( v6 ) );
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5, v6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// initializer list
			r = lx.insert( lx.begin(), { v1, v2, v0 } );
			AssertTrue( check_deque( lx, { v1, v2, v0, v1, v2, v3, v4, v5, v6 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() += 7, { v2, v0 } );
			AssertTrue( check_deque( lx, { v1, v2, v0, v1, v2, v3, v4, v2, v0, v5, v6 } ));
			AssertTrue( r == lx.begin() + 7 );
			r = lx.insert( lx.begin() += 5, { } );
			AssertTrue( check_deque( lx, { v1, v2, v0, v1, v2, v3, v4, v2, v0, v5, v6 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.end(), { v3, v5, v0 } );
			AssertTrue( check_deque( lx, { v1, v2, v0, v1, v2, v3, v4, v2, v0, v5, v6, v3, v5, v0 } ));
			AssertTrue( r == lx.begin() + 11 );

			// range
			lx.clear();
			r = lx.insert( lx.begin(), lp.begin(), lp.end());
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin(), lp.begin(), ( lp.begin() += 2 ));
			AssertTrue( check_deque( lx, { v1, v2, v1, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, ( lp.begin() += 1 ), ( lp.begin() += 4 ));
			AssertTrue( check_deque( lx, { v1, v2, v1, v2, v3, v4, v2, v3, v4, v5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), ( lp.begin() += 3 ), lp.end());
			AssertTrue( check_deque( lx, { v1, v2, v1, v2, v3, v4, v2, v3, v4, v5, v4, v5 } ));
			AssertTrue( r == lx.begin() + 10 );

			// range (self insertion)
			lx.clear();
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			lx = { v1, v2, v3 };
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { v1, v2, v3, v1, v2, v3 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { v1, v2, v3, v1, v2, v3, v1, v2, v3, v1, v2, v3 } ));
			AssertTrue( r == lx.begin() + 6 );

			// fill
			lx.clear();
			r = lx.insert( lx.begin(), 3, v1 );
			AssertTrue( check_deque( lx, { v1, v1, v1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), 2, v2 );
			AssertTrue( check_deque( lx, { v2, v2, v1, v1, v1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), 2, v3 );
			AssertTrue( check_deque( lx, { v2, v2, v1, v1, v1, v3, v3 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin() + 2, 0, v4 );
			AssertTrue( check_deque( lx, { v2, v2, v1, v1, v1, v3, v3 } ));
			AssertTrue( r == lx.begin() + 2 );
			r = lx.insert( lx.begin() + 4, 3, v5 );
			AssertTrue( check_deque( lx, { v2, v2, v1, v1, v5, v5, v5, v1, v3, v3 } ));
			AssertTrue( r == lx.begin() + 4 );
		}

		fprintf( stderr, "--- erase ---\n" );
		{
			dp_deque<test[]>		lx;
			dp_deque<test[]>::iterator	r;

			lx = lp;
			r = lx.erase( lx.begin() + 1, lx.begin() + 3 );
			AssertTrue( check_deque( lx, { v1, v4, v5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin() + 1 );
			AssertTrue( check_deque( lx, { v1, v5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin(), lx.begin() + 1 );
			AssertTrue( check_deque( lx, { v5 } ));
			AssertTrue( r == lx.begin() );
			lx = lp;
			r = lx.erase( lx.begin() + 3, lx.begin() + 5 );
			AssertTrue( check_deque( lx, { v1, v2, v3 } ));
			AssertTrue( r == lx.end() );
		}
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test19()
{
	this->set_subtitle( "list operations (modifier) - reference pointer(f-array) value" );
	{
		dr_deque<test[3]>	lp = { w1, w2, w3, w4, w5 };
		dr_deque<test[3]>	l0;

		fprintf( stderr, "--- assign ---\n" );
		{
			dr_deque<test[3]>	lx;

			lx.assign( 3, nullptr );
			AssertTrue( check_deque( lx, { nullptr, nullptr, nullptr } ));
			lx.assign( 7, w4 );
			AssertTrue( check_deque( lx, { w4, w4, w4, w4, w4, w4, w4 } ));
			lx.assign(( lp.begin() += 2 ), lp.end());
			AssertTrue( check_deque( lx, { w3, w4, w5 } ));
			lx.assign( { w1, w2, w3, w4, w5 } );
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
		}
		fprintf( stderr, "--- insert ---\n" );
		{
			dr_deque<test[3]>		lx = { w2, w3, w5 };
			dr_deque<test[3]>::iterator	r;

			// single element (copy)
			r = lx.insert( lx.begin(), static_cast<test* const&>( w1 ));
			AssertTrue( check_deque( lx, { w1, w2, w3, w5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, static_cast<test* const&>( w4 ));
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), static_cast<test* const&>( w6 ));
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5, w6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// single element (move)
			lx = { w2, w3, w5 };
			r = lx.insert( lx.begin(), w1 );
			AssertTrue( check_deque( lx, { w1, w2, w3, w5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, w4 );
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), w6 );
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5, w6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// initializer list
			r = lx.insert( lx.begin(), { w1, w2, w0 } );
			AssertTrue( check_deque( lx, { w1, w2, w0, w1, w2, w3, w4, w5, w6 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() += 7, { w2, w0 } );
			AssertTrue( check_deque( lx, { w1, w2, w0, w1, w2, w3, w4, w2, w0, w5, w6 } ));
			AssertTrue( r == lx.begin() + 7 );
			r = lx.insert( lx.begin() += 5, { } );
			AssertTrue( check_deque( lx, { w1, w2, w0, w1, w2, w3, w4, w2, w0, w5, w6 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.end(), { w3, w5, w0 } );
			AssertTrue( check_deque( lx, { w1, w2, w0, w1, w2, w3, w4, w2, w0, w5, w6, w3, w5, w0 } ));
			AssertTrue( r == lx.begin() + 11 );

			// range
			lx.clear();
			r = lx.insert( lx.begin(), lp.begin(), lp.end());
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin(), lp.begin(), ( lp.begin() += 2 ));
			AssertTrue( check_deque( lx, { w1, w2, w1, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, ( lp.begin() += 1 ), ( lp.begin() += 4 ));
			AssertTrue( check_deque( lx, { w1, w2, w1, w2, w3, w4, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), ( lp.begin() += 3 ), lp.end());
			AssertTrue( check_deque( lx, { w1, w2, w1, w2, w3, w4, w2, w3, w4, w5, w4, w5 } ));
			AssertTrue( r == lx.begin() + 10 );

			// range (self insertion)
			lx.clear();
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			lx = { w1, w2, w3 };
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { w1, w2, w3, w1, w2, w3 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { w1, w2, w3, w1, w2, w3, w1, w2, w3, w1, w2, w3 } ));
			AssertTrue( r == lx.begin() + 6 );

			// fill
			lx.clear();
			r = lx.insert( lx.begin(), 3, w1 );
			AssertTrue( check_deque( lx, { w1, w1, w1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), 2, w2 );
			AssertTrue( check_deque( lx, { w2, w2, w1, w1, w1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), 2, w3 );
			AssertTrue( check_deque( lx, { w2, w2, w1, w1, w1, w3, w3 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin() + 2, 0, w4 );
			AssertTrue( check_deque( lx, { w2, w2, w1, w1, w1, w3, w3 } ));
			AssertTrue( r == lx.begin() + 2 );
			r = lx.insert( lx.begin() + 4, 3, w5 );
			AssertTrue( check_deque( lx, { w2, w2, w1, w1, w5, w5, w5, w1, w3, w3 } ));
			AssertTrue( r == lx.begin() + 4 );
		}

		fprintf( stderr, "--- erase ---\n" );
		{
			dr_deque<test[3]>		lx;
			dr_deque<test[3]>::iterator	r;

			lx = lp;
			r = lx.erase( lx.begin() + 1, lx.begin() + 3 );
			AssertTrue( check_deque( lx, { w1, w4, w5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin() + 1 );
			AssertTrue( check_deque( lx, { w1, w5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin(), lx.begin() + 1 );
			AssertTrue( check_deque( lx, { w5 } ));
			AssertTrue( r == lx.begin() );
			lx = lp;
			r = lx.erase( lx.begin() + 3, lx.begin() + 5 );
			AssertTrue( check_deque( lx, { w1, w2, w3 } ));
			AssertTrue( r == lx.end() );
		}
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test1A()
{
	this->set_subtitle( "list operations (modifier) - deep pointer(f-array) value" );
	{
		dp_deque<test[3]>	lp = { w1, w2, w3, w4, w5 };
		dp_deque<test[3]>	l0;

		fprintf( stderr, "--- assign ---\n" );
		{
			dp_deque<test[3]>	lx;

			lx.assign( 3, nullptr );
			AssertTrue( check_deque( lx, { nullptr, nullptr, nullptr } ));
			lx.assign( 7, w4 );
			AssertTrue( check_deque( lx, { w4, w4, w4, w4, w4, w4, w4 } ));
			lx.assign(( lp.begin() += 2 ), lp.end());
			AssertTrue( check_deque( lx, { w3, w4, w5 } ));
			lx.assign( { w1, w2, w3, w4, w5 } );
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
		}
		fprintf( stderr, "--- insert ---\n" );
		{
			dp_deque<test[3]>		lx = { w2, w3, w5 };
			dp_deque<test[3]>::iterator	r;

			// single element (copy)
			r = lx.insert( lx.begin(), static_cast<test* const&>( w1 ));
			AssertTrue( check_deque( lx, { w1, w2, w3, w5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, static_cast<test* const&>( w4 ));
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), static_cast<test* const&>( w6 ));
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5, w6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// single element (move)
			lx = { w2, w3, w5 };
			r = lx.insert( lx.begin(), dpl( w1 ) );
			AssertTrue( check_deque( lx, { w1, w2, w3, w5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, dpl( w4 ) );
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), dpl( w6 ) );
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5, w6 } ));
			AssertTrue( r == lx.begin() + 5 );

			// initializer list
			r = lx.insert( lx.begin(), { w1, w2, w0 } );
			AssertTrue( check_deque( lx, { w1, w2, w0, w1, w2, w3, w4, w5, w6 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() += 7, { w2, w0 } );
			AssertTrue( check_deque( lx, { w1, w2, w0, w1, w2, w3, w4, w2, w0, w5, w6 } ));
			AssertTrue( r == lx.begin() + 7 );
			r = lx.insert( lx.begin() += 5, { } );
			AssertTrue( check_deque( lx, { w1, w2, w0, w1, w2, w3, w4, w2, w0, w5, w6 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.end(), { w3, w5, w0 } );
			AssertTrue( check_deque( lx, { w1, w2, w0, w1, w2, w3, w4, w2, w0, w5, w6, w3, w5, w0 } ));
			AssertTrue( r == lx.begin() + 11 );

			// range
			lx.clear();
			r = lx.insert( lx.begin(), lp.begin(), lp.end());
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin(), lp.begin(), ( lp.begin() += 2 ));
			AssertTrue( check_deque( lx, { w1, w2, w1, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, ( lp.begin() += 1 ), ( lp.begin() += 4 ));
			AssertTrue( check_deque( lx, { w1, w2, w1, w2, w3, w4, w2, w3, w4, w5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), ( lp.begin() += 3 ), lp.end());
			AssertTrue( check_deque( lx, { w1, w2, w1, w2, w3, w4, w2, w3, w4, w5, w4, w5 } ));
			AssertTrue( r == lx.begin() + 10 );

			// range (self insertion)
			lx.clear();
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			lx = { w1, w2, w3 };
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { w1, w2, w3, w1, w2, w3 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { w1, w2, w3, w1, w2, w3, w1, w2, w3, w1, w2, w3 } ));
			AssertTrue( r == lx.begin() + 6 );

			// fill
			lx.clear();
			r = lx.insert( lx.begin(), 3, w1 );
			AssertTrue( check_deque( lx, { w1, w1, w1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), 2, w2 );
			AssertTrue( check_deque( lx, { w2, w2, w1, w1, w1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), 2, w3 );
			AssertTrue( check_deque( lx, { w2, w2, w1, w1, w1, w3, w3 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin() + 2, 0, w4 );
			AssertTrue( check_deque( lx, { w2, w2, w1, w1, w1, w3, w3 } ));
			AssertTrue( r == lx.begin() + 2 );
			r = lx.insert( lx.begin() + 4, 3, w5 );
			AssertTrue( check_deque( lx, { w2, w2, w1, w1, w5, w5, w5, w1, w3, w3 } ));
			AssertTrue( r == lx.begin() + 4 );
		}

		fprintf( stderr, "--- erase ---\n" );
		{
			dp_deque<test[3]>		lx;
			dp_deque<test[3]>::iterator	r;

			lx = lp;
			r = lx.erase( lx.begin() + 1, lx.begin() + 3 );
			AssertTrue( check_deque( lx, { w1, w4, w5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin() + 1 );
			AssertTrue( check_deque( lx, { w1, w5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin(), lx.begin() + 1 );
			AssertTrue( check_deque( lx, { w5 } ));
			AssertTrue( r == lx.begin() );
			lx = lp;
			r = lx.erase( lx.begin() + 3, lx.begin() + 5 );
			AssertTrue( check_deque( lx, { w1, w2, w3 } ));
			AssertTrue( r == lx.end() );
		}
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test1B()
{
	this->set_subtitle( "list operations (modifier) - data(int value) value" );
	{
		std::deque<int>	lp = { 1, 2, 3, 4, 5 };
		std::deque<int>	l0;

		fprintf( stderr, "--- assign ---\n" );
		{
			std::deque<int>	lx;

			lx.assign( 3, 0 );
			AssertTrue( check_deque( lx, { 0, 0, 0 } ));
			lx.assign( 7, 4 );
			AssertTrue( check_deque( lx, { 4, 4, 4, 4, 4, 4, 4 } ));
			lx.assign(( lp.begin() += 2 ), lp.end());
			AssertTrue( check_deque( lx, { 3, 4, 5 } ));
			lx.assign( { 1, 2, 3, 4, 5 } );
			AssertTrue( check_deque( lx, { 1, 2, 3, 4, 5 } ));
		}
		fprintf( stderr, "--- insert ---\n" );
		{
			std::deque<int>		lx = { 2, 3, 5 };
			std::deque<int>::iterator	r;

			// single element (copy)
			r = lx.insert( lx.begin(), static_cast<int const&>( 1 ));
			AssertTrue( check_deque( lx, { 1, 2, 3, 5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, static_cast<int const&>( 4 ));
			AssertTrue( check_deque( lx, { 1, 2, 3, 4, 5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), static_cast<int const&>( 3 ));
			AssertTrue( check_deque( lx, { 1, 2, 3, 4, 5, 3 } ));
			AssertTrue( r == lx.begin() + 5 );

			// single element (move)
			lx = { 2, 3, 5 };
			r = lx.insert( lx.begin(), 1 );
			AssertTrue( check_deque( lx, { 1, 2, 3, 5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, 4 );
			AssertTrue( check_deque( lx, { 1, 2, 3, 4, 5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), 3 );
			AssertTrue( check_deque( lx, { 1, 2, 3, 4, 5, 3 } ));
			AssertTrue( r == lx.begin() + 5 );

			// initializer list
			r = lx.insert( lx.begin(), { 1, 2, 0 } );
			AssertTrue( check_deque( lx, { 1, 2, 0, 1, 2, 3, 4, 5, 3 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() += 7, { 2, 0 } );
			AssertTrue( check_deque( lx, { 1, 2, 0, 1, 2, 3, 4, 2, 0, 5, 3 } ));
			AssertTrue( r == lx.begin() + 7 );
			r = lx.insert( lx.begin() += 5, { } );
			AssertTrue( check_deque( lx, { 1, 2, 0, 1, 2, 3, 4, 2, 0, 5, 3 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.end(), { 3, 5, 0 } );
			AssertTrue( check_deque( lx, { 1, 2, 0, 1, 2, 3, 4, 2, 0, 5, 3, 3, 5, 0 } ));
			AssertTrue( r == lx.begin() + 11 );

			// range
			lx.clear();
			r = lx.insert( lx.begin(), lp.begin(), lp.end());
			AssertTrue( check_deque( lx, { 1, 2, 3, 4, 5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { 1, 2, 3, 4, 5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { 1, 2, 3, 4, 5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), l0.begin(), l0.end());
			AssertTrue( check_deque( lx, { 1, 2, 3, 4, 5 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin(), lp.begin(), ( lp.begin() += 2 ));
			AssertTrue( check_deque( lx, { 1, 2, 1, 2, 3, 4, 5 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin() + 3, ( lp.begin() += 1 ), ( lp.begin() += 4 ));
			AssertTrue( check_deque( lx, { 1, 2, 1, 2, 3, 4, 2, 3, 4, 5 } ));
			AssertTrue( r == lx.begin() + 3 );
			r = lx.insert( lx.end(), ( lp.begin() += 3 ), lp.end());
			AssertTrue( check_deque( lx, { 1, 2, 1, 2, 3, 4, 2, 3, 4, 5, 4, 5 } ));
			AssertTrue( r == lx.begin() + 10 );

			// range (self insertion)
			lx.clear();
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( lx.empty());
			AssertTrue( r == lx.begin());
			lx = { 1, 2, 3 };
			r = lx.insert( lx.begin(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { 1, 2, 3, 1, 2, 3 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), lx.begin(), lx.end());
			AssertTrue( check_deque( lx, { 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3 } ));
			AssertTrue( r == lx.begin() + 6 );

			// fill
			lx.clear();
			r = lx.insert( lx.begin(), 3, 1 );
			AssertTrue( check_deque( lx, { 1, 1, 1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.begin(), 2, 2 );
			AssertTrue( check_deque( lx, { 2, 2, 1, 1, 1 } ));
			AssertTrue( r == lx.begin());
			r = lx.insert( lx.end(), 2, 3 );
			AssertTrue( check_deque( lx, { 2, 2, 1, 1, 1, 3, 3 } ));
			AssertTrue( r == lx.begin() + 5 );
			r = lx.insert( lx.begin() + 2, 0, 4 );
			AssertTrue( check_deque( lx, { 2, 2, 1, 1, 1, 3, 3 } ));
			AssertTrue( r == lx.begin() + 2 );
			r = lx.insert( lx.begin() + 4, 3, 5 );
			AssertTrue( check_deque( lx, { 2, 2, 1, 1, 5, 5, 5, 1, 3, 3 } ));
			AssertTrue( r == lx.begin() + 4 );
		}

		fprintf( stderr, "--- erase ---\n" );
		{
			std::deque<int>		lx;
			std::deque<int>::iterator	r;

			lx = lp;
			r = lx.erase( lx.begin() + 1, lx.begin() + 3 );
			AssertTrue( check_deque( lx, { 1, 4, 5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin() + 1 );
			AssertTrue( check_deque( lx, { 1, 5 } ));
			AssertTrue( r == lx.begin() + 1 );
			r = lx.erase( lx.begin(), lx.begin() + 1 );
			AssertTrue( check_deque( lx, { 5 } ));
			AssertTrue( r == lx.begin() );
			lx = lp;
			r = lx.erase( lx.begin() + 3, lx.begin() + 5 );
			AssertTrue( check_deque( lx, { 1, 2, 3 } ));
			AssertTrue( r == lx.end() );
		}
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test1C()
{
	this->set_subtitle( "list operations (accessor) - reference pointer(pointer) value" );
	{
		fprintf( stderr, "--- at/operator[] ---\n" );
		{
			dr_deque<test*>		lp = { &t1, &t2, &t3, &t4, &t5 };
			dr_deque<test*> const&	cp = lp;

			AssertEqual( *lp[ 0 ], t1 );
			AssertEqual( *lp.at( 1 ), t2 );
			AssertEqual( lp.at( 2 )->num(), 3 );
			AssertEqual( lp[ 3 ]->num(), 4 );
			AssertZero( strcmp( lp[ 4 ]->cstr(), s5 ));

			AssertEqual( *cp[ 0 ], t1 );
			AssertEqual( *cp.at( 1 ), t2 );
			AssertEqual( cp.at( 2 )->num(), 3 );
			AssertEqual( cp[ 3 ]->num(), 4 );
			AssertZero( strcmp( cp[ 4 ]->cstr(), s5 ));

			lp[ 1 ] = &t4;
			AssertTrue( check_deque( lp, { &t1, &t4, &t3, &t4, &t5 } ));
			lp[ 3 ] = lp[ 2 ];					
			AssertTrue( check_deque( lp, { &t1, &t4, &t3, &t3, &t5 } ));

			test	bk = *lp[ 2 ];
			*lp[ 2 ] = t7;
			AssertTrue( check_deque( lp, { &t1, &t4, &t7, &t7, &t5 } ));	// different result by d-ptr
			*lp[ 2 ] = bk;

			try {
				AssertEqual( lp.at( 5 ), &t0 );
			}
			catch ( typename std::exception& e ) {
				fprintf( stderr, "*** exception: %s\n", e.what() );
			}
		}
		fprintf( stderr, "--- front/back ---\n" );
		{
			dr_deque<test*>		lp;
			dr_deque<test*> const&	cp = lp;

			lp = { &t1, &t2, &t3, &t1, &t4, &t5 };
			AssertTrue( static_cast<bool>( lp.front() ));
			AssertEqual( static_cast<test*>( lp.front()), &t1 );
			AssertEqual( *lp.front(), t1 );
			AssertEqual( lp.front()->num(), 1 );

			test	bk = *lp.front();
			*lp.front() = t7;
			AssertTrue( check_deque( lp, { &t7, &t2, &t3, &t7, &t4, &t5 } ));
			*lp.front() = bk;

			AssertTrue( static_cast<bool>( lp.back() ));
			AssertEqual( static_cast<test*>( lp.back()), &t5 );
			AssertEqual( *lp.back(), t5 );
			AssertEqual( lp.back()->num(), 5 );

			AssertTrue( static_cast<bool>( cp.front() ));
			AssertEqual( static_cast<const test*>( cp.front()), &t1 );
			AssertEqual( *cp.front(), t1 );
			AssertEqual( cp.front()->num(), 1 );

			AssertTrue( static_cast<bool>( cp.back() ));
			AssertEqual( static_cast<const test*>( cp.back()), &t5 );
			AssertEqual( *cp.back(), t5 );
			AssertEqual( cp.back()->num(), 5 );

			lp.back() = lp.front();			
			AssertEqual( static_cast<test*>( lp.back()), &t1 );	// the first and the last both refer &t1
			AssertTrue( check_deque( lp, { &t1, &t2, &t3, &t1, &t4, &t1 } ));
		}

		fprintf( stderr, "--- returned reference\n" );
		{
			dr_deque<test*>		nn { &t1, &t2, &t3, &t4, nullptr, &t5 };
			dr_deque<const test*>		cn { &t1, &t2, &t3, &t4, nullptr, &t5 };

			AssertEqual( nn[ 1 ], &t2 );				// adresss comparison
			AssertEqual( cn[ 1 ], &t2 );			//
			AssertEqual( *nn[ 1 ], t2 );
			AssertEqual( *cn[ 1 ], t2 );
			AssertEqual( nn[ 1 ]->num(), 2 );
			AssertEqual( cn[ 1 ]->num(), 2 );
			nn[ 1 ] = &t7;
			cn[ 1 ] = &t7;
			AssertTrue( check_deque( nn, { &t1, &t7, &t3, &t4, nullptr, &t5 } ));
			AssertTrue( check_deque( cn, { &t1, &t7, &t3, &t4, nullptr, &t5 } ));

			AssertTrue( nn[ 2 ] = nn[ 0 ] );
			//AssertTrue( nn[ 3 ] = cn[ 0 ] );			// compile error
			AssertTrue( check_deque( nn, { &t1, &t7, &t1, &t4, nullptr, &t5 } ));
			AssertTrue( cn[ 2 ] = nn[ 5 ] );
			AssertTrue( cn[ 3 ] = cn[ 5 ] );
			AssertTrue( check_deque( cn, { &t1, &t7, &t5, &t5, nullptr, &t5 } ));
		}

	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test1D()
{
	this->set_subtitle( "list operations (accessor) - deep pointer(pointer) value" );
	{
		fprintf( stderr, "--- at/operator[] ---\n" );
		{
			dp_deque<test*>		lp = { &t1, &t2, &t3, &t4, &t5 };
			dp_deque<test*> const&	cp = lp;

			AssertEqual( *lp[ 0 ], t1 );
			AssertEqual( *lp.at( 1 ), t2 );
			AssertEqual( lp.at( 2 )->num(), 3 );
			AssertEqual( lp[ 3 ]->num(), 4 );
			AssertZero( strcmp( lp[ 4 ]->cstr(), s5 ));

			AssertEqual( *cp[ 0 ], t1 );
			AssertEqual( *cp.at( 1 ), t2 );
			AssertEqual( cp.at( 2 )->num(), 3 );
			AssertEqual( cp[ 3 ]->num(), 4 );
			AssertZero( strcmp( cp[ 4 ]->cstr(), s5 ));

			lp[ 1 ] = dpl( &t4 );
			AssertTrue( check_deque( lp, { &t1, &t4, &t3, &t4, &t5 } ));
			lp[ 3 ] = lp[ 2 ];					
			AssertTrue( check_deque( lp, { &t1, &t4, &t3, &t3, &t5 } ));

			test	bk = *lp[ 2 ];
			*lp[ 2 ] = t7;
			AssertTrue( check_deque( lp, { &t1, &t4, &t7, &t3, &t5 } ));	// different result by stl
			*lp[ 2 ] = bk;

			try {
				AssertEqual( lp.at( 5 ), &t0 );
			}
			catch ( typename std::exception& e ) {
				fprintf( stderr, "*** exception: %s\n", e.what() );
			}
		}
		fprintf( stderr, "--- front/back ---\n" );
		{
			dp_deque<test*>		lp;
			dp_deque<test*> const&	cp = lp;

			lp = { &t1, &t2, &t3, &t1, &t4, &t5 };
			AssertTrue( static_cast<bool>( lp.front() ));
			AssertNotEqual( static_cast<test*>( lp.front()), &t1 );
			AssertEqual( *lp.front(), t1 );
			AssertEqual( lp.front()->num(), 1 );

			test	bk = *lp.front();
			*lp.front() = t7;
			AssertTrue( check_deque( lp, { &t7, &t2, &t3, &t1, &t4, &t5 } ));
			*lp.front() = bk;

			AssertTrue( static_cast<bool>( lp.back() ));
			AssertNotEqual( static_cast<test*>( lp.back()), &t5 );
			AssertEqual( *lp.back(), t5 );
			AssertEqual( lp.back()->num(), 5 );

			AssertTrue( static_cast<bool>( cp.front() ));
			AssertNotEqual( static_cast<const test*>( cp.front()), &t1 );
			AssertEqual( *cp.front(), t1 );
			AssertEqual( cp.front()->num(), 1 );

			AssertTrue( static_cast<bool>( cp.back() ));
			AssertNotEqual( static_cast<const test*>( cp.back()), &t5 );
			AssertEqual( *cp.back(), t5 );
			AssertEqual( cp.back()->num(), 5 );

			lp.back() = lp.front();			
			AssertNotEqual( static_cast<test*>( lp.back()), &t1 );	// &t1 will be copy assigned
			AssertTrue( check_deque( lp, { &t1, &t2, &t3, &t1, &t4, &t1 } ));
		}

		fprintf( stderr, "--- returned reference\n" );
		{
			dp_deque<test*>		nn { &t1, &t2, &t3, &t4, nullptr, &t5 };
			dp_deque<const test*>		cn { &t1, &t2, &t3, &t4, nullptr, &t5 };

			AssertNotEqual( nn[ 1 ], &t2 );				// adresss comparison
			AssertNotEqual( cn[ 1 ], &t2 );			//
			AssertEqual( *nn[ 1 ], t2 );
			AssertEqual( *cn[ 1 ], t2 );
			AssertEqual( nn[ 1 ]->num(), 2 );
			AssertEqual( cn[ 1 ]->num(), 2 );
			nn[ 1 ] = dpl( &t7 );
			cn[ 1 ] = dpl( &t7 );
			AssertTrue( check_deque( nn, { &t1, &t7, &t3, &t4, nullptr, &t5 } ));
			AssertTrue( check_deque( cn, { &t1, &t7, &t3, &t4, nullptr, &t5 } ));

			AssertTrue( nn[ 2 ] = nn[ 0 ] );
			//AssertTrue( nn[ 3 ] = cn[ 0 ] );			// compile error
			AssertTrue( check_deque( nn, { &t1, &t7, &t1, &t4, nullptr, &t5 } ));
			AssertTrue( cn[ 2 ] = nn[ 5 ] );
			AssertTrue( cn[ 3 ] = cn[ 5 ] );
			AssertTrue( check_deque( cn, { &t1, &t7, &t5, &t5, nullptr, &t5 } ));
		}

	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test1E()
{
	this->set_subtitle( "list operations (accessor) - reference pointer(c-string) value" );
	{
		fprintf( stderr, "--- at/operator[] ---\n" );
		{
			dr_deque<const char[]>		lp = { s1, s2, s3, s4, s5 };
			dr_deque<const char[]> const&	cp = lp;

			AssertZero( strcmp( lp[ 0 ], s1 ));
			AssertZero( strcmp( lp.at( 2 ), s3 ));

			AssertZero( strcmp( cp[ 0 ], s1 ));
			AssertZero( strcmp( cp.at( 2 ), s3 ));

			lp[ 1 ] = s4;
			AssertTrue( check_deque( lp, { s1, s4, s3, s4, s5 } ));
			lp[ 3 ] = lp[ 2 ];					
			AssertTrue( check_deque( lp, { s1, s4, s3, s3, s5 } ));

			try {
				AssertEqual( lp.at( 5 ), s0 );
			}
			catch ( typename std::exception& e ) {
				fprintf( stderr, "*** exception: %s\n", e.what() );
			}
		}
		fprintf( stderr, "--- front/back ---\n" );
		{
			dr_deque<const char[]>		lp;
			dr_deque<const char[]> const&	cp = lp;

			lp = { s1, s2, s3, s1, s4, s5 };
			AssertTrue( static_cast<bool>( lp.front() ));
			AssertEqual( static_cast<const char*>( lp.front()), s1 );
			AssertZero( strcmp( lp.front(), s1 ));

			AssertTrue( static_cast<bool>( lp.back() ));
			AssertEqual( static_cast<const char*>( lp.back()), s5 );
			AssertZero( strcmp( lp.back(), s5 ));

			AssertTrue( static_cast<bool>( cp.front() ));
			AssertEqual( static_cast<const char*>( cp.front()), s1 );
			AssertZero( strcmp( cp.front(), s1 ));

			AssertTrue( static_cast<bool>( cp.back() ));
			AssertEqual( static_cast<const char*>( cp.back()), s5 );
			AssertZero( strcmp( cp.back(), s5 ));

			lp.back() = lp.front();			
			AssertEqual( static_cast<const char*>( lp.back()), s1 );	// the first and the last both refer s1
			AssertTrue( check_deque( lp, { s1, s2, s3, s1, s4, s1 } ));
		}


	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test1F()
{
	this->set_subtitle( "list operations (accessor) - deep pointer(c-string) value" );
	{
		fprintf( stderr, "--- at/operator[] ---\n" );
		{
			dp_deque<const char[]>		lp = { s1, s2, s3, s4, s5 };
			dp_deque<const char[]> const&	cp = lp;

			AssertZero( strcmp( lp[ 0 ], s1 ));
			AssertZero( strcmp( lp.at( 2 ), s3 ));

			AssertZero( strcmp( cp[ 0 ], s1 ));
			AssertZero( strcmp( cp.at( 2 ), s3 ));

			lp[ 1 ] = strdup( s4 );
			AssertTrue( check_deque( lp, { s1, s4, s3, s4, s5 } ));
			lp[ 3 ] = lp[ 2 ];					
			AssertTrue( check_deque( lp, { s1, s4, s3, s3, s5 } ));

			try {
				AssertEqual( lp.at( 5 ), s0 );
			}
			catch ( typename std::exception& e ) {
				fprintf( stderr, "*** exception: %s\n", e.what() );
			}
		}
		fprintf( stderr, "--- front/back ---\n" );
		{
			dp_deque<const char[]>		lp;
			dp_deque<const char[]> const&	cp = lp;

			lp = { s1, s2, s3, s1, s4, s5 };
			AssertTrue( static_cast<bool>( lp.front() ));
			AssertNotEqual( static_cast<const char*>( lp.front()), s1 );
			AssertZero( strcmp( lp.front(), s1 ));

			AssertTrue( static_cast<bool>( lp.back() ));
			AssertNotEqual( static_cast<const char*>( lp.back()), s5 );
			AssertZero( strcmp( lp.back(), s5 ));

			AssertTrue( static_cast<bool>( cp.front() ));
			AssertNotEqual( static_cast<const char*>( cp.front()), s1 );
			AssertZero( strcmp( cp.front(), s1 ));

			AssertTrue( static_cast<bool>( cp.back() ));
			AssertNotEqual( static_cast<const char*>( cp.back()), s5 );
			AssertZero( strcmp( cp.back(), s5 ));

			lp.back() = lp.front();			
			AssertNotEqual( static_cast<const char*>( lp.back()), s1 );	// s1 will be copy assigned
			AssertTrue( check_deque( lp, { s1, s2, s3, s1, s4, s1 } ));
		}


	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test20()
{
	this->set_subtitle( "list operations (accessor) - reference pointer(v-array) value" );
	{
		fprintf( stderr, "--- at/operator[] ---\n" );
		{
			dr_deque<test[]>		lp = { v1, v2, v3, v4, v5 };
			dr_deque<test[]> const&	cp = lp;

			AssertTrue( dp_eql<test[]>()( lp[ 0 ], v1 ));
			AssertTrue( dp_eql<test[]>()( lp.at( 2 ), v3 ));

			AssertTrue( dp_eql<test[]>()( cp[ 0 ], v1 ));
			AssertTrue( dp_eql<test[]>()( cp.at( 2 ), v3 ));

			lp[ 1 ] = v4;
			AssertTrue( check_deque( lp, { v1, v4, v3, v4, v5 } ));
			lp[ 3 ] = lp[ 2 ];					
			AssertTrue( check_deque( lp, { v1, v4, v3, v3, v5 } ));

			try {
				AssertEqual( lp.at( 5 ), v0 );
			}
			catch ( typename std::exception& e ) {
				fprintf( stderr, "*** exception: %s\n", e.what() );
			}
		}
		fprintf( stderr, "--- front/back ---\n" );
		{
			dr_deque<test[]>		lp;
			dr_deque<test[]> const&	cp = lp;

			lp = { v1, v2, v3, v1, v4, v5 };
			AssertTrue( static_cast<bool>( lp.front() ));
			AssertEqual( static_cast<test*>( lp.front()), v1 );
			AssertTrue( dp_eql<test[]>()( lp.front(), v1 ));

			AssertTrue( static_cast<bool>( lp.back() ));
			AssertEqual( static_cast<test*>( lp.back()), v5 );
			AssertTrue( dp_eql<test[]>()( lp.back(), v5 ));

			AssertTrue( static_cast<bool>( cp.front() ));
			AssertEqual( static_cast<const test*>( cp.front()), v1 );
			AssertTrue( dp_eql<test[]>()( cp.front(), v1 ));

			AssertTrue( static_cast<bool>( cp.back() ));
			AssertEqual( static_cast<const test*>( cp.back()), v5 );
			AssertTrue( dp_eql<test[]>()( cp.back(), v5 ));

			lp.back() = lp.front();			
			AssertEqual( static_cast<test*>( lp.back()), v1 );	// the first and the last both refer v1
			AssertTrue( check_deque( lp, { v1, v2, v3, v1, v4, v1 } ));
		}


	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test21()
{
	this->set_subtitle( "list operations (accessor) - deep pointer(v-array) value" );
	{
		fprintf( stderr, "--- at/operator[] ---\n" );
		{
			dp_deque<test[]>		lp = { v1, v2, v3, v4, v5 };
			dp_deque<test[]> const&	cp = lp;

			AssertTrue( dp_eql<test[]>()( lp[ 0 ], v1 ));
			AssertTrue( dp_eql<test[]>()( lp.at( 2 ), v3 ));

			AssertTrue( dp_eql<test[]>()( cp[ 0 ], v1 ));
			AssertTrue( dp_eql<test[]>()( cp.at( 2 ), v3 ));

			lp[ 1 ] = dpl( v4 );
			AssertTrue( check_deque( lp, { v1, v4, v3, v4, v5 } ));
			lp[ 3 ] = lp[ 2 ];					
			AssertTrue( check_deque( lp, { v1, v4, v3, v3, v5 } ));

			try {
				AssertEqual( lp.at( 5 ), v0 );
			}
			catch ( typename std::exception& e ) {
				fprintf( stderr, "*** exception: %s\n", e.what() );
			}
		}
		fprintf( stderr, "--- front/back ---\n" );
		{
			dp_deque<test[]>		lp;
			dp_deque<test[]> const&	cp = lp;

			lp = { v1, v2, v3, v1, v4, v5 };
			AssertTrue( static_cast<bool>( lp.front() ));
			AssertNotEqual( static_cast<test*>( lp.front()), v1 );
			AssertTrue( dp_eql<test[]>()( lp.front(), v1 ));

			AssertTrue( static_cast<bool>( lp.back() ));
			AssertNotEqual( static_cast<test*>( lp.back()), v5 );
			AssertTrue( dp_eql<test[]>()( lp.back(), v5 ));

			AssertTrue( static_cast<bool>( cp.front() ));
			AssertNotEqual( static_cast<const test*>( cp.front()), v1 );
			AssertTrue( dp_eql<test[]>()( cp.front(), v1 ));

			AssertTrue( static_cast<bool>( cp.back() ));
			AssertNotEqual( static_cast<const test*>( cp.back()), v5 );
			AssertTrue( dp_eql<test[]>()( cp.back(), v5 ));

			lp.back() = lp.front();			
			AssertNotEqual( static_cast<test*>( lp.back()), v1 );	// v1 will be copy assigned
			AssertTrue( check_deque( lp, { v1, v2, v3, v1, v4, v1 } ));
		}


	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test22()
{
	this->set_subtitle( "list operations (accessor) - reference pointer(f-array) value" );
	{
		fprintf( stderr, "--- at/operator[] ---\n" );
		{
			dr_deque<test[3]>		lp = { w1, w2, w3, w4, w5 };
			dr_deque<test[3]> const&	cp = lp;

			AssertTrue( dp_eql<test[3]>()( lp[ 0 ], w1 ));
			AssertTrue( dp_eql<test[3]>()( lp.at( 2 ), w3 ));

			AssertTrue( dp_eql<test[3]>()( cp[ 0 ], w1 ));
			AssertTrue( dp_eql<test[3]>()( cp.at( 2 ), w3 ));

			lp[ 1 ] = w4;
			AssertTrue( check_deque( lp, { w1, w4, w3, w4, w5 } ));
			lp[ 3 ] = lp[ 2 ];					
			AssertTrue( check_deque( lp, { w1, w4, w3, w3, w5 } ));

			try {
				AssertEqual( lp.at( 5 ), w0 );
			}
			catch ( typename std::exception& e ) {
				fprintf( stderr, "*** exception: %s\n", e.what() );
			}
		}
		fprintf( stderr, "--- front/back ---\n" );
		{
			dr_deque<test[3]>		lp;
			dr_deque<test[3]> const&	cp = lp;

			lp = { w1, w2, w3, w1, w4, w5 };
			AssertTrue( static_cast<bool>( lp.front() ));
			AssertEqual( static_cast<test*>( lp.front()), w1 );
			AssertTrue( dp_eql<test[3]>()( lp.front(), w1 ));

			AssertTrue( static_cast<bool>( lp.back() ));
			AssertEqual( static_cast<test*>( lp.back()), w5 );
			AssertTrue( dp_eql<test[3]>()( lp.back(), w5 ));

			AssertTrue( static_cast<bool>( cp.front() ));
			AssertEqual( static_cast<const test*>( cp.front()), w1 );
			AssertTrue( dp_eql<test[3]>()( cp.front(), w1 ));

			AssertTrue( static_cast<bool>( cp.back() ));
			AssertEqual( static_cast<const test*>( cp.back()), w5 );
			AssertTrue( dp_eql<test[3]>()( cp.back(), w5 ));

			lp.back() = lp.front();			
			AssertEqual( static_cast<test*>( lp.back()), w1 );	// the first and the last both refer w1
			AssertTrue( check_deque( lp, { w1, w2, w3, w1, w4, w1 } ));
		}


	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test23()
{
	this->set_subtitle( "list operations (accessor) - deep pointer(f-array) value" );
	{
		fprintf( stderr, "--- at/operator[] ---\n" );
		{
			dp_deque<test[3]>		lp = { w1, w2, w3, w4, w5 };
			dp_deque<test[3]> const&	cp = lp;

			AssertTrue( dp_eql<test[3]>()( lp[ 0 ], w1 ));
			AssertTrue( dp_eql<test[3]>()( lp.at( 2 ), w3 ));

			AssertTrue( dp_eql<test[3]>()( cp[ 0 ], w1 ));
			AssertTrue( dp_eql<test[3]>()( cp.at( 2 ), w3 ));

			lp[ 1 ] = dpl( w4 );
			AssertTrue( check_deque( lp, { w1, w4, w3, w4, w5 } ));
			lp[ 3 ] = lp[ 2 ];					
			AssertTrue( check_deque( lp, { w1, w4, w3, w3, w5 } ));

			try {
				AssertEqual( lp.at( 5 ), w0 );
			}
			catch ( typename std::exception& e ) {
				fprintf( stderr, "*** exception: %s\n", e.what() );
			}
		}
		fprintf( stderr, "--- front/back ---\n" );
		{
			dp_deque<test[3]>		lp;
			dp_deque<test[3]> const&	cp = lp;

			lp = { w1, w2, w3, w1, w4, w5 };
			AssertTrue( static_cast<bool>( lp.front() ));
			AssertNotEqual( static_cast<test*>( lp.front()), w1 );
			AssertTrue( dp_eql<test[3]>()( lp.front(), w1 ));

			AssertTrue( static_cast<bool>( lp.back() ));
			AssertNotEqual( static_cast<test*>( lp.back()), w5 );
			AssertTrue( dp_eql<test[3]>()( lp.back(), w5 ));

			AssertTrue( static_cast<bool>( cp.front() ));
			AssertNotEqual( static_cast<const test*>( cp.front()), w1 );
			AssertTrue( dp_eql<test[3]>()( cp.front(), w1 ));

			AssertTrue( static_cast<bool>( cp.back() ));
			AssertNotEqual( static_cast<const test*>( cp.back()), w5 );
			AssertTrue( dp_eql<test[3]>()( cp.back(), w5 ));

			lp.back() = lp.front();			
			AssertNotEqual( static_cast<test*>( lp.back()), w1 );	// w1 will be copy assigned
			AssertTrue( check_deque( lp, { w1, w2, w3, w1, w4, w1 } ));
		}


	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test24()
{
	this->set_subtitle( "list operations (accessor) - data(int value) value" );
	{
		fprintf( stderr, "--- at/operator[] ---\n" );
		{
			std::deque<int>		lp = { 1, 2, 3, 4, 5 };
			std::deque<int> const&	cp = lp;





			lp[ 1 ] = 4;
			AssertTrue( check_deque( lp, { 1, 4, 3, 4, 5 } ));
			lp[ 3 ] = lp[ 2 ];					
			AssertTrue( check_deque( lp, { 1, 4, 3, 3, 5 } ));

			try {
				AssertEqual( lp.at( 5 ), 0 );
			}
			catch ( typename std::exception& e ) {
				fprintf( stderr, "*** exception: %s\n", e.what() );
			}
		}
		fprintf( stderr, "--- front/back ---\n" );
		{
			std::deque<int>		lp;
			std::deque<int> const&	cp = lp;

			lp = { 1, 2, 3, 1, 4, 5 };
			AssertTrue( static_cast<bool>( lp.front() ));



			AssertTrue( static_cast<bool>( lp.back() ));



			AssertTrue( static_cast<bool>( cp.front() ));



			AssertTrue( static_cast<bool>( cp.back() ));



			lp.back() = lp.front();			

			AssertTrue( check_deque( lp, { 1, 2, 3, 1, 4, 1 } ));
		}


	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test25()
{
	this->set_subtitle( "iterator - reference pointer(pointer) value" );

	fprintf( stderr, "--- iterator ---\n" );
	{
		dr_deque<test*>		lr;
		dr_deque<test*>::iterator	e, i, j;
		unsigned			n;

		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertZero( n );

		lr = { &t1, &t2, &t3, &t4, &t5 };
		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		i = lr.begin();
		e = lr.end();
		j = i + 2;
		while ( i != e ) {
			if ( i == j ) *i = &t7;
			println( *i );
			++i;
		}
		AssertTrue( check_deque( lr, { &t1, &t2, &t7, &t4, &t5 } ));

		for ( test* const& p : lr ) println( p );
	}
	fprintf( stderr, "--- const_iterator ---\n" );
	{
		const dr_deque<test*>		lr = { &t1, &t2, &t3, &t4, &t5 };
		unsigned			n = 0;

		for ( auto i = lr.begin(); i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		AssertEqual( **( lr.begin() += 3 ), t4 );

		n = 0;
		for ( auto i = lr.begin(); i != lr.end(); ++i ) { n += ( *i )->num(); }
		AssertEqual( n, 15 );

		for ( const test* const& p : lr ) println( p );
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test26()
{
	this->set_subtitle( "iterator - deep pointer(pointer) value" );

	fprintf( stderr, "--- iterator ---\n" );
	{
		dp_deque<test*>		lr;
		dp_deque<test*>::iterator	e, i, j;
		unsigned			n;

		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertZero( n );

		lr = { &t1, &t2, &t3, &t4, &t5 };
		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		i = lr.begin();
		e = lr.end();
		j = i + 2;
		while ( i != e ) {
			if ( i == j ) *i = dpl( &t7 );
			println( *i );
			++i;
		}
		AssertTrue( check_deque( lr, { &t1, &t2, &t7, &t4, &t5 } ));

		for ( test* const& p : lr ) println( p );
	}
	fprintf( stderr, "--- const_iterator ---\n" );
	{
		const dp_deque<test*>		lr = { &t1, &t2, &t3, &t4, &t5 };
		unsigned			n = 0;

		for ( auto i = lr.begin(); i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		AssertEqual( **( lr.begin() += 3 ), t4 );

		n = 0;
		for ( auto i = lr.begin(); i != lr.end(); ++i ) { n += ( *i )->num(); }
		AssertEqual( n, 15 );

		for ( const test* const& p : lr ) println( p );
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test27()
{
	this->set_subtitle( "iterator - reference pointer(c-string) value" );

	fprintf( stderr, "--- iterator ---\n" );
	{
		dr_deque<const char[]>		lr;
		dr_deque<const char[]>::iterator	e, i, j;
		unsigned			n;

		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertZero( n );

		lr = { s1, s2, s3, s4, s5 };
		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		i = lr.begin();
		e = lr.end();
		j = i + 2;
		while ( i != e ) {
			if ( i == j ) *i = s7;
			println( *i );
			++i;
		}
		AssertTrue( check_deque( lr, { s1, s2, s7, s4, s5 } ));

		for ( const char* const& p : lr ) println( p );
	}
	fprintf( stderr, "--- const_iterator ---\n" );
	{
		const dr_deque<const char[]>		lr = { s1, s2, s3, s4, s5 };
		unsigned			n = 0;

		for ( auto i = lr.begin(); i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		AssertZero( strcmp( *( lr.begin() += 3 ), s4 ));

		n = 0;
		for ( auto i = lr.begin(); i != lr.end(); ++i ) { n += strlen( *i ); }
		AssertEqual( n, 30 );

		for ( const char* const& p : lr ) println( p );
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test28()
{
	this->set_subtitle( "iterator - deep pointer(c-string) value" );

	fprintf( stderr, "--- iterator ---\n" );
	{
		dp_deque<const char[]>		lr;
		dp_deque<const char[]>::iterator	e, i, j;
		unsigned			n;

		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertZero( n );

		lr = { s1, s2, s3, s4, s5 };
		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		i = lr.begin();
		e = lr.end();
		j = i + 2;
		while ( i != e ) {
			if ( i == j ) *i = strdup( s7 );
			println( *i );
			++i;
		}
		AssertTrue( check_deque( lr, { s1, s2, s7, s4, s5 } ));

		for ( const char* const& p : lr ) println( p );
	}
	fprintf( stderr, "--- const_iterator ---\n" );
	{
		const dp_deque<const char[]>		lr = { s1, s2, s3, s4, s5 };
		unsigned			n = 0;

		for ( auto i = lr.begin(); i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		AssertZero( strcmp( *( lr.begin() += 3 ), s4 ));

		n = 0;
		for ( auto i = lr.begin(); i != lr.end(); ++i ) { n += strlen( *i ); }
		AssertEqual( n, 30 );

		for ( const char* const& p : lr ) println( p );
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test29()
{
	this->set_subtitle( "iterator - reference pointer(v-array) value" );

	fprintf( stderr, "--- iterator ---\n" );
	{
		dr_deque<test[]>		lr;
		dr_deque<test[]>::iterator	e, i, j;
		unsigned			n;

		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertZero( n );

		lr = { v1, v2, v3, v4, v5 };
		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		i = lr.begin();
		e = lr.end();
		j = i + 2;
		while ( i != e ) {
			if ( i == j ) *i = v7;
			println( *i );
			++i;
		}
		AssertTrue( check_deque( lr, { v1, v2, v7, v4, v5 } ));

		for ( test* const& p : lr ) println( p );
	}
	fprintf( stderr, "--- const_iterator ---\n" );
	{
		const dr_deque<test[]>		lr = { v1, v2, v3, v4, v5 };
		unsigned			n = 0;

		for ( auto i = lr.begin(); i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		AssertTrue( dp_eql<test[]>()( *( lr.begin() += 3 ), v4 ));

		n = 0;
		for ( auto i = lr.begin(); i != lr.end(); ++i ) { n += ( *i )[ 0 ].num(); }
		AssertEqual( n, 15 );

		for ( const test* const& p : lr ) println( p );
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test2A()
{
	this->set_subtitle( "iterator - deep pointer(v-array) value" );

	fprintf( stderr, "--- iterator ---\n" );
	{
		dp_deque<test[]>		lr;
		dp_deque<test[]>::iterator	e, i, j;
		unsigned			n;

		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertZero( n );

		lr = { v1, v2, v3, v4, v5 };
		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		i = lr.begin();
		e = lr.end();
		j = i + 2;
		while ( i != e ) {
			if ( i == j ) *i = dpl( v7 );
			println( *i );
			++i;
		}
		AssertTrue( check_deque( lr, { v1, v2, v7, v4, v5 } ));

		for ( test* const& p : lr ) println( p );
	}
	fprintf( stderr, "--- const_iterator ---\n" );
	{
		const dp_deque<test[]>		lr = { v1, v2, v3, v4, v5 };
		unsigned			n = 0;

		for ( auto i = lr.begin(); i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		AssertTrue( dp_eql<test[]>()( *( lr.begin() += 3 ), v4 ));

		n = 0;
		for ( auto i = lr.begin(); i != lr.end(); ++i ) { n += ( *i )[ 0 ].num(); }
		AssertEqual( n, 15 );

		for ( const test* const& p : lr ) println( p );
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test2B()
{
	this->set_subtitle( "iterator - reference pointer(f-array) value" );

	fprintf( stderr, "--- iterator ---\n" );
	{
		dr_deque<test[3]>		lr;
		dr_deque<test[3]>::iterator	e, i, j;
		unsigned			n;

		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertZero( n );

		lr = { w1, w2, w3, w4, w5 };
		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		i = lr.begin();
		e = lr.end();
		j = i + 2;
		while ( i != e ) {
			if ( i == j ) *i = w7;
			println( *i );
			++i;
		}
		AssertTrue( check_deque( lr, { w1, w2, w7, w4, w5 } ));

		for ( test* const& p : lr ) println( p );
	}
	fprintf( stderr, "--- const_iterator ---\n" );
	{
		const dr_deque<test[3]>		lr = { w1, w2, w3, w4, w5 };
		unsigned			n = 0;

		for ( auto i = lr.begin(); i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		AssertTrue( dp_eql<test[3]>()( *( lr.begin() += 3 ), w4 ));

		n = 0;
		for ( auto i = lr.begin(); i != lr.end(); ++i ) { n += ( *i )[ 0 ].num(); }
		AssertEqual( n, 15 );

		for ( const test* const& p : lr ) println( p );
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test2C()
{
	this->set_subtitle( "iterator - deep pointer(f-array) value" );

	fprintf( stderr, "--- iterator ---\n" );
	{
		dp_deque<test[3]>		lr;
		dp_deque<test[3]>::iterator	e, i, j;
		unsigned			n;

		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertZero( n );

		lr = { w1, w2, w3, w4, w5 };
		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		i = lr.begin();
		e = lr.end();
		j = i + 2;
		while ( i != e ) {
			if ( i == j ) *i = dpl( w7 );
			println( *i );
			++i;
		}
		AssertTrue( check_deque( lr, { w1, w2, w7, w4, w5 } ));

		for ( test* const& p : lr ) println( p );
	}
	fprintf( stderr, "--- const_iterator ---\n" );
	{
		const dp_deque<test[3]>		lr = { w1, w2, w3, w4, w5 };
		unsigned			n = 0;

		for ( auto i = lr.begin(); i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		AssertTrue( dp_eql<test[3]>()( *( lr.begin() += 3 ), w4 ));

		n = 0;
		for ( auto i = lr.begin(); i != lr.end(); ++i ) { n += ( *i )[ 0 ].num(); }
		AssertEqual( n, 15 );

		for ( const test* const& p : lr ) println( p );
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test2D()
{
	this->set_subtitle( "iterator - data(int value) value" );

	fprintf( stderr, "--- iterator ---\n" );
	{
		std::deque<int>		lr;
		std::deque<int>::iterator	e, i, j;
		unsigned			n;

		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertZero( n );

		lr = { 1, 2, 3, 4, 5 };
		for ( i = lr.begin(), n = 0; i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );

		i = lr.begin();
		e = lr.end();
		j = i + 2;
		while ( i != e ) {
			if ( i == j ) *i = 7;
			println( *i );
			++i;
		}
		AssertTrue( check_deque( lr, { 1, 2, 7, 4, 5 } ));

		for ( int const& p : lr ) println( p );
	}
	fprintf( stderr, "--- const_iterator ---\n" );
	{
		const std::deque<int>		lr = { 1, 2, 3, 4, 5 };
		unsigned			n = 0;

		for ( auto i = lr.begin(); i != lr.end(); ++i, ++n ) println( *i );
		AssertEqual( n, 5 );



		n = 0;


		for ( int const& p : lr ) println( p );
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test2E()
{
	this->set_subtitle( "list operations (miscellaneous) - reference pointer(pointer) value" );

	dr_deque<test*>	r0;
	dr_deque<test*>	r1 = { &t1 };
	dr_deque<test*>	r5 = { &t1, &t2, &t3, &t4, &t5 };

	fprintf( stderr, "--- empty() ---\n" );
	AssertTrue( r0.empty());
	AssertFalse( r1.empty());
	AssertFalse( r5.empty());

	fprintf( stderr, "--- size() ---\n" );
	AssertEqual( r0.size(), 0 );
	AssertEqual( r1.size(), 1 );
	AssertEqual( r5.size(), 5 );

	fprintf( stderr, "--- resize() ---\n" );
	{
		dr_deque<test*>  l5 = r5;
		l5.resize( 3 );
		AssertTrue( check_deque( l5, { &t1, &t2, &t3 } ));
		dr_deque<test*>  l1 = r1;
		l1.resize( 3 );
		AssertTrue( check_deque( l1, { &t1, nullptr, nullptr } ));
		dr_deque<test*>  l0 = r0;
		l0.resize( 3 );
		AssertTrue( check_deque( l0, { nullptr, nullptr, nullptr } ));
	}

	fprintf( stderr, "--- swap, clear ---\n" );
	{
		dr_deque<test*>	  lx;
		dr_deque<test*>	  ly;

		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( ly.empty());
		lx = r5;
		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { &t1, &t2, &t3, &t4, &t5 } ));
		lx.swap( ly );
		AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
		AssertTrue( ly.empty());

		lx = r5;
		lx.clear();
		AssertTrue( lx.empty());
		lx.clear();
		AssertTrue( lx.empty());
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test2F()
{
	this->set_subtitle( "list operations (miscellaneous) - deep pointer(pointer) value" );

	dp_deque<test*>	r0;
	dp_deque<test*>	r1 = { &t1 };
	dp_deque<test*>	r5 = { &t1, &t2, &t3, &t4, &t5 };

	fprintf( stderr, "--- empty() ---\n" );
	AssertTrue( r0.empty());
	AssertFalse( r1.empty());
	AssertFalse( r5.empty());

	fprintf( stderr, "--- size() ---\n" );
	AssertEqual( r0.size(), 0 );
	AssertEqual( r1.size(), 1 );
	AssertEqual( r5.size(), 5 );

	fprintf( stderr, "--- resize() ---\n" );
	{
		dp_deque<test*>  l5 = r5;
		l5.resize( 3 );
		AssertTrue( check_deque( l5, { &t1, &t2, &t3 } ));
		dp_deque<test*>  l1 = r1;
		l1.resize( 3 );
		AssertTrue( check_deque( l1, { &t1, nullptr, nullptr } ));
		dp_deque<test*>  l0 = r0;
		l0.resize( 3 );
		AssertTrue( check_deque( l0, { nullptr, nullptr, nullptr } ));
	}

	fprintf( stderr, "--- swap, clear ---\n" );
	{
		dp_deque<test*>	  lx;
		dp_deque<test*>	  ly;

		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( ly.empty());
		lx = r5;
		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { &t1, &t2, &t3, &t4, &t5 } ));
		lx.swap( ly );
		AssertTrue( check_deque( lx, { &t1, &t2, &t3, &t4, &t5 } ));
		AssertTrue( ly.empty());

		lx = r5;
		lx.clear();
		AssertTrue( lx.empty());
		lx.clear();
		AssertTrue( lx.empty());
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test30()
{
	this->set_subtitle( "list operations (miscellaneous) - reference pointer(c-string) value" );

	dr_deque<const char[]>	r0;
	dr_deque<const char[]>	r1 = { s1 };
	dr_deque<const char[]>	r5 = { s1, s2, s3, s4, s5 };

	fprintf( stderr, "--- empty() ---\n" );
	AssertTrue( r0.empty());
	AssertFalse( r1.empty());
	AssertFalse( r5.empty());

	fprintf( stderr, "--- size() ---\n" );
	AssertEqual( r0.size(), 0 );
	AssertEqual( r1.size(), 1 );
	AssertEqual( r5.size(), 5 );

	fprintf( stderr, "--- resize() ---\n" );
	{
		dr_deque<const char[]>  l5 = r5;
		l5.resize( 3 );
		AssertTrue( check_deque( l5, { s1, s2, s3 } ));
		dr_deque<const char[]>  l1 = r1;
		l1.resize( 3 );
		AssertTrue( check_deque( l1, { s1, nullptr, nullptr } ));
		dr_deque<const char[]>  l0 = r0;
		l0.resize( 3 );
		AssertTrue( check_deque( l0, { nullptr, nullptr, nullptr } ));
	}

	fprintf( stderr, "--- swap, clear ---\n" );
	{
		dr_deque<const char[]>	  lx;
		dr_deque<const char[]>	  ly;

		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( ly.empty());
		lx = r5;
		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { s1, s2, s3, s4, s5 } ));
		lx.swap( ly );
		AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
		AssertTrue( ly.empty());

		lx = r5;
		lx.clear();
		AssertTrue( lx.empty());
		lx.clear();
		AssertTrue( lx.empty());
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test31()
{
	this->set_subtitle( "list operations (miscellaneous) - deep pointer(c-string) value" );

	dp_deque<const char[]>	r0;
	dp_deque<const char[]>	r1 = { s1 };
	dp_deque<const char[]>	r5 = { s1, s2, s3, s4, s5 };

	fprintf( stderr, "--- empty() ---\n" );
	AssertTrue( r0.empty());
	AssertFalse( r1.empty());
	AssertFalse( r5.empty());

	fprintf( stderr, "--- size() ---\n" );
	AssertEqual( r0.size(), 0 );
	AssertEqual( r1.size(), 1 );
	AssertEqual( r5.size(), 5 );

	fprintf( stderr, "--- resize() ---\n" );
	{
		dp_deque<const char[]>  l5 = r5;
		l5.resize( 3 );
		AssertTrue( check_deque( l5, { s1, s2, s3 } ));
		dp_deque<const char[]>  l1 = r1;
		l1.resize( 3 );
		AssertTrue( check_deque( l1, { s1, nullptr, nullptr } ));
		dp_deque<const char[]>  l0 = r0;
		l0.resize( 3 );
		AssertTrue( check_deque( l0, { nullptr, nullptr, nullptr } ));
	}

	fprintf( stderr, "--- swap, clear ---\n" );
	{
		dp_deque<const char[]>	  lx;
		dp_deque<const char[]>	  ly;

		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( ly.empty());
		lx = r5;
		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { s1, s2, s3, s4, s5 } ));
		lx.swap( ly );
		AssertTrue( check_deque( lx, { s1, s2, s3, s4, s5 } ));
		AssertTrue( ly.empty());

		lx = r5;
		lx.clear();
		AssertTrue( lx.empty());
		lx.clear();
		AssertTrue( lx.empty());
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test32()
{
	this->set_subtitle( "list operations (miscellaneous) - reference pointer(v-array) value" );

	dr_deque<test[]>	r0;
	dr_deque<test[]>	r1 = { v1 };
	dr_deque<test[]>	r5 = { v1, v2, v3, v4, v5 };

	fprintf( stderr, "--- empty() ---\n" );
	AssertTrue( r0.empty());
	AssertFalse( r1.empty());
	AssertFalse( r5.empty());

	fprintf( stderr, "--- size() ---\n" );
	AssertEqual( r0.size(), 0 );
	AssertEqual( r1.size(), 1 );
	AssertEqual( r5.size(), 5 );

	fprintf( stderr, "--- resize() ---\n" );
	{
		dr_deque<test[]>  l5 = r5;
		l5.resize( 3 );
		AssertTrue( check_deque( l5, { v1, v2, v3 } ));
		dr_deque<test[]>  l1 = r1;
		l1.resize( 3 );
		AssertTrue( check_deque( l1, { v1, nullptr, nullptr } ));
		dr_deque<test[]>  l0 = r0;
		l0.resize( 3 );
		AssertTrue( check_deque( l0, { nullptr, nullptr, nullptr } ));
	}

	fprintf( stderr, "--- swap, clear ---\n" );
	{
		dr_deque<test[]>	  lx;
		dr_deque<test[]>	  ly;

		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( ly.empty());
		lx = r5;
		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { v1, v2, v3, v4, v5 } ));
		lx.swap( ly );
		AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
		AssertTrue( ly.empty());

		lx = r5;
		lx.clear();
		AssertTrue( lx.empty());
		lx.clear();
		AssertTrue( lx.empty());
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test33()
{
	this->set_subtitle( "list operations (miscellaneous) - deep pointer(v-array) value" );

	dp_deque<test[]>	r0;
	dp_deque<test[]>	r1 = { v1 };
	dp_deque<test[]>	r5 = { v1, v2, v3, v4, v5 };

	fprintf( stderr, "--- empty() ---\n" );
	AssertTrue( r0.empty());
	AssertFalse( r1.empty());
	AssertFalse( r5.empty());

	fprintf( stderr, "--- size() ---\n" );
	AssertEqual( r0.size(), 0 );
	AssertEqual( r1.size(), 1 );
	AssertEqual( r5.size(), 5 );

	fprintf( stderr, "--- resize() ---\n" );
	{
		dp_deque<test[]>  l5 = r5;
		l5.resize( 3 );
		AssertTrue( check_deque( l5, { v1, v2, v3 } ));
		dp_deque<test[]>  l1 = r1;
		l1.resize( 3 );
		AssertTrue( check_deque( l1, { v1, nullptr, nullptr } ));
		dp_deque<test[]>  l0 = r0;
		l0.resize( 3 );
		AssertTrue( check_deque( l0, { nullptr, nullptr, nullptr } ));
	}

	fprintf( stderr, "--- swap, clear ---\n" );
	{
		dp_deque<test[]>	  lx;
		dp_deque<test[]>	  ly;

		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( ly.empty());
		lx = r5;
		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { v1, v2, v3, v4, v5 } ));
		lx.swap( ly );
		AssertTrue( check_deque( lx, { v1, v2, v3, v4, v5 } ));
		AssertTrue( ly.empty());

		lx = r5;
		lx.clear();
		AssertTrue( lx.empty());
		lx.clear();
		AssertTrue( lx.empty());
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test34()
{
	this->set_subtitle( "list operations (miscellaneous) - reference pointer(f-array) value" );

	dr_deque<test[3]>	r0;
	dr_deque<test[3]>	r1 = { w1 };
	dr_deque<test[3]>	r5 = { w1, w2, w3, w4, w5 };

	fprintf( stderr, "--- empty() ---\n" );
	AssertTrue( r0.empty());
	AssertFalse( r1.empty());
	AssertFalse( r5.empty());

	fprintf( stderr, "--- size() ---\n" );
	AssertEqual( r0.size(), 0 );
	AssertEqual( r1.size(), 1 );
	AssertEqual( r5.size(), 5 );

	fprintf( stderr, "--- resize() ---\n" );
	{
		dr_deque<test[3]>  l5 = r5;
		l5.resize( 3 );
		AssertTrue( check_deque( l5, { w1, w2, w3 } ));
		dr_deque<test[3]>  l1 = r1;
		l1.resize( 3 );
		AssertTrue( check_deque( l1, { w1, nullptr, nullptr } ));
		dr_deque<test[3]>  l0 = r0;
		l0.resize( 3 );
		AssertTrue( check_deque( l0, { nullptr, nullptr, nullptr } ));
	}

	fprintf( stderr, "--- swap, clear ---\n" );
	{
		dr_deque<test[3]>	  lx;
		dr_deque<test[3]>	  ly;

		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( ly.empty());
		lx = r5;
		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { w1, w2, w3, w4, w5 } ));
		lx.swap( ly );
		AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
		AssertTrue( ly.empty());

		lx = r5;
		lx.clear();
		AssertTrue( lx.empty());
		lx.clear();
		AssertTrue( lx.empty());
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test35()
{
	this->set_subtitle( "list operations (miscellaneous) - deep pointer(f-array) value" );

	dp_deque<test[3]>	r0;
	dp_deque<test[3]>	r1 = { w1 };
	dp_deque<test[3]>	r5 = { w1, w2, w3, w4, w5 };

	fprintf( stderr, "--- empty() ---\n" );
	AssertTrue( r0.empty());
	AssertFalse( r1.empty());
	AssertFalse( r5.empty());

	fprintf( stderr, "--- size() ---\n" );
	AssertEqual( r0.size(), 0 );
	AssertEqual( r1.size(), 1 );
	AssertEqual( r5.size(), 5 );

	fprintf( stderr, "--- resize() ---\n" );
	{
		dp_deque<test[3]>  l5 = r5;
		l5.resize( 3 );
		AssertTrue( check_deque( l5, { w1, w2, w3 } ));
		dp_deque<test[3]>  l1 = r1;
		l1.resize( 3 );
		AssertTrue( check_deque( l1, { w1, nullptr, nullptr } ));
		dp_deque<test[3]>  l0 = r0;
		l0.resize( 3 );
		AssertTrue( check_deque( l0, { nullptr, nullptr, nullptr } ));
	}

	fprintf( stderr, "--- swap, clear ---\n" );
	{
		dp_deque<test[3]>	  lx;
		dp_deque<test[3]>	  ly;

		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( ly.empty());
		lx = r5;
		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { w1, w2, w3, w4, w5 } ));
		lx.swap( ly );
		AssertTrue( check_deque( lx, { w1, w2, w3, w4, w5 } ));
		AssertTrue( ly.empty());

		lx = r5;
		lx.clear();
		AssertTrue( lx.empty());
		lx.clear();
		AssertTrue( lx.empty());
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test36()
{
	this->set_subtitle( "list operations (miscellaneous) - data(int value) value" );

	std::deque<int>	r0;
	std::deque<int>	r1 = { 1 };
	std::deque<int>	r5 = { 1, 2, 3, 4, 5 };

	fprintf( stderr, "--- empty() ---\n" );
	AssertTrue( r0.empty());
	AssertFalse( r1.empty());
	AssertFalse( r5.empty());

	fprintf( stderr, "--- size() ---\n" );
	AssertEqual( r0.size(), 0 );
	AssertEqual( r1.size(), 1 );
	AssertEqual( r5.size(), 5 );

	fprintf( stderr, "--- resize() ---\n" );
	{
		std::deque<int>  l5 = r5;
		l5.resize( 3 );
		AssertTrue( check_deque( l5, { 1, 2, 3 } ));
		std::deque<int>  l1 = r1;
		l1.resize( 3 );
		AssertTrue( check_deque( l1, { 1, 0, 0 } ));
		std::deque<int>  l0 = r0;
		l0.resize( 3 );
		AssertTrue( check_deque( l0, { 0, 0, 0 } ));
	}

	fprintf( stderr, "--- swap, clear ---\n" );
	{
		std::deque<int>	  lx;
		std::deque<int>	  ly;

		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( ly.empty());
		lx = r5;
		lx.swap( ly );
		AssertTrue( lx.empty());
		AssertTrue( check_deque( ly, { 1, 2, 3, 4, 5 } ));
		lx.swap( ly );
		AssertTrue( check_deque( lx, { 1, 2, 3, 4, 5 } ));
		AssertTrue( ly.empty());

		lx = r5;
		lx.clear();
		AssertTrue( lx.empty());
		lx.clear();
		AssertTrue( lx.empty());
	}
}

// -----------------------------------------------------------------------------
void dp_dequetest::test37()
{
	this->set_subtitle( "relational operators - reference pointer(pointer) value" );

	dr_deque<test*>	l0;
	dr_deque<test*>	l1 = { &t1, &t2, &t3 };
	dr_deque<test*>	l2 = { &t1, &t2, &t3, nullptr };
	dr_deque<test*>	l3 = { &t1, &t2, &t3, &t4 };
	dr_deque<test*>	l4 = { &t1, &t2, &t4 };

	dr_deque<test*>	l  = { &t1, &t2, &t3 };


	fprintf( stderr, "--- equality ---\n" );
	AssertTrue( l != l0 );
	AssertTrue( l == l1 );
	AssertTrue( l != l2 );

	fprintf( stderr, "--- comparison ---\n" );
	AssertFalse( l < l0 );
	AssertTrue( l == l1 );
	AssertTrue( l <= l1 );
	AssertTrue( l < l2 );
	AssertTrue( l < l3 );
	AssertTrue( l > l0 );
	AssertTrue( l >= l1 );
	AssertFalse( l >= l2 );
	AssertFalse( l > l3 );
}

// -----------------------------------------------------------------------------
void dp_dequetest::test38()
{
	this->set_subtitle( "relational operators - deep pointer(pointer) value" );

	dp_deque<test*>	l0;
	dp_deque<test*>	l1 = { &t1, &t2, &t3 };
	dp_deque<test*>	l2 = { &t1, &t2, &t3, nullptr };
	dp_deque<test*>	l3 = { &t1, &t2, &t3, &t4 };
	dp_deque<test*>	l4 = { &t1, &t2, &t4 };

	dp_deque<test*>	l  = { &t1, &t2, &t3 };


	fprintf( stderr, "--- equality ---\n" );
	AssertTrue( l != l0 );
	AssertTrue( l == l1 );
	AssertTrue( l != l2 );

	fprintf( stderr, "--- comparison ---\n" );
	AssertFalse( l < l0 );
	AssertTrue( l == l1 );
	AssertTrue( l <= l1 );
	AssertTrue( l < l2 );
	AssertTrue( l < l3 );
	AssertTrue( l > l0 );
	AssertTrue( l >= l1 );
	AssertFalse( l >= l2 );
	AssertFalse( l > l3 );
}

// -----------------------------------------------------------------------------
void dp_dequetest::test39()
{
	this->set_subtitle( "relational operators - reference pointer(c-string) value" );

	dr_deque<const char[]>	l0;
	dr_deque<const char[]>	l1 = { s1, s2, s3 };
	dr_deque<const char[]>	l2 = { s1, s2, s3, nullptr };
	dr_deque<const char[]>	l3 = { s1, s2, s3, s4 };
	dr_deque<const char[]>	l4 = { s1, s2, s4 };

	dr_deque<const char[]>	l  = { s1, s2, s3 };


	fprintf( stderr, "--- equality ---\n" );
	AssertTrue( l != l0 );
	AssertTrue( l == l1 );
	AssertTrue( l != l2 );

	fprintf( stderr, "--- comparison ---\n" );
	AssertFalse( l < l0 );
	AssertTrue( l == l1 );
	AssertTrue( l <= l1 );
	AssertTrue( l < l2 );
	AssertTrue( l < l3 );
	AssertTrue( l > l0 );
	AssertTrue( l >= l1 );
	AssertFalse( l >= l2 );
	AssertFalse( l > l3 );
}

// -----------------------------------------------------------------------------
void dp_dequetest::test3A()
{
	this->set_subtitle( "relational operators - deep pointer(c-string) value" );

	dp_deque<const char[]>	l0;
	dp_deque<const char[]>	l1 = { s1, s2, s3 };
	dp_deque<const char[]>	l2 = { s1, s2, s3, nullptr };
	dp_deque<const char[]>	l3 = { s1, s2, s3, s4 };
	dp_deque<const char[]>	l4 = { s1, s2, s4 };

	dp_deque<const char[]>	l  = { s1, s2, s3 };


	fprintf( stderr, "--- equality ---\n" );
	AssertTrue( l != l0 );
	AssertTrue( l == l1 );
	AssertTrue( l != l2 );

	fprintf( stderr, "--- comparison ---\n" );
	AssertFalse( l < l0 );
	AssertTrue( l == l1 );
	AssertTrue( l <= l1 );
	AssertTrue( l < l2 );
	AssertTrue( l < l3 );
	AssertTrue( l > l0 );
	AssertTrue( l >= l1 );
	AssertFalse( l >= l2 );
	AssertFalse( l > l3 );
}

// -----------------------------------------------------------------------------
void dp_dequetest::test3B()
{
	this->set_subtitle( "relational operators - reference pointer(v-array) value" );

	dr_deque<test[]>	l0;
	dr_deque<test[]>	l1 = { v1, v2, v3 };
	dr_deque<test[]>	l2 = { v1, v2, v3, nullptr };
	dr_deque<test[]>	l3 = { v1, v2, v3, v4 };
	dr_deque<test[]>	l4 = { v1, v2, v4 };

	dr_deque<test[]>	l  = { v1, v2, v3 };


	fprintf( stderr, "--- equality ---\n" );
	AssertTrue( l != l0 );
	AssertTrue( l == l1 );
	AssertTrue( l != l2 );

	fprintf( stderr, "--- comparison ---\n" );
	AssertFalse( l < l0 );
	AssertTrue( l == l1 );
	AssertTrue( l <= l1 );
	AssertTrue( l < l2 );
	AssertTrue( l < l3 );
	AssertTrue( l > l0 );
	AssertTrue( l >= l1 );
	AssertFalse( l >= l2 );
	AssertFalse( l > l3 );
}

// -----------------------------------------------------------------------------
void dp_dequetest::test3C()
{
	this->set_subtitle( "relational operators - deep pointer(v-array) value" );

	dp_deque<test[]>	l0;
	dp_deque<test[]>	l1 = { v1, v2, v3 };
	dp_deque<test[]>	l2 = { v1, v2, v3, nullptr };
	dp_deque<test[]>	l3 = { v1, v2, v3, v4 };
	dp_deque<test[]>	l4 = { v1, v2, v4 };

	dp_deque<test[]>	l  = { v1, v2, v3 };


	fprintf( stderr, "--- equality ---\n" );
	AssertTrue( l != l0 );
	AssertTrue( l == l1 );
	AssertTrue( l != l2 );

	fprintf( stderr, "--- comparison ---\n" );
	AssertFalse( l < l0 );
	AssertTrue( l == l1 );
	AssertTrue( l <= l1 );
	AssertTrue( l < l2 );
	AssertTrue( l < l3 );
	AssertTrue( l > l0 );
	AssertTrue( l >= l1 );
	AssertFalse( l >= l2 );
	AssertFalse( l > l3 );
}

// -----------------------------------------------------------------------------
void dp_dequetest::test3D()
{
	this->set_subtitle( "relational operators - reference pointer(f-array) value" );

	dr_deque<test[3]>	l0;
	dr_deque<test[3]>	l1 = { w1, w2, w3 };
	dr_deque<test[3]>	l2 = { w1, w2, w3, nullptr };
	dr_deque<test[3]>	l3 = { w1, w2, w3, w4 };
	dr_deque<test[3]>	l4 = { w1, w2, w4 };

	dr_deque<test[3]>	l  = { w1, w2, w3 };


	fprintf( stderr, "--- equality ---\n" );
	AssertTrue( l != l0 );
	AssertTrue( l == l1 );
	AssertTrue( l != l2 );

	fprintf( stderr, "--- comparison ---\n" );
	AssertFalse( l < l0 );
	AssertTrue( l == l1 );
	AssertTrue( l <= l1 );
	AssertTrue( l < l2 );
	AssertTrue( l < l3 );
	AssertTrue( l > l0 );
	AssertTrue( l >= l1 );
	AssertFalse( l >= l2 );
	AssertFalse( l > l3 );
}

// -----------------------------------------------------------------------------
void dp_dequetest::test3E()
{
	this->set_subtitle( "relational operators - deep pointer(f-array) value" );

	dp_deque<test[3]>	l0;
	dp_deque<test[3]>	l1 = { w1, w2, w3 };
	dp_deque<test[3]>	l2 = { w1, w2, w3, nullptr };
	dp_deque<test[3]>	l3 = { w1, w2, w3, w4 };
	dp_deque<test[3]>	l4 = { w1, w2, w4 };

	dp_deque<test[3]>	l  = { w1, w2, w3 };


	fprintf( stderr, "--- equality ---\n" );
	AssertTrue( l != l0 );
	AssertTrue( l == l1 );
	AssertTrue( l != l2 );

	fprintf( stderr, "--- comparison ---\n" );
	AssertFalse( l < l0 );
	AssertTrue( l == l1 );
	AssertTrue( l <= l1 );
	AssertTrue( l < l2 );
	AssertTrue( l < l3 );
	AssertTrue( l > l0 );
	AssertTrue( l >= l1 );
	AssertFalse( l >= l2 );
	AssertFalse( l > l3 );
}

// -----------------------------------------------------------------------------
void dp_dequetest::test3F()
{
	this->set_subtitle( "relational operators - data(int value) value" );

	std::deque<int>	l0;
	std::deque<int>	l1 = { 1, 2, 3 };
	std::deque<int>	l2 = { 1, 2, 3, 0 };
	std::deque<int>	l3 = { 1, 2, 3, 4 };
	std::deque<int>	l4 = { 1, 2, 4 };

	std::deque<int>	l  = { 1, 2, 3 };


	fprintf( stderr, "--- equality ---\n" );
	AssertTrue( l != l0 );
	AssertTrue( l == l1 );
	AssertTrue( l != l2 );

	fprintf( stderr, "--- comparison ---\n" );
	AssertFalse( l < l0 );
	AssertTrue( l == l1 );
	AssertTrue( l <= l1 );
	AssertTrue( l < l2 );
	AssertTrue( l < l3 );
	AssertTrue( l > l0 );
	AssertTrue( l >= l1 );
	AssertFalse( l >= l2 );
	AssertFalse( l > l3 );
}

// -----------------------------------------------------------------------------
void dp_dequetest::test40()
{
	this->set_subtitle( "list duplication - reference pointer(pointer) value" );

	dr_deque<test*>	l;
	dr_deque<test*>*	p;

	p = dpl( &l );
	AssertTrue( p->empty());
	delete p;

	l.push_back( &t1 );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { &t1 } ));
	delete p;

	l.push_back( &t2 );
	l.push_back( &t3 );
	l.push_back( nullptr );
	l.push_back( &t4 );
	l.push_back( &t5 );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { &t1, &t2, &t3, nullptr, &t4, &t5 } ));
	delete p;
}

// -----------------------------------------------------------------------------
void dp_dequetest::test41()
{
	this->set_subtitle( "list duplication - deep pointer(pointer) value" );

	dp_deque<test*>	l;
	dp_deque<test*>*	p;

	p = dpl( &l );
	AssertTrue( p->empty());
	delete p;

	l.push_back( dpl( &t1 ) );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { &t1 } ));
	delete p;

	l.push_back( dpl( &t2 ) );
	l.push_back( dpl( &t3 ) );
	l.push_back( nullptr );
	l.push_back( dpl( &t4 ) );
	l.push_back( dpl( &t5 ) );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { &t1, &t2, &t3, nullptr, &t4, &t5 } ));
	delete p;
}

// -----------------------------------------------------------------------------
void dp_dequetest::test42()
{
	this->set_subtitle( "list duplication - reference pointer(c-string) value" );

	dr_deque<const char[]>	l;
	dr_deque<const char[]>*	p;

	p = dpl( &l );
	AssertTrue( p->empty());
	delete p;

	l.push_back( s1 );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { s1 } ));
	delete p;

	l.push_back( s2 );
	l.push_back( s3 );
	l.push_back( nullptr );
	l.push_back( s4 );
	l.push_back( s5 );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { s1, s2, s3, nullptr, s4, s5 } ));
	delete p;
}

// -----------------------------------------------------------------------------
void dp_dequetest::test43()
{
	this->set_subtitle( "list duplication - deep pointer(c-string) value" );

	dp_deque<const char[]>	l;
	dp_deque<const char[]>*	p;

	p = dpl( &l );
	AssertTrue( p->empty());
	delete p;

	l.push_back( strdup( s1 ) );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { s1 } ));
	delete p;

	l.push_back( strdup( s2 ) );
	l.push_back( strdup( s3 ) );
	l.push_back( nullptr );
	l.push_back( strdup( s4 ) );
	l.push_back( strdup( s5 ) );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { s1, s2, s3, nullptr, s4, s5 } ));
	delete p;
}

// -----------------------------------------------------------------------------
void dp_dequetest::test44()
{
	this->set_subtitle( "list duplication - reference pointer(v-array) value" );

	dr_deque<test[]>	l;
	dr_deque<test[]>*	p;

	p = dpl( &l );
	AssertTrue( p->empty());
	delete p;

	l.push_back( v1 );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { v1 } ));
	delete p;

	l.push_back( v2 );
	l.push_back( v3 );
	l.push_back( nullptr );
	l.push_back( v4 );
	l.push_back( v5 );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { v1, v2, v3, nullptr, v4, v5 } ));
	delete p;
}

// -----------------------------------------------------------------------------
void dp_dequetest::test45()
{
	this->set_subtitle( "list duplication - deep pointer(v-array) value" );

	dp_deque<test[]>	l;
	dp_deque<test[]>*	p;

	p = dpl( &l );
	AssertTrue( p->empty());
	delete p;

	l.push_back( dpl( v1 ) );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { v1 } ));
	delete p;

	l.push_back( dpl( v2 ) );
	l.push_back( dpl( v3 ) );
	l.push_back( nullptr );
	l.push_back( dpl( v4 ) );
	l.push_back( dpl( v5 ) );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { v1, v2, v3, nullptr, v4, v5 } ));
	delete p;
}

// -----------------------------------------------------------------------------
void dp_dequetest::test46()
{
	this->set_subtitle( "list duplication - reference pointer(f-array) value" );

	dr_deque<test[3]>	l;
	dr_deque<test[3]>*	p;

	p = dpl( &l );
	AssertTrue( p->empty());
	delete p;

	l.push_back( w1 );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { w1 } ));
	delete p;

	l.push_back( w2 );
	l.push_back( w3 );
	l.push_back( nullptr );
	l.push_back( w4 );
	l.push_back( w5 );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { w1, w2, w3, nullptr, w4, w5 } ));
	delete p;
}

// -----------------------------------------------------------------------------
void dp_dequetest::test47()
{
	this->set_subtitle( "list duplication - deep pointer(f-array) value" );

	dp_deque<test[3]>	l;
	dp_deque<test[3]>*	p;

	p = dpl( &l );
	AssertTrue( p->empty());
	delete p;

	l.push_back( dpl( w1 ) );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { w1 } ));
	delete p;

	l.push_back( dpl( w2 ) );
	l.push_back( dpl( w3 ) );
	l.push_back( nullptr );
	l.push_back( dpl( w4 ) );
	l.push_back( dpl( w5 ) );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { w1, w2, w3, nullptr, w4, w5 } ));
	delete p;
}

// -----------------------------------------------------------------------------
void dp_dequetest::test48()
{
	this->set_subtitle( "list duplication - data(int value) value" );

	std::deque<int>	l;
	std::deque<int>*	p;

	p = dpl( &l );
	AssertTrue( p->empty());
	delete p;

	l.push_back( 1 );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { 1 } ));
	delete p;

	l.push_back( 2 );
	l.push_back( 3 );
	l.push_back( 0 );
	l.push_back( 4 );
	l.push_back( 5 );
	p = dpl( &l );
	AssertTrue( check_deque( *p, { 1, 2, 3, 0, 4, 5 } ));
	delete p;
}

// -----------------------------------------------------------------------------
void dp_dequetest::test49()
{
	this->set_subtitle( "heterogenious list" );

	dp_deque<base*>	l = { &t1, &u2, &i3, &u4, &t5, &t6, &i7 };

	print( l );
	AssertEqual( 7, l.size());
}

// -----------------------------------------------------------------------------
void dp_dequetest::test4A()
{
	this->set_subtitle( "temporal" );

	dp_deque<test*>	n;
	dp_deque<test*> l = { &t1, &t2, &t3 };

	n = l;

	print( n );
}

// Main
// -----------------------------------------------------------------------------
int main( int argc, char** argv )
{
	dp_dequetest( argc, argv ).run();
	return 0;
}
